<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Algorithm - Two Pointers and Sliding Window">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm - Two Pointers and Sliding Window">
<meta property="og:url" content="http://example.com/2023/03/08/Algorithm%20-%20Two%20Pointers%20and%20Sliding%20Window/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:description" content="Algorithm - Two Pointers and Sliding Window">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://leetcode.com/media/original_images/121_profit_graph.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg">
<meta property="og:image" content="https://assets.leetcode.com/users/images/99b64bb7-85d3-454e-a800-0a76cd905ef5_1637980713.7155366.png">
<meta property="og:image" content="https://assets.leetcode.com/users/images/494f2123-8fcc-455a-8a67-0968223ba270_1642736908.3527038.png">
<meta property="article:published_time" content="2023-03-08T14:18:59.000Z">
<meta property="article:modified_time" content="2023-03-11T05:09:36.694Z">
<meta property="article:author" content="Francis">
<meta property="article:tag" content="Two Pointers and Sliding Window">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leetcode.com/media/original_images/121_profit_graph.png">

<link rel="canonical" href="http://example.com/2023/03/08/Algorithm%20-%20Two%20Pointers%20and%20Sliding%20Window/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Algorithm - Two Pointers and Sliding Window | FrancisTan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FrancisTan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just For Fun</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/08/Algorithm%20-%20Two%20Pointers%20and%20Sliding%20Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Algorithm - Two Pointers and Sliding Window
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-08 22:18:59" itemprop="dateCreated datePublished" datetime="2023-03-08T22:18:59+08:00">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-11 13:09:36" itemprop="dateModified" datetime="2023-03-11T13:09:36+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Algorithm-Two-Pointers-and-Sliding-Window"><a href="#Algorithm-Two-Pointers-and-Sliding-Window" class="headerlink" title="Algorithm - Two Pointers and Sliding Window"></a>Algorithm - Two Pointers and Sliding Window</h1><span id="more"></span>


<h3 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>Two Pointer 與 Sliding Window 都是蠻常聽到的一種解題常用的技巧，也可以說是演算法的解題 pattern，目的在於減少迴圈的使用，亦即降低時間複雜度。而 Two Pointer 又可以分為左右指標與快慢指標兩種，Sliding Window 則可以算是廣義的左右指標中的一種。</p>
<br/>

<h3 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h3><ol>
<li>使用時機：<br>當題敘符合以下幾類特徵時，要想到有使用two pointers的可能。<ul>
<li>資料結構<ul>
<li>array, subarray</li>
<li>string, substring</li>
<li>linked list</li>
</ul>
</li>
<li>題目所求<ul>
<li>maximum, minimum</li>
<li>longest, largest</li>
<li>sum</li>
</ul>
</li>
</ul>
</li>
<li>確認限制：<br>即「current interval 應該包含哪些東西」或是「不能包括哪些東西」。</li>
<li>確認移動的標的及方向：<br>即「current interval」若符合限制時應該移動哪一根pointer、往哪移動，若不符合限制時又該移動哪一根pointer、往哪移動。</li>
</ol>
<br/>

<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><h3 id="Substring-Problems："><a href="#Substring-Problems：" class="headerlink" title="Substring Problems："></a>Substring Problems：</h3><h4 id="Problem1-Longest-Palindromic-Substring"><a href="#Problem1-Longest-Palindromic-Substring" class="headerlink" title="Problem1. Longest Palindromic Substring"></a>Problem1. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></h4><ul>
<li>確認限制：區間內應該要是回文</li>
<li>擴展方式：由中心(note: 可以是奇數或偶數回文)往兩側擴散</li>
</ul>
<p>Method1：Expand from every center<br>time：$ O(n^2) $<br>space：$ O(1) $<br>解題：</p>
<ol>
<li>新增一個函式，利用兩個變數(left_pos、right_pos)將每個character視為center，同步往左右兩邊擴展，一一比對左右兩個char是否相同，若相同就繼續擴展，直到左右不一樣或是左右某一個char超出string的範圍時，就回傳左右的位置（Note：迴圈中斷時，要馬是(1)左右兩個char不相同，或是(2)左右之中至少一個超出string的範圍，所以在回傳left_pos、right_pos之前需要將left +&#x3D; 1、right -&#x3D;1）</li>
<li>palindrome有兩種：(1)長度為奇數，e.g “aba”  (2)長度為偶數，e.g. “abba”，所以這兩種情形都要考慮到，即對於string的每個char，都要進行兩次expand，一次為current char當作center、一次為current char和其next char當作center</li>
<li>注意題目是問最長的回文，所以在解題時其實只要maintain相距最遠的left_pos, right_pos就好，即初始化兩個變數start, end為零，檢查每次expand回傳的left_pos, right_pos，若有比start, end相距還遠，就更新start, end，最後再return “string[start : end+1]”即可（這樣就不用浪費O(n)的空間去真的maintain一個longest string）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n^2)</span></span><br><span class="line"><span class="string">    space: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand</span>(<span class="params">s, idx, one</span>):</span><br><span class="line">            <span class="keyword">if</span> one:</span><br><span class="line">                l = idx - <span class="number">1</span></span><br><span class="line">                r = idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = idx - <span class="number">1</span></span><br><span class="line">                r = idx + <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r]:</span><br><span class="line">                    l -= <span class="number">1</span></span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> l, r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maintain</span>(<span class="params">l, r, s, e</span>):</span><br><span class="line">            <span class="keyword">if</span> (r - l) &gt; (e - s):</span><br><span class="line">                s = l</span><br><span class="line">                e = r</span><br><span class="line">            <span class="keyword">return</span> s, e</span><br><span class="line"></span><br><span class="line">        idx, start, end = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            l, r = expand(s, idx, <span class="literal">True</span>)</span><br><span class="line">            start, end = maintain(l, r, start, end)</span><br><span class="line">            <span class="keyword">if</span> idx + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[idx] == s[idx+<span class="number">1</span>]:</span><br><span class="line">                l, r = expand(s, idx, <span class="literal">False</span>)</span><br><span class="line">                start, end = maintain(l, r, start, end)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<br/>

<p>Method2：dynamic programming<br>先備知識：DP</p>
<ol>
<li>DP的核心觀念：將一個問題切成子問題，將子問題切成子子問題，以此類推，並透過儲存每一次的計算成果，達到減少重複計算的目的</li>
<li>儲存計算結果的方式通常為1D-table或是2D-table </li>
<li>就如同遞迴函式一樣，DP一定會有基本(初始)條件，所以在建完用來儲存計算結果的表後，我們通常需要assign一些值進去</li>
<li>續(3)：舉個基本條件的例子，以計算階乘為例，我們知道n! &#x3D; (n-1)! * n，而1! &#x3D; 1，所以我們可以利用”1! &#x3D; 1”這個基本條件去計算2以後的所有階乘，可以列出以下式子 → For function f(n): (1)f(n) &#x3D; 1 , n &#x3D;&#x3D; 1 (2)f(n) &#x3D; f(n-1)*n , n ≥ 2</li>
</ol>
<p>time：$ O(n^2) $<br>space：$ O(n^2) $<br>解題：</p>
<ol>
<li>此題利用DP的精髓在於：若s[ i ] &#x3D;&#x3D; s[ j ]，且s[ i+1 : j-1 ]為palindrome，則s[ i : j ]為palindrome，如此達到”重複利用先前計算結果”的效果，所以2D-table的任一entry實際上為bool，即table[ i ][ j ]代表的就是s[ i : j ]是否為palindrome</li>
<li>上述先備知識(3)應用於此題為：每單一個char自己就是palindrome，所以在建完2D-table後，需要將table[ 1 ][ 1 ], table[ 2 ][ 2 ] … 等初始化為True</li>
<li>利用double for loops分別去迭代start_pos, end_pos，並利用兩個變數leftmost、rightmost去maintain最長的回文區間，當s[ start_pos ] &#x3D;&#x3D; s[ end_pos]時，需要更新table有兩種情形：<ol>
<li>end_pos -  start_pos &#x3D;&#x3D; 1：表示為偶數的回文</li>
<li>s[start_pos+1 : end_pos-1]為palindrome(去table看)<br> 以上兩種皆為有效的palindrome，此時就檢查當前區段是否為longest，是的話就更新leftmost、rightmost，並更新table[start_pos][end_pos]為True</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/solutions/474664/commented-clean-python-dp-solution/#:~:text=hungapp,end">(explanation見評論區)</a>)<br> 由於我們想要以最短的substring為開始去填dp table，迴圈(start, end)的設置必須是由”短到長”，e.g. s &#x3D; “abba”，double for loops的起始點(start_pos, end_pos)依序為”ab”, “bb”, “ba”，而非”ab”, “ab”, “aa”，這是由於觀念(1)，我們現在考慮start_pos, end_pos分別在first “a”, last “a”，演算法會去table看”bb”是否為palindrome，而若我們不是由”短到長”去iterate的話，此時”bb”根本還沒被iterate到，因此無法找出所求，反之則可以求出正解<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp</span></span><br><span class="line"><span class="string">    time: O(n^2)</span></span><br><span class="line"><span class="string">    space: O(n^2)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dp = [[<span class="literal">False</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">        leftmost, rightmost = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(end-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[start] == s[end]:</span><br><span class="line">                    <span class="keyword">if</span> (end - start == <span class="number">1</span>) <span class="keyword">or</span> (dp[start+<span class="number">1</span>][end-<span class="number">1</span>] == <span class="literal">True</span>):</span><br><span class="line">                        dp[start][end] = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">if</span> (end - start) &gt; (rightmost - leftmost):</span><br><span class="line">                            leftmost = start</span><br><span class="line">                            rightmost = end</span><br><span class="line">        <span class="keyword">return</span> s[leftmost:rightmost+<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br/></li>
</ol>
<h4 id="Problem2-Longest-Substring-Without-Repeating-Characters"><a href="#Problem2-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Problem2. Longest Substring Without Repeating Characters"></a>Problem2. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></h4><ul>
<li>確認限制：區間內應該不能有repeating characters</li>
<li>擴展方式：<ul>
<li>if current window is valid: pointer right往右擴展。</li>
<li>if not valid: 將pointer left往前拉到”repeating char”的下一格。</li>
</ul>
</li>
</ul>
<p>Method1：two pointers - sliding window(best solution)<br>time：$ O(n) $<br>space：$ O(n) $<br>解題：</p>
<ol>
<li>利用hashmap去紀錄每一個char的idx</li>
<li>利用兩個變數left, right，left一開始為零、right則是一直往前跑，當出現repeating char時可分為兩種情況：<ol>
<li>repeating char在[left, right]區間裡：將left往前拉到repeating char的next position，因為對於現在區間而言若left還停留在repeating char之前，則[left, right]無論如何都不會是longest panlindrome，且更新hashmap的idx為right的位置</li>
<li>repeating char不在[left, right]區間裡：考慮case “tmmzuxt”，t為duplicates，只是當第二個t被traverse到的時候，第一個t已不在[left, right]區間內，所以可以照常計算max_len</li>
</ol>
</li>
<li>若沒有出現2-(a)的情況則計算當前長度以持續維護max_len<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    space: O(n)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> (char <span class="keyword">in</span> hashmap) <span class="keyword">and</span> (hashmap[char] &gt;= l):</span><br><span class="line">                l = hashmap[char] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, r - l + <span class="number">1</span>)</span><br><span class="line">            hashmap[char] = r</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<br/></li>
</ol>
<h4 id="Problem3-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#Problem3-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="Problem3 Longest Substring with At Least K Repeating Characters"></a>Problem3 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/">Longest Substring with At Least K Repeating Characters</a></h4><ul>
<li>確認限制：<ul>
<li>區間內unique char的數量必須$ &lt;&#x3D; $該次迭代的數量限制。</li>
<li>區間內任一char的出現次數必須$ &lt;&#x3D; $ K。</li>
</ul>
</li>
<li>擴展方式：<ul>
<li>if current window is valid: pointer right往右擴展。</li>
<li>if not valid: 將pointer left往前移，直到unique char的數量$\leq$該次迭代的數量限制</li>
</ul>
</li>
</ul>
<p>Method1：sliding window(best solution)</p>
<p>時間：$ O(26*n) $ &#x3D; $ O(n) $, given that the number of alphabet is 26, and the n is the length of “s”</p>
<p>空間：$ O(n) $, which is the cost of hashmap used to count frequency of charactersproblem.</p>
<p>觀念：<br>這題看完題敘可以蠻直觀地想到要用sliding window，但困難的點在於，考慮case<code>s = aabbb...</code> and <code>k = 3</code>，當我們traverse到”aabbb”這個區間時(i.e. left&#x3D;0, right&#x3D;4)問題來了，究竟我們是要(1)繼續擴展pointer right然後期望我們會遇到下一個”a”，還是(2)放棄”aa”，將pointer left往前拉到first b的位置？答案是無法確定，所以有了以下的解法：</p>
<ol>
<li>既然我們已知s一定只包含lowercase English letters，那大不了就是在一開始先看s總共包含幾種characters，假設今天s有8種char，我們就從「僅有一個unique char的所有sliding windows」，一直測試到「包含8個unique char的所有sliding windows」，這樣一定可以找到題目所求的longest substring。</li>
<li>the outermost loop為「1 to ”the number of unique char in s”」，接著For每一個迭代，我們都初始化left &#x3D; 0、right &#x3D; 0 to len(s)，並利用一個hashmap(say, counter_curr)去統計current sliding window內每個char的數量：<ol>
<li>當current sliding window內「unique char的數量」&gt; 該次iteration所限制的數量：<br> 此時我們要”shrink sliding window”(i.e. 將pointer left往前拉)直到window內unique char的數量符合限制，而具體作法不只是讓left +&#x3D; 1，還要去counter_curr將left所指的char次數減一，且當次數歸零時，我們要將其從counter_curr pop掉(這樣hashmap長度才會減少)。</li>
<li>當current sliding window內「unique char的數量」≤ 該次iteration所限制的數量：<br> 代表此刻的sliding window是一個”valid”的window，我們就可以透過counter_curr去檢查這些char的數量是否都有≥K，如果有，我們就利用$ max(maxLen,;r-l+1) $去保存最大長度，並且繼續擴展我們的window，直到某天window的unique char數量超出限制 或是 right超出s的長度。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: sliding window(best solution)</span></span><br><span class="line"><span class="string">    time: O(26*n) = O(n), given that the number of alphabet is 26, and the n is the length of &quot;s&quot;</span></span><br><span class="line"><span class="string">    space: O(n), which is the cost of hashmap used to count frequency of characters</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        counter_all = Counter(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> nums_char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(counter_all)+<span class="number">1</span>):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            counter_curr = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                counter_curr[s[right]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(counter_curr) &gt; nums_char:</span><br><span class="line">                    counter_curr[s[left]] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> counter_curr[s[left]] == <span class="number">0</span>:</span><br><span class="line">                        counter_curr.pop(s[left])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">all</span>([v &gt;= k <span class="keyword">for</span> key, v <span class="keyword">in</span> counter_curr.items()]):</span><br><span class="line">                    max_len = <span class="built_in">max</span>(max_len, right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<br/>

<h3 id="Subarray-Problems："><a href="#Subarray-Problems：" class="headerlink" title="Subarray Problems："></a>Subarray Problems：</h3><h4 id="Problem1-Maximum-Subarray"><a href="#Problem1-Maximum-Subarray" class="headerlink" title="Problem1. Maximum Subarray"></a>Problem1. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a></h4><p>此題使用two pointers(i.e. curr_sum, max_sum，分別代表當前區間的加總、目前為止所出現的最大加總)，比較沒有那麼明顯的sliding window區間。</p>
<ul>
<li>確認限制：當前區間內的加總不能為負，一旦為負就要將其歸零，代表從下一個開始重新計算加總。</li>
<li>擴展方式：一路往右擴展。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.interviewbit.com/blog/maximum-subarray-sum/">Method1：<strong>Kadane’s Algorithm</strong></a><br>時間：$ O(n) $<br>空間：$ O(1) $<br>觀念：</p>
<ol>
<li><p>利用兩個變數curr_sum、maximum分別去紀錄當前的加總以及最大加總，且一開始將curr_sum和maximum初始化為nums[0](畢竟returned answer至少須為陣列中的某個數)：</p>
<ol>
<li>maximum &#x3D; max(maximum, curr_sum)</li>
<li>if curr_sum &lt; 0 : curr_sum &#x3D; 0</li>
</ol>
</li>
<li><p>此算法的核心概念為1-b：當curr_sum為負時，我們要將其歸零，這是因為當curr_sum為負時，表示”current position以前”的那坨數對於”current position以後”的數(不管之後的數為何)都是”拖油瓶”，它們只會讓以後的加總”更小”，而既然到”目前為止”的最大加總都已經被maximum紀錄起來了，我們就可以放心的放棄之前看過的累積值(curr_sum)並將其歸零重新開始計算</p>
</li>
<li><p>Ex: [3, -5, 2, 2] :</p>
<table>
<thead>
<tr>
<th>i</th>
<th>curr_sum</th>
<th>maximum</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>-2 → 0</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: $ O(n) $</span></span><br><span class="line"><span class="string">    space: $ O(1) $</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tmp_sum = <span class="number">0</span></span><br><span class="line">        maximum = -<span class="number">10001</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tmp_sum += num</span><br><span class="line">            maximum = <span class="built_in">max</span>(maximum, tmp_sum)</span><br><span class="line">            <span class="keyword">if</span> tmp_sum &lt; <span class="number">0</span>:</span><br><span class="line">                tmp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> maximum</span><br></pre></td></tr></table></figure>

<br/>

<h4 id="Problem2-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem2-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem2. Best Time to Buy and Sell Stock"></a>Problem2. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Best Time to Buy and Sell Stock</a></h4><p>此題使用two pointers(i.e. buy_price, max_profit，分別代表購買價格(亦即到目前為止的最小值)、到目前為止的最大利潤)，比較沒有那麼明顯的sliding window區間。</p>
<ul>
<li>確認限制：<ul>
<li>一定要包含「到目前為止的最小值」。</li>
<li>一定要計算出「到目前為止的最大差值」(i.e. max_profit)</li>
</ul>
</li>
<li>擴展方式：一路往右擴展，若出現比「當前最小值」更小的值，更新buy_price。</li>
</ul>
<p>示意圖：<br><img src="https://leetcode.com/media/original_images/121_profit_graph.png" alt="image alt"></p>
<p>Method1 : two pointers<br>time: $ O(n) $<br>space: $ O(1) $<br>觀念：</p>
<ul>
<li>profit最重要的就是買、賣價 → 所以想到用two pointers去紀錄</li>
<li>架構：初始化purchase_price、max_profit，一邊維護這兩個變數一邊遍歷陣列</li>
<li>主體：<ol>
<li>先比較current price和purchase_price<ol>
<li>current price &lt; purchase_price → 無利可圖，但需要更新purchase_price(買低就是賺)</li>
<li>current price ≥ purchase_price → 去看max_profit</li>
</ol>
</li>
<li>若情況為1-b，看當前利潤是否大於最大利潤 → $max(maxProfit,;currentPrice;-;purchasePrice)$</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        purchase_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> p &lt; purchase_price:</span><br><span class="line">                purchase_price = p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_profit = <span class="built_in">max</span>(max_profit, p - purchase_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<br/>

<h4 id="Problem3-Container-With-Most-Water"><a href="#Problem3-Container-With-Most-Water" class="headerlink" title="Problem3. Container With Most Water"></a>Problem3. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/description/">Container With Most Water</a></h4><ul>
<li>確認限制：沒有特別限制。</li>
<li>擴展方式：從兩邊往中間夾，每次移動「較矮的那根」，直到left, right碰到。</li>
</ul>
<p>示意圖：<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="image alt"></p>
<p>Method1：Two pointers - sliding window(best solution)<br>time：$ O(n) $<br>space：$ O(1) $<br>concept：由於是算面積，要想到用”夾住”的概念(top down)，即一開始就直接考慮最寬的情況，然 後慢慢往內縮<br>main：</p>
<ol>
<li>每次都移動較矮的那根，試想，如果是移動較高的那根只會有兩種情況，(1): 新的那根高於較矮的那根，此情況則還是會以矮的那根為主 (2): 新的那根低於較矮的那根，此情況面積只會更小，所以以上兩種情況都沒有意義。</li>
<li>濃縮1.的概念，由於一開始已經是從”最寬”的情況往內縮，所以得到較大面積唯一的可能為找到比當前更高的高度，則只有移動矮的那根才可能做得到。</li>
</ol>
<p>terminal condition：當兩個pointer碰到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        max_cont = (right - left) * <span class="built_in">min</span>(height[left], height[right])</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            new_cont = (right - left) * <span class="built_in">min</span>(height[left], height[right])</span><br><span class="line">            max_cont = <span class="built_in">max</span>(max_cont, new_cont)</span><br><span class="line">        <span class="keyword">return</span> max_cont</span><br></pre></td></tr></table></figure>
<br/>

<h4 id="Problems4-Product-of-Array-Except-Self"><a href="#Problems4-Product-of-Array-Except-Self" class="headerlink" title="Problems4. Product of Array Except Self"></a>Problems4. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">Product of Array Except Self</a></h4><ul>
<li>確認限制：two pointers - prefix, suffix<ul>
<li>pointer left代表「從左到自己前一格」的prefix product。</li>
<li>pointer right代表「從右到自己後一格」的suffix product。</li>
</ul>
</li>
<li>擴展方式：一個由前往後、一個由後往前移動，當兩方「開始交匯」的時候，就是「答案開始生成」的時候。</li>
</ul>
<p>示意圖：<br><img src="https://assets.leetcode.com/users/images/99b64bb7-85d3-454e-a800-0a76cd905ef5_1637980713.7155366.png" alt="image alt"></p>
<p>既然題目是計算「除了本身之外的乘積」，那就想辦法湊出「從前面乘過來」(prefix)以及「從後面乘過來」(suffix)。</p>
<p>Method1：prefix &amp; suffix (two-pass)</p>
<p>時間：O(2n) &#x3D; O(n)</p>
<p>空間：O(1), note that the array used to store the answer is not counted as extra space in this problem.</p>
<p>觀念：</p>
<ol>
<li>利用一個陣列prefix儲存prefix product的計算結果，陣列中每個位置pos為「pos之前」的乘積(不包含pos本身)，Note: nums[0]之前沒有東西，所以prefix[0]初始化為1。</li>
<li>得到prefix陣列後，我們預期要將陳列中的每個值乘以suffix以得到答案，所以這次我們由後往前遍歷，並利用一個變數suffix(Note: nums[-1]之後沒有東西，所以suffix初始化為1)代表nums中每個位置其所對應的後綴乘積。</li>
<li>如此由後往前將prefix[i] * suffix即可得到in place的答案。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: prefix &amp; suffix (two-pass)</span></span><br><span class="line"><span class="string">    time: O(2n) = O(n)</span></span><br><span class="line"><span class="string">    space: O(1), note that the array used to store the answer is not counted as extra space in this problem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        prefix = [<span class="number">1</span>]</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            prefix.append(prefix[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>])</span><br><span class="line">        suffix = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            prefix[i] *= suffix</span><br><span class="line">            suffix *= nums[i]</span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure></li>
</ol>
<br/>

<p>Method2：prefix &amp; suffix (one-pass, best solution)</p>
<p>時間：O(n)</p>
<p>空間：O(1), note that the array used to store the answer is not counted as extra space in this problem.</p>
<p>觀念：</p>
<ol>
<li><p>Method1需要兩個for loops：(1)建立prefix (2)乘以suffix並得出答案，然而其實不用先將每個prefix都儲存下來，若我們將prefix、suffix視為兩個pointer，一個「由前往後遍歷」、一個「由後往前遍歷」，沿途持續更新這兩個變數並將nums每個位置所對應的prefix和suffix product儲存起來，試想，當兩個pointer「開始發生交錯」時，理論上即可算出所求。</p>
<p> Ex: nums &#x3D; [2,3,4,5]</p>
<table>
<thead>
<tr>
<th>iteration</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
</tr>
<tr>
<td>suffix</td>
<td>1</td>
<td>5</td>
<td>20</td>
<td>60</td>
</tr>
</tbody></table>
<p> For iteration: 0~4, ans:</p>
<table>
<thead>
<tr>
<th>iteration</th>
<th>pos 0</th>
<th>pos 1</th>
<th>pos 2</th>
<th>pos 3</th>
</tr>
</thead>
<tbody><tr>
<td>0(初始化)</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>40</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>60</td>
<td>40</td>
<td>30</td>
<td>24</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: prefix &amp; suffix (one-pass, best solution)</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    space: O(1), note that the array used to store the answer is not counted as extra space in this problem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        prefix, suffix = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        forward, backward = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> forward &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            ans[forward] *= prefix</span><br><span class="line">            prefix *= nums[forward]</span><br><span class="line">            ans[backward] *= suffix</span><br><span class="line">            suffix *= nums[backward]</span><br><span class="line">            forward += <span class="number">1</span></span><br><span class="line">            backward -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<br/>

<h4 id="Problems5-Maximum-Product-Subarray"><a href="#Problems5-Maximum-Product-Subarray" class="headerlink" title="Problems5. Maximum Product Subarray"></a>Problems5. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/description/">Maximum Product Subarray</a></h4><ul>
<li>確認限制：two pointers - maximum, minimum<ul>
<li>maximum代表到目前為止的最大值。</li>
<li>minimum代表到目前為止的最小值。</li>
</ul>
</li>
<li>擴展方式：就是遍歷整個陣列。</li>
</ul>
<p>Method1：Two pointers(maintain max and min)(best solution)</p>
<p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用兩個變數”curr_max”, ”curr_min”去maintain在陣列中到任一位置 i 的最大最小值，值得思考的是題目所求為「最大乘積」，那為何會需要maintain一個最小值？因為在陣列中我們有可能會遇到「負值」，此時若什麼都不做就乘下去會使得「大的變成小的、小的變成大的」，所以我們需要一個「最小值幫手」，讓我們在遇到負值時依然可以維護正確的極值。</li>
<li>續(1)，當我們遇到負值時，就將”curr_max”, ”curr_min”互換，如此各自乘以該負值得到的乘積才會是正確的，另外，要知道對於陣列中的每個數，有時候不乘反而更貼近我們想要的結果(e.g. 考慮求nums &#x3D; [-8, 8]的max product → ans &#x3D; 8)，所以我們每次都要拿極值與”其本身”作比較(i.e. 我們有「乘」與「不乘」兩種選擇) → $Let ; i ;be ; [1, ;len(nums))$<ol>
<li>$currMax &#x3D; max(nums[i],;nums[i]*currMax)$</li>
<li>$currMin &#x3D; min(nums[i],;nums[i]* currMin)$</li>
<li>$ans &#x3D; max(ans,; currMax)$</li>
</ol>
</li>
<li>最後return ans即為所求。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: two pointers</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    space: O(1) </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        curr_max, curr_min, ans = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                curr_max, curr_min = curr_min, curr_max</span><br><span class="line">            curr_max = <span class="built_in">max</span>(nums[i], curr_max * nums[i])</span><br><span class="line">            curr_min = <span class="built_in">min</span>(nums[i], curr_min * nums[i])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr_max)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<br/>

<h4 id="Problems6-Gas-Station"><a href="#Problems6-Gas-Station" class="headerlink" title="Problems6. Gas Station"></a>Problems6. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/gas-station/">Gas Station</a></h4><ul>
<li>確認限制：two pointers - total_surplus, curr_surplus<ul>
<li>total_surplus代表遍歷完整個陣列的剩餘油量。</li>
<li>curr_surplus代表到「當前里程區間的剩餘油量」，若在position i &lt; 0就要歸零，代表從i+1重新開始計算。</li>
</ul>
</li>
<li>擴展方式：遍歷整個陣列，且當curr_surplus &lt; 0，更新start position。</li>
</ul>
<p>示意圖：<br><img src="https://assets.leetcode.com/users/images/494f2123-8fcc-455a-8a67-0968223ba270_1642736908.3527038.png" alt="image alt"></p>
<p>Method1：two pointers(best solution)</p>
<p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li><p>將gas, cost兩個陣列想像成一個陣列( arr[i] &#x3D; gas[i] - cost[i] )，arr[i]表示從 i 開到 i + 1所剩下的油量，將arr的每個element加總，由於不論從哪個起始點開始，車子繞一圈相當於就是在將陣列中的「所有elements」做加總，只是順序不同罷了(起始點不同)，所以：</p>
<ol>
<li>若≥0: 表示一定存在有效的起始點  </li>
<li>反之: 不存在有效起始點</li>
</ol>
</li>
<li><p>此題最關鍵的概念：若從某起始點”s”只能開到另一點”e”(油不夠開到e+1)，則[s, e]這段區間都不會有有效的起始點，所以此時應該要跨過這個區間直接從”e+1”繼續。</p>
<p> 反證法：假設[s, e]存在有效的起始點</p>
<p> (1)let’s say start from “s+1”，For sum(s+1, s+2, …, e) &gt; 0 (?)，已知起始點(s)必為正，所以<br> sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+1, s+2, …, e) &lt; 0</p>
<p> (2)let’s say start from “s+2”，For sum(s+2, s+3, …, e) &gt; 0 (?)，已知sum(s, s+1)必為正(否則車子開不到s+2)，因此sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+2, s+3, …, e) &lt; 0</p>
<p> → 以此類推即可得證。</p>
</li>
<li><p>實際操作：</p>
<ol>
<li>用變數curr_surplus對”當前幾個”elements進行加總，在陣列中的任一位置，若curr_surplus&lt;0表示車只能開到該位置，此時根據觀念(2)，我們將curr_surplus歸零，並把起始點往前拉到該位置的下一個位置，繼續演算法。</li>
<li>用變數total_surplus對陣列中的每個elements進行加總，迴圈結束後若total_surplus&lt;0表示不存在有效起始點，反之則一定存在有效起始點(此時return該起始點)。</li>
<li>若看code會發現一個容易產生疑慮的地方：”start &#x3D; i + 1”這行，不禁讓人思考若i此時為last element則start不是就超出陣列長度了嗎？<br> Ans: 若i為last element且被+1，表示車子開到last position(i)勢必會沒油，而不管從哪個起始點開始繞一圈車子一定會經過last position，所以可得陣列一定不存在有效起始點(i.e. total_surplus勢必&lt;0，演算法會return -1)。</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    space: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_surplus = <span class="number">0</span></span><br><span class="line">        curr_surplus = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            total_surplus += gas[i] - cost[i]</span><br><span class="line">            curr_surplus += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> curr_surplus &lt; <span class="number">0</span>:</span><br><span class="line">                curr_surplus = <span class="number">0</span></span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> total_surplus &lt; <span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure>

<br/>

<h4 id="Problems7-3Sum"><a href="#Problems7-3Sum" class="headerlink" title="Problems7. 3Sum"></a>Problems7. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/">3Sum</a></h4><ul>
<li>確認限制：無特別限制。</li>
<li>擴展方式：從兩側往中間夾，由於區間內為sorted，看是希望加總變大還是變小<ul>
<li>要變大：pointer left往右移。</li>
<li>要變小：pointer right往左移。</li>
<li>等於目標：兩根同時往中間移。</li>
</ul>
</li>
</ul>
<p>Method1：Two pointers - sliding window(best solution)</p>
<p>time：O(n^2)</p>
<p>space：O(n)</p>
<p>觀念：</p>
<p>set</p>
<ol>
<li>由於題目要求三個數不能有duplicates，且不要求順序，所以使用set來存取答案 → set的unique property：<ol>
<li>當set裡存的是一個個number → 只要值不同就可以被存入 </li>
<li>當set裡存的是一個個tuple(set只能存hashable object) → 只要tuple裡的值順序不同就可以被存入，e.g. (1,2,3) &amp; (1,3,2)→可以、(1,2,3) &amp; (1,2,3)→不行</li>
</ol>
</li>
<li>插入：set.add(<hashable object>)，e.g. tuple &#x3D; (1,2,3), set.add(tuple)</li>
<li>刪除：set.remove(<hashable object>)，e.g. set.remove(tuple) </li>
<li>註：”All of Python’s immutable built-in objects are hashable”，所以set可以存tuple(不可被修改)，但不能存lists, sets</li>
</ol>
<p>two pointers </p>
<ol>
<li>先排序number array，從左到右(len-2)iterate，將current pointer(i)視為base number，剩下的兩個數則是我們要找的target，也就是-1*base number </li>
<li>利用left(i+1), right(last element)去夾住base number之後的elements：<ol>
<li>while condition：由於題目要求三個數的index不能重複，所以條件會是while left &lt; right</li>
<li>當(left + right) &lt; target : 表示要變大，所以left往右移動一格 </li>
<li>當(left + right) &gt; target : 表示要變小，所以right左移動一格 </li>
<li>當(left + right) &#x3D; target : 表示找到答案，將三個數按照順序放入set，此時因為我們每次都是將值按照順序插入set，所以set會自動幫我們過濾掉duplicates，而也因為題目不允許答案有duplicates，此時就將兩個pointers都往中間移。</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n^2), given that for every &quot;base number&quot; that &lt;= 0, we scan all the number on its right side.</span></span><br><span class="line"><span class="string">    space: O(n), which is the cost of the set.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            target = -<span class="number">1</span> * nums[i]</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[left] + nums[right] == target:</span><br><span class="line">                    ans.add((nums[i], nums[left], nums[right]))</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[left] + nums[right] &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, ans))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="Linked-List-Problems："><a href="#Linked-List-Problems：" class="headerlink" title="Linked List Problems："></a>Linked List Problems：</h3><p>Coming soon…</p>
<br>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://medium.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98%E7%B3%BB%E5%88%97-two-pointer-%E8%88%87sliding-window-8742f45f3f55">演算法筆記系列 — Two Pointer 與Sliding Window</a><br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/window-sliding-technique/">Window Sliding Technique</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Two-Pointers-and-Sliding-Window/" rel="tag"># Two Pointers and Sliding Window</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/07/Data%20Structure%20-%20Least%20Recently%20Used%20Cache/" rel="prev" title="Data Structures - Least Recently Used Cache">
      <i class="fa fa-chevron-left"></i> Data Structures - Least Recently Used Cache
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Algorithm-Two-Pointers-and-Sliding-Window"><span class="nav-number">1.</span> <span class="nav-text">Algorithm - Two Pointers and Sliding Window</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9"><span class="nav-number">1.0.1.</span> <span class="nav-text">基本介紹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A1%8C%E8%A7%80%E5%BF%B5"><span class="nav-number">1.0.2.</span> <span class="nav-text">解題觀念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode"><span class="nav-number">1.0.3.</span> <span class="nav-text">Leetcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Substring-Problems%EF%BC%9A"><span class="nav-number">1.0.4.</span> <span class="nav-text">Substring Problems：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem1-Longest-Palindromic-Substring"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">Problem1. Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem2-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">Problem2. Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem3-Longest-Substring-with-At-Least-K-Repeating-Characters"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">Problem3 Longest Substring with At Least K Repeating Characters</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subarray-Problems%EF%BC%9A"><span class="nav-number">1.0.5.</span> <span class="nav-text">Subarray Problems：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem1-Maximum-Subarray"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">Problem1. Maximum Subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem2-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">Problem2. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem3-Container-With-Most-Water"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">Problem3. Container With Most Water</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problems4-Product-of-Array-Except-Self"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">Problems4. Product of Array Except Self</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problems5-Maximum-Product-Subarray"><span class="nav-number">1.0.5.5.</span> <span class="nav-text">Problems5. Maximum Product Subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problems6-Gas-Station"><span class="nav-number">1.0.5.6.</span> <span class="nav-text">Problems6. Gas Station</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problems7-3Sum"><span class="nav-number">1.0.5.7.</span> <span class="nav-text">Problems7. 3Sum</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linked-List-Problems%EF%BC%9A"><span class="nav-number">1.0.6.</span> <span class="nav-text">Linked List Problems：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">1.0.7.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Francis"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Francis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
