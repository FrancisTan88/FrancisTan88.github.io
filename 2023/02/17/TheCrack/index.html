<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. Find the two sum (link)Method 1 : Brute force (O(n^2))觀念：  從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。 當固定某個current value，如果掃過一遍都沒有match的，則該cu">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode - Random">
<meta property="og:url" content="http://example.com/2023/02/17/TheCrack/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:description" content="1. Find the two sum (link)Method 1 : Brute force (O(n^2))觀念：  從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。 當固定某個current value，如果掃過一遍都沒有match的，則該cu">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-16T19:08:18.000Z">
<meta property="article:modified_time" content="2023-02-16T21:15:05.229Z">
<meta property="article:author" content="Francis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/17/TheCrack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Leetcode - Random | FrancisTan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FrancisTan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just For Fun</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/TheCrack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode - Random
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 03:08:18 / Modified: 05:15:05" itemprop="dateCreated datePublished" datetime="2023-02-17T03:08:18+08:00">2023-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Find-the-two-sum-link"><a href="#1-Find-the-two-sum-link" class="headerlink" title="1. Find the two sum (link)"></a>1. Find the two sum (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">link</a>)</h1><h2 id="Method-1-Brute-force-O-n-2"><a href="#Method-1-Brute-force-O-n-2" class="headerlink" title="Method 1 : Brute force (O(n^2))"></a>Method 1 : Brute force (O(n^2))</h2><p>觀念：</p>
<ul>
<li>從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。</li>
<li>當固定某個current value，如果掃過一遍都沒有match的，則該current value就不用再看了</li>
</ul>
<p>Programming：</p>
<ul>
<li>if x in dictionary → 只能用於判斷dictionary的「key」有沒有包含x，不能用於「value」</li>
</ul>
<h2 id="Method-2-Two-pass-hash-map-O-n"><a href="#Method-2-Two-pass-hash-map-O-n" class="headerlink" title="Method 2 : Two pass hash map (O(n))"></a>Method 2 : Two pass hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>先利用dictionary跑一個for loop，將陣列中的值存入(key: array value, value: array index)，再跑一圈for loop遍歷陣列，將complement當作key查找dictionary，如果該值存在且該索引不等於current value的索引，則return兩個值的index。</li>
<li>dictionary的查找每次只需要用到O(1)的時間，因此能夠滿足O(n)。</li>
</ul>
<h1 id="9-Check-if-an-integer-is-a-palindrome-link"><a href="#9-Check-if-an-integer-is-a-palindrome-link" class="headerlink" title="9.Check if an integer is a palindrome (link)"></a>9.Check if an integer is a palindrome (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/submissions/">link</a>)</h1><h2 id="Method3-Revert-half-of-the-number-Olog-n"><a href="#Method3-Revert-half-of-the-number-Olog-n" class="headerlink" title="Method3 : Revert half of the number (Olog(n))"></a>Method3 : <strong><strong>Revert half of the number (Olog(n))</strong></strong></h2><p>作法：</p>
<ul>
<li><p>利用一個變數”reverse”(一開始為0)每次對integer%10去取他的個位數(得到current value)，再將current value + reverse * 10，達到revert的效果</p>
</li>
<li><p>While loop :</p>
<ul>
<li>條件：當reverse &lt; integer</li>
<li>跑完迴圈後要比較兩個number(reverse &amp; integer)，(1)如果integer為奇數位數: revert會比integer多一位(e.g. integer &#x3D;&#x3D; 12, revert &#x3D;&#x3D; 123)   (2)如果integer為偶數位數: integer會剛好等於revert</li>
</ul>
</li>
<li><p>最後：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reverse == integer <span class="keyword">or</span> <span class="built_in">int</span>(reverse/<span class="number">10</span>) == integer:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：一開始要先處理負數、個位數為0的情況(e.g. 4440)，不然reverse會不正確</p>
</li>
</ul>
<h1 id="13-Convert-Roman-numerial-to-integer-link"><a href="#13-Convert-Roman-numerial-to-integer-link" class="headerlink" title="13.Convert Roman numerial to integer (link)"></a>13.Convert Roman numerial to integer (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">link</a>)</h1><h2 id="Method2-Hash-map-O-n"><a href="#Method2-Hash-map-O-n" class="headerlink" title="Method2 : Hash map (O(n))"></a>Method2 : Hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>利用一個dictionary去紀錄roman numerial所代表的數字</li>
<li>用一個for loop遍歷string，依照roman numerial的規則，如果current value &lt; next value，則代表current value需要被扣掉（須注意在比較current, next的大小時，next value不能超過string的長度）</li>
</ul>
<h1 id="14-Find-the-longest-common-prefix-link"><a href="#14-Find-the-longest-common-prefix-link" class="headerlink" title="14.Find the longest common prefix (link)"></a>14.Find the longest common prefix (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">link</a>)</h1><h2 id="Method1-Vertical-scanning-O-N-M"><a href="#Method1-Vertical-scanning-O-N-M" class="headerlink" title="Method1 : Vertical scanning (O(N*M))"></a>Method1 : Vertical scanning (O(N*M))</h2><p>觀念：</p>
<ul>
<li>直接以第一個string為比對基準，每次取一個character出來和list裡的其他string相比，如果based string的長度超過了某個其他string，或是當based string和任一string不相等時，則return目前取到的string</li>
<li>最差的情況為list裡的所有string都相等，這樣等於要把所有的character都看過一遍才可以return，意即O(N*M)</li>
</ul>
<h2 id="Method2-Compare-the-most-two-different-strings-O-N-M"><a href="#Method2-Compare-the-most-two-different-strings-O-N-M" class="headerlink" title="Method2 : Compare the most two different strings (O(N*M))"></a>Method2 : Compare the most two different strings (O(N*M))</h2><p>觀念：</p>
<ul>
<li>利用function min( ), max( ) 分別找出alphabet排序最前面和最後面的string，再比較此兩個strings，return答案。</li>
<li>由於min, max讓我們得到list中差異最大的兩個strings，直接比較這兩個strings就可代表其他所有的strings，我們無需再對其他的strings作比對。</li>
</ul>
<h1 id="20-Valid-Parentheses（link）"><a href="#20-Valid-Parentheses（link）" class="headerlink" title="20.Valid Parentheses（link）"></a>20.<strong>Valid Parentheses（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">link</a>）</strong></h1><h2 id="Method1-Using-hash-map-and-stack-O-N"><a href="#Method1-Using-hash-map-and-stack-O-N" class="headerlink" title="Method1 : Using hash map and stack (O(N))"></a>Method1 : Using hash map and stack (O(N))</h2><p>觀念：</p>
<ul>
<li>hash map: 把左括號當作key, 右括號當作value。</li>
<li>stack: 只要是左括號就push, 右括號就pop。</li>
<li>如果current char為右括號，須檢查stack是否為empty以及current char和stack裡的top char是否配對，若沒有則return false。</li>
<li>最後若stack不為empty表示有左括號沒被配對到，則return false，否則就return true。</li>
</ul>
<h1 id="21-Merge-two-sorted-lists-singly-linked-list-link-reference"><a href="#21-Merge-two-sorted-lists-singly-linked-list-link-reference" class="headerlink" title="21.Merge two sorted lists (singly linked list) (link, reference)"></a>21.Merge two sorted lists (singly linked list) (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">link</a>, <a target="_blank" rel="noopener" href="https://medium.com/@tobby168/%E7%94%A8python%E5%AF%A6%E4%BD%9Clinked-list-524441133d4d">reference</a>)</h1><h2 id="Method1-Using-the-concept-of-“merge-sort”"><a href="#Method1-Using-the-concept-of-“merge-sort”" class="headerlink" title="Method1 : Using the concept of “merge sort”"></a>Method1 : Using the concept of “merge sort”</h2><p>time: O(m+n), given that m, n are the length of two lists respectively</p>
<p>space: O(1)</p>
<p>觀念：</p>
<ol>
<li><p>linked list起手式：要用node.next &#x3D; …去把鏈結串起來，不能直接assign(因為會改變記憶體位置) e.g y &#x3D; 5 → x &#x3D; y → y &#x3D; 8 —&gt; (x, y) &#x3D; (5, 8)  </p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node = ListNode()</span><br><span class="line">head = node</span><br><span class="line"><span class="keyword">while</span> ... :</span><br><span class="line">	node.<span class="built_in">next</span> = ...</span><br><span class="line">	node = node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>traverse的時候不用另外再創建新的ListNode，應該要直接用list裡面的node去串接以節省記憶體空間，實踐方法為利用一個nxt變數先保存curr_node.next，再將current_node斷掉來直接取用current_node，最後再將current_node接回nxt變數即可達到inplace traverse。</p>
</li>
</ol>
<h1 id="26-Remove-Duplicates-from-Sorted-Array-link"><a href="#26-Remove-Duplicates-from-Sorted-Array-link" class="headerlink" title="26.Remove Duplicates from Sorted Array (link)"></a>26.<strong>Remove Duplicates from Sorted Array (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a>)</strong></h1><h2 id="Method1-Just-delete-it"><a href="#Method1-Just-delete-it" class="headerlink" title="Method1 : Just delete it"></a>Method1 : Just delete it</h2><p>觀念：</p>
<ul>
<li>若遇到duplicates，則利用function remove(”value”)直接把它刪掉，否則就跳到下一個繼續檢查 。</li>
<li>function remove(”value” ) : 會刪掉陣列中第一個符合”value”的element。</li>
</ul>
<h2 id="Method2-Take-advantage-of-the-property-of-non-decreasing-order"><a href="#Method2-Take-advantage-of-the-property-of-non-decreasing-order" class="headerlink" title="Method2 : Take advantage of the property of non-decreasing order"></a>Method2 : Take advantage of the property of non-decreasing order</h2><p>觀念：</p>
<ul>
<li>利用一個變數(e.g. “ind”)去紀錄前幾個sorted values的位置，接著一個個比大小，若找到比較大的值(代表非duplicates)就將該值插到前面，最後return ind。</li>
</ul>
<h1 id="27-Remove-Elements-link"><a href="#27-Remove-Elements-link" class="headerlink" title="27.Remove Elements (link)"></a>27.<strong>Remove Elements (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">link</a>)</strong></h1><h2 id="Method2-Check-and-insert"><a href="#Method2-Check-and-insert" class="headerlink" title="Method2 : Check and insert"></a>Method2 : Check and insert</h2><p>觀念：</p>
<ul>
<li>利用一個for loop遍歷整個list，如果current element和題目給的val不相等，則將他插入前面，最後return “first part of sorted array”</li>
</ul>
<h1 id="35-Search-Insertion-Position-link"><a href="#35-Search-Insertion-Position-link" class="headerlink" title="35.Search Insertion Position (link)"></a>35.<strong>Search Insertion Position (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/">link</a>)</strong></h1><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search :"></a>Binary Search :</h2><ul>
<li>two pointers : left, right</li>
<li>middle : $(left+right);&#x2F;&#x2F;;2$ → (1)目標為奇數個: middle在正中間 (2)目標為偶數個: middle在中間偏前面的位置</li>
<li>每一個iteration透過移動left or right把當前問題減半直到找到目標值或是當前問題無法再被減少</li>
</ul>
<h2 id="Method1-iterative-binary-search"><a href="#Method1-iterative-binary-search" class="headerlink" title="Method1 : iterative binary search"></a>Method1 : iterative binary search</h2><p>時間：O(logn)</p>
<p>空間：O(1)</p>
<p>主體：middle和目標值比大小</p>
<ol>
<li><p>while condition：left &lt; right<br>why &lt; rather than ≤ → 試想當目標被我們減少到只剩一個時，此時left, right, middle指在同個位置，而若target又剛好小於middle，這時透過right &#x3D; middle並無法縮減目標，會陷入infinite while loop，e.g. nums &#x3D; [8], target &#x3D; 7</p>
</li>
<li><p>$if;middle &#x3D;&#x3D;target:;return ;midddle$ </p>
<p> $if;middle &gt; target:;search;left;half$ → right &#x3D; middle</p>
<p> $if;middle &lt; target:;search;right;half$ → left &#x3D; middle + 1</p>
</li>
<li><p>edge case：若while loop結束還沒有return，代表target不在陣列裡，此時分成兩種情況</p>
<ol>
<li>target要被插在陣列的中間某個位置 → return left or right</li>
<li>target大於陣列所有的值，此時要被插在最後面 → return len(arr)</li>
</ol>
</li>
</ol>
<h2 id="Method2-recursive-binary-search"><a href="#Method2-recursive-binary-search" class="headerlink" title="Method2 : recursive binary search"></a>Method2 : recursive binary search</h2><p>時間：O(logn)</p>
<p>空間：O(logn)</p>
<p>主體：（略）</p>
<h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-last-word/">Length of Last Word</a></h1><h2 id="Method-Naive"><a href="#Method-Naive" class="headerlink" title="Method : Naive"></a>Method : Naive</h2><p>觀念：</p>
<ul>
<li>loop由後往前掃，用一個variable去紀錄last word的長度，如果不是empty string就++，所以如果current value為empty string且variable又不為零，代表loop遇到了last word之後(由後往前)的第一個斷點，此時可以return result。</li>
</ul>
<h2 id="Method-Using-module"><a href="#Method-Using-module" class="headerlink" title="Method : Using module"></a>Method : Using module</h2><p>觀念：</p>
<ul>
<li>利用”string”.split( )，當此function的parameter為None時，它會自動將空格、換行等當作separator，並回傳一個string list，此時return len(list[-1])即是答案。</li>
</ul>
<h1 id="66-Plus-one"><a href="#66-Plus-one" class="headerlink" title="66. Plus one"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. Plus one</a></h1><h2 id="Method1-convert-to-integer-and-increment-it"><a href="#Method1-convert-to-integer-and-increment-it" class="headerlink" title="Method1 : convert to integer and increment it"></a>Method1 : convert to integer and increment it</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>Note：</p>
<ol>
<li>join( )只能用在string iterable(e.g. string, string list)</li>
<li>map(<function>, <iterable>)可以但不限於用在list，但其return的是一個物件，要把他再轉成list</li>
</ol>
<p>觀念：把陣列中的每個數字合併成一個string，再把他轉成integer後+1，再轉回string回傳整數陣列</p>
<h2 id="Method2-digits-operation"><a href="#Method2-digits-operation" class="headerlink" title="Method2 : digits operation"></a>Method2 : digits operation</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：由後往前遍歷，如果不是9就直接+1回傳，否則就更新為0</p>
<p>注意：如果the most significant number是9且需要進位，則最後回傳會多一位，e.g. num &#x3D; [9, 9]，return [1, 0, 0]</p>
<h1 id="67-Add-binary"><a href="#67-Add-binary" class="headerlink" title="67. Add binary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/">67. Add binary</a></h1><h2 id="Method-math"><a href="#Method-math" class="headerlink" title="Method : math"></a>Method : math</h2><p>觀念：</p>
<ol>
<li>數學進位題要想到”%” operation</li>
</ol>
<p>主體：</p>
<ol>
<li>利用兩個pointer分別代表兩個str的index，將對應的每一位相加並且由右往左算，額外利用一個bool去判斷是否需要進位，如此算出answer的每一位char，即$ans&#x3D;curr%2;+;ans$  </li>
<li>注意：有種special case需要在head新增”1”，e.g. 11 + 1 &#x3D; 100</li>
</ol>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></strong></h1><h2 id="Method-calculate-the-arrangement-and-combination-排列組合"><a href="#Method-calculate-the-arrangement-and-combination-排列組合" class="headerlink" title="Method : calculate the arrangement and combination(排列組合)"></a>Method : calculate the arrangement and combination(排列組合)</h2><p>觀念：</p>
<ul>
<li>把該值想成是很多‘2’和’1’的組合，而計算出這些可能的排列組合即為題目所求。<br>排列組合的公式：(total amount of numbers)!  &#x2F;  (the amount of number which are in the same catogory)! multiplied by each other</li>
<li>先算出2最多可能有幾個(e.g. “5”→2, “12”→6)，而每一次iteration拿題目給的value扣掉2 * ”2的個數”所剩即為”1的個數”，由此去計算每一種組合(e.g. “4”→[ (一個2+兩個1), (兩個2+零個1) ] )的可能排列，即可得出答案。</li>
<li>階乘的計算：math.factorial(”number”)<br>e.g. math.factorial(5) &#x3D; 5! , math.factorial(0) &#x3D; 0! &#x3D; 1</li>
</ul>
<h1 id="83-Remove-Duplicates-From-Sorted-Linked-List"><a href="#83-Remove-Duplicates-From-Sorted-Linked-List" class="headerlink" title="83. Remove Duplicates From Sorted Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates From Sorted Linked List</a></h1><h2 id="Method-connect-the-“next”-to-the-“next-next”"><a href="#Method-connect-the-“next”-to-the-“next-next”" class="headerlink" title="Method : connect the “next” to the “next next”"></a>Method : connect the “next” to the “next next”</h2><p>觀念：</p>
<ul>
<li>Traverse整個linked list，當current value &#x3D;&#x3D; next value就把current node的next接到next next，如此達到delete的效果，若current value !&#x3D; next value就(head &#x3D; head.next)繼續traverse下去。</li>
</ul>
<h1 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h1><h2 id="Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort"><a href="#Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort" class="headerlink" title="Method1 : create new list from the first m elements of nums1 and use Merge Sort"></a>Method1 : create new list from the first m elements of nums1 and use Merge Sort</h2><p>觀念：</p>
<ul>
<li>將first m elements of nums1擷取出來，再和nums2比大小（Merge Sort），這邊可以將排序後的elements放進新的陣列，也可以inplace放進nums1裡面。</li>
</ul>
<h2 id="Method2-Using-the-reverse-index（link）"><a href="#Method2-Using-the-reverse-index（link）" class="headerlink" title="Method2 : Using the reverse index（link）"></a>Method2 : Using the reverse index（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/discuss/785646/Python-3-greater-99.78-faster">link</a>）</h2><p>觀念：</p>
<ul>
<li>利用reverse index將first m elements of nums1 and total nums2由後往前比，較大的就插入nums1的last element，直到兩個陣列其中一個被traverse完為止，而最後還沒被traverse完的那個陣列若是nums1則不用做任何事（因為題目所求為nums1的inplace），但若是nums2則要將nums2內剩下的所有elements依序插入nums1。</li>
</ul>
<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h1><p>Inorder Traversal:</p>
<ul>
<li>traverse left subtree</li>
<li>do something with root value</li>
<li>traverse right sub tree</li>
</ul>
<h2 id="Method1-depth-first-search-recursion"><a href="#Method1-depth-first-search-recursion" class="headerlink" title="Method1 : depth-first-search(recursion)"></a>Method1 : depth-first-search(recursion)</h2><p>觀念：</p>
<ul>
<li>先往左下探到底，直到root.left為None的時候再將root.val append到list，接著traverse root.right。</li>
<li>每個遞迴都會創建一個新的list，如此利用list +&#x3D; list的方式將每次遞迴所return的陣列接起來。</li>
</ul>
<h2 id="Method1-depth-first-search-stack"><a href="#Method1-depth-first-search-stack" class="headerlink" title="Method1 : depth-first-search(stack)"></a>Method1 : depth-first-search(stack)</h2><p>觀念：</p>
<ul>
<li>一樣先往左traverse並將沿路看到的nodes push到stack裡，直到遇到null node時，就將stack的top node pop出來並放到result list，再將root更新為popedNode.right，只要stack不為empty且root ≠ null就繼續重複上述動作直到return。</li>
<li>此做法即是利用stack後進先出的特性，由於我們都是優先往左traverse，而根據Inorder traversal的特性越靠左下角的node越會先被traverse到，所以當我們撞到null node時，只要將stack pop出來，再把root移到popedNode.right繼續traverse，即可得到題目所求。</li>
</ul>
<h1 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h1><h2 id="Method1-“just-compare-both-of-them”-recursion"><a href="#Method1-“just-compare-both-of-them”-recursion" class="headerlink" title="Method1 : “just compare both of them”(recursion)"></a>Method1 : “just compare both of them”(recursion)</h2><p>觀念：</p>
<p>直接比對兩個tree(true or false)：</p>
<ul>
<li>若兩者皆為null → true</li>
<li>若其中一個為null → false</li>
<li>若都不是null(都有值) → (1)值不相等: false (2)值相等: look further</li>
</ul>
<h1 id="106-Convert-sorted-array-to-bst"><a href="#106-Convert-sorted-array-to-bst" class="headerlink" title="106. Convert sorted array to bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">106. Convert sorted array to bst</a></h1><h2 id="Method1-recursive"><a href="#Method1-recursive" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>觀念：</p>
<p>先找到middle value並initialize為root，middle value的左邊都小於自己，所以要放到root.left，相反地，將middle value的右邊都放到root.right，最後return root。</p>
<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a></h1><h2 id="Method1-recursion"><a href="#Method1-recursion" class="headerlink" title="Method1 : recursion"></a>Method1 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(logn)$</p>
<p>觀念：</p>
<h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></strong></h1><h2 id="Method1-recursive-postorder-traversal"><a href="#Method1-recursive-postorder-traversal" class="headerlink" title="Method1 : recursive(postorder traversal)"></a>Method1 : recursive(postorder traversal)</h2><p>觀念：</p>
<ul>
<li><p>postorder traversal</p>
</li>
<li><p>終止條件：null node → return 0(什麼都沒有)</p>
</li>
<li><p>遞迴：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftNodes = func(root.left)</span><br><span class="line">rightNodes = func(root.right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當$abs(leftNodes - rightNodes) &gt;&#x3D; 2$時，表示已經出現unbalanced情形所以其他的部分都不重要了(現在只要想辦法把這個結果一路傳回root)，於是return -1(這邊-1只是為了標記沒有其他含義)</li>
<li>當$leftNodes&#x3D;&#x3D;-1 ;||; rightNodes&#x3D;&#x3D;-1$，表示先前已經找到unbalanced，所以繼續return -1</li>
<li>當1.和2.都沒發生，則$return;1+max(leftNodes, ;rightNodes)$，要用max是因為對於任一個node來說，當出現左右不對稱情形，會用較深的那邊表示該節點的高度。</li>
</ol>
</li>
</ul>
<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></strong></h1><h2 id="Method-dfs-postorder-traversal"><a href="#Method-dfs-postorder-traversal" class="headerlink" title="Method : dfs(postorder traversal)"></a>Method : dfs(postorder traversal)</h2><p>時間：O(n)</p>
<p>空間：O(h)</p>
<p>觀念： </p>
<ol>
<li><p>當left_nodes和right_nodes其中一個為0且另一個不為0，代表只有一條路可以到leaf node(不為零的那條)，所以要return 1 + max(left_nodes, right_nodes)</p>
</li>
<li><p>除了1.以外的情況可再分為兩種：</p>
<ol>
<li>兩條路都可走：由於是找最短路徑，所以要走nodes較少的那條</li>
<li>兩條路都不可走：代表current node為leaf node(left &amp; right &#x3D;&#x3D; 0)</li>
</ol>
<p> 綜合a,b → return 1 + min(left_nodes, right_nodes)</p>
</li>
</ol>
<h1 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/description/">112. Path Sum</a></strong></h1><h2 id="Method1-recursive-1"><a href="#Method1-recursive-1" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>time: $O(n)$ , space: </p>
<p>觀念：</p>
<ul>
<li><p>由於是要traverse到leaf node，不太可能先”遞迴”再”做事”，所以為preorder traversal</p>
</li>
<li><p>終止條件：null node → return False</p>
</li>
<li><p>遞迴：</p>
<p>  由於要做加總，所以要把”total一路傳下去到leaf node”，而target也要傳因為要做比對</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = func(root.left, total, target)</span><br><span class="line">r = func(root.right, total, target)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當left或right其中一邊為True表示找到了sum path，這時return True，把True這個資訊接續傳上去</li>
<li>除了1.以外的情況，表示兩邊都是False(沒有找到)，這時就要看current node的total是否等於target sum，且因為題目限制為leaf node，所以要限制條件為沒有children node</li>
<li>如果1. 2.都不符合表示沒戲了，直接return False</li>
</ol>
</li>
</ul>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/description/">118. Pascal’s Triangle</a></strong></h1><h2 id="Method1-double-for-loops"><a href="#Method1-double-for-loops" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>觀念：</p>
<ul>
<li>由於return format為2d array → 直覺想到double for loops</li>
<li>架構：<ol>
<li>第一圈為2d array內所有sub array的iterations，也就是題目的numRows</li>
<li>第二圈為每個sub array內integer的iterations</li>
</ol>
</li>
<li>主體：<ol>
<li>對於triangle每一層的integer，只要是頭或尾都必為1</li>
<li>若不符合1.，代表是位於中間的integer，因此若我們假設current position為”i”，則其值為$prevArray[i];+;prevArray[i+1]$</li>
</ol>
</li>
</ul>
<h1 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/description/">119. Pascal’s Triangle II</a></strong></h1><h2 id="Method1-double-for-loops-1"><a href="#Method1-double-for-loops-1" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>time: $O(n^2)$ , space: $O(n^2)$</p>
<p>觀念：跟118.一樣，只是變成return最後一個array</p>
<h2 id="Method2-Mathematics"><a href="#Method2-Mathematics" class="headerlink" title="Method2 : Mathematics"></a>Method2 : Mathematics</h2><p>time: $O(n^2)$ , space: $O(n)$</p>
<p>觀念：帕斯克三角形第i列的第j個值為 → $C^i_j$ （i, j為0-indexed, 利用模組math的函式factorial計算）</p>
<p>→ $\frac{factorial(i)}{factorial(j)*factorial(i-j)}$</p>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding" class="headerlink" title="121. Best Time to Buy and Sell Stock(Window Sliding)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a>(<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/window-sliding-technique/">Window Sliding</a>)</strong></h1><h2 id="Method1-Window-Sliding-two-pointers"><a href="#Method1-Window-Sliding-two-pointers" class="headerlink" title="Method1 : Window Sliding(two pointers)"></a>Method1 : Window Sliding(two pointers)</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>profit最重要的就是買、賣價 → 所以想到用two pointers去紀錄</li>
<li>架構：初始化purchase_price、max_profit，一邊維護這兩個變數一邊遍歷陣列</li>
<li>主體：<ol>
<li>先比較current price和purchase_price<ol>
<li>current price &lt; purchase_price → 無利可圖，但需要更新purchase_price(買低就是賺)</li>
<li>current price ≥ purchase_price → 去看max_profit</li>
</ol>
</li>
<li>若情況為1-b，看當前利潤是否大於最大利潤 → $max(maxProfit,;currentPrice;-;purchasePrice)$</li>
</ol>
</li>
</ul>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></strong></h1><h2 id="Method-traverse-forward-and-backward-synchronously"><a href="#Method-traverse-forward-and-backward-synchronously" class="headerlink" title="Method : traverse forward and backward synchronously"></a>Method : traverse forward and backward synchronously</h2><p>time : O(n)</p>
<p>space : O(1)</p>
<p>補充：</p>
<ol>
<li>letters的大小寫轉換：string.upper() , string.lower()</li>
<li>判斷是否為letters or numbers：isalnum(<string>)</li>
</ol>
<p>觀念：</p>
<p>題目所給的string包含許多不是alphanumeric的符號，而palindrome的前後比對必須是pairs by pairs，所以當前或後遇到不是alphanumeric的時候必須跳過，只有當前後都為alphanumeric時才有比較的意義</p>
<h1 id="136-Single-Number-Wiki-XOR"><a href="#136-Single-Number-Wiki-XOR" class="headerlink" title="136. Single Number (Wiki: XOR)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/description/">136. Single Number</a> (<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">Wiki: XOR</a>)</strong></h1><h2 id="Method1-sort-it-first-then-compare-them"><a href="#Method1-sort-it-first-then-compare-them" class="headerlink" title="Method1 : sort it first, then compare them"></a>Method1 : sort it first, then compare them</h2><p>time: $O(nlogn)$ → the cost of built-in function sorted( ), note that every compare-based sorting algorithm at least cost nlogn</p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li><p>排序後一樣的number會比鄰排在一起</p>
</li>
<li><p>主體：</p>
<p>  每個number和它下一個比，如果一樣就跳到下下個繼續比，如果不一樣就return single number</p>
<ol>
<li>single number位在array的”非最後位置” → 發現不一樣時，single number一定是current number</li>
<li>single number位在array的最後 → 若已經看到最後一個位置，代表前面的numbers都是duplicates，這時不能和下一個比，直接return current number。</li>
</ol>
</li>
</ul>
<h2 id="Method2-XOR"><a href="#Method2-XOR" class="headerlink" title="Method2 : XOR"></a>Method2 : XOR</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>XOR：</p>
<ol>
<li><p>同性相斥：同樣的boolean: return False , 同樣的integer: return 0</p>
<p> e.g.</p>
<table>
<thead>
<tr>
<th>(a,b)</th>
<th>a^b</th>
</tr>
</thead>
<tbody><tr>
<td>(True, False)</td>
<td>True</td>
</tr>
<tr>
<td>(True, True)</td>
<td>False</td>
</tr>
<tr>
<td>(100, 0)</td>
<td>100</td>
</tr>
<tr>
<td>(100, 100)</td>
<td>0</td>
</tr>
<tr>
<td>(100, 10)</td>
<td>some number</td>
</tr>
</tbody></table>
</li>
<li><p>a^b^c^b^c &#x3D; b^b^c^c^a &#x3D; a</p>
</li>
</ol>
<p>觀念：0有還原某個數的特性 → 0^100 &#x3D; 100 , 0^0 &#x3D; 0，所以利用上述2.的特性，初始化一個變數為0，讓他去和整個array的number作XOR即可得到single number</p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></strong></h1><h2 id="Method1-hash-map"><a href="#Method1-hash-map" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：</p>
<ul>
<li><p>Node的結構為object，實質為某個unique的記憶體位址，所以即便有兩個node.val一樣，他們對於記憶體而言仍然是兩個不同的東西，利用此特性去儲存traverse到的每個node，就可以判斷是否有cycle</p>
</li>
<li><p>主體：</p>
<p>  儲存traverse過的每個node，如此判斷同一個node是否重複出現</p>
<ol>
<li><p>由於儲存的方式不用去管順序，且希望使用O(1)查找，所以適合用set( ) （<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-set.html">set相關用法</a>）</p>
<p> <em>→ set( ) is an unsorted and unique data structure</em></p>
</li>
<li><p>檢查每個node是否已在set( )內，如果有就代表出現cycle → return True，否則就將current node存到set( )</p>
</li>
<li><p>若traverse完整個node list都沒有return則代表沒有出現cycle → return False</p>
</li>
</ol>
</li>
</ul>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists</a></strong></h1><h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169. Majority Element</a></strong></h1><h2 id="Method1-hash-map-1"><a href="#Method1-hash-map-1" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：利用一個dictionary去統計不同數字出現的次數，直到發現某數的次數$&gt;\frac{1}{2}n$時就return該數</p>
<h2 id="Method2-Boyer-Moore-Voting-Algorithm-多數投票算法"><a href="#Method2-Boyer-Moore-Voting-Algorithm-多數投票算法" class="headerlink" title="Method2 : Boyer-Moore Voting Algorithm(多數投票算法)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Method2 :</a> <strong><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Boyer-Moore Voting Algorithm(多數投票算法)</a></strong></strong></h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>將$majority$想像成一個最強的軍隊，$count$想像成此軍隊的生命值，而其他的數通通組成較弱的一隊，在traverse的過程中如果$current;number&#x3D;&#x3D;majority$，表示他們為同一國的，則$count$+1，反之則為敵人，$count$-1，根據題目由於$majority$的數量一定超過總數的一半，所以可以確保最後必會產生出$majority$(至少剩一命)</li>
<li>注意：$if;count&#x3D;&#x3D;0$，表示目前最強軍隊的人都死光了，那就必須將<em>current number</em>變成新的王</li>
</ul>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel Sheet Column Number</a></strong></h1><h2 id="Method1-進位制"><a href="#Method1-進位制" class="headerlink" title="Method1 : 進位制"></a>Method1 : 進位制</h2><p>time:  O(n)</p>
<p>space: O(1), given the number of alphabet is fixed at 26</p>
<p>觀念：</p>
<ol>
<li>此題考進位制的概念，如同我們熟悉的十進位制計算一般，e.g. $18&#x3D;10^0<em>8;+;10^1</em>1$，英文字母(alphabet)的26進位制也是一樣的概念，e.g. $AB&#x3D;26^0<em>2;+;26^1</em>1&#x3D;28$</li>
<li>迴圈從string的右掃到左比較容易寫</li>
</ol>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></strong></h1><p>先備知識：</p>
<ol>
<li>Bits(Binary digits)：為二元進位的意思，每一位為0或1，e.g. 32bits的意思即為用32個位置的0或1來表示某一個數，沒用到的位置補零(補在前面)</li>
<li>function bin(<int>)：將integer轉成二進位制，return format為string，使用上通常為bin(<int>)[2:]，其中[2:]是為了省略開頭的”0b…”</li>
<li>int(<str>, <int>)：將<int>進位制的<str>轉換為一般的10進位制int，e.g. int(”0110”, 2) → 6</li>
</ol>
<h2 id="Method1-Just-coding"><a href="#Method1-Just-coding" class="headerlink" title="Method1 : Just coding"></a>Method1 : Just coding</h2><p>time:  O(n)</p>
<p>space: O(n) </p>
<p>觀念：</p>
<ol>
<li>利用func bin()將input轉換為二進位制的string，由於題目說input必須是32-bits，而因為func bin()返回的string會自動省略掉前面的0，所以必須將string的前面補零至32個character</li>
<li>reverse(1)得到的32-bits string </li>
<li>最後將reversed string利用func int()轉回正常的10進位int即可得答案</li>
</ol>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">20<strong>6. Reverse Linked List</strong></a></h1><h2 id="Method1-iterative"><a href="#Method1-iterative" class="headerlink" title="Method1 : iterative"></a>Method1 : iterative</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：想像成這個list會由右往左長，且方向是往右指</p>
<ol>
<li>初始化一個None </li>
<li>主體：每次將head的next紀錄起來，然後就可以將head接到answer node，接著把answer node往左移一格到剛接好的head，如此一來answer node就完成，最後將head指回一開始我們紀錄的next的位置</li>
</ol>
<h2 id="Method2-recursion"><a href="#Method2-recursion" class="headerlink" title="Method2 : recursion"></a>Method2 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：和iterative差不多只是換種寫法</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/02/17/TheDeep/" rel="next" title="Leetcode - Top Interview">
      Leetcode - Top Interview <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Find-the-two-sum-link"><span class="nav-number">1.</span> <span class="nav-text">1. Find the two sum (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-1-Brute-force-O-n-2"><span class="nav-number">1.1.</span> <span class="nav-text">Method 1 : Brute force (O(n^2))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-2-Two-pass-hash-map-O-n"><span class="nav-number">1.2.</span> <span class="nav-text">Method 2 : Two pass hash map (O(n))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Check-if-an-integer-is-a-palindrome-link"><span class="nav-number">2.</span> <span class="nav-text">9.Check if an integer is a palindrome (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method3-Revert-half-of-the-number-Olog-n"><span class="nav-number">2.1.</span> <span class="nav-text">Method3 : Revert half of the number (Olog(n))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Convert-Roman-numerial-to-integer-link"><span class="nav-number">3.</span> <span class="nav-text">13.Convert Roman numerial to integer (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Hash-map-O-n"><span class="nav-number">3.1.</span> <span class="nav-text">Method2 : Hash map (O(n))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Find-the-longest-common-prefix-link"><span class="nav-number">4.</span> <span class="nav-text">14.Find the longest common prefix (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Vertical-scanning-O-N-M"><span class="nav-number">4.1.</span> <span class="nav-text">Method1 : Vertical scanning (O(N*M))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Compare-the-most-two-different-strings-O-N-M"><span class="nav-number">4.2.</span> <span class="nav-text">Method2 : Compare the most two different strings (O(N*M))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-Valid-Parentheses%EF%BC%88link%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">20.Valid Parentheses（link）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Using-hash-map-and-stack-O-N"><span class="nav-number">5.1.</span> <span class="nav-text">Method1 : Using hash map and stack (O(N))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Merge-two-sorted-lists-singly-linked-list-link-reference"><span class="nav-number">6.</span> <span class="nav-text">21.Merge two sorted lists (singly linked list) (link, reference)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Using-the-concept-of-%E2%80%9Cmerge-sort%E2%80%9D"><span class="nav-number">6.1.</span> <span class="nav-text">Method1 : Using the concept of “merge sort”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array-link"><span class="nav-number">7.</span> <span class="nav-text">26.Remove Duplicates from Sorted Array (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Just-delete-it"><span class="nav-number">7.1.</span> <span class="nav-text">Method1 : Just delete it</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Take-advantage-of-the-property-of-non-decreasing-order"><span class="nav-number">7.2.</span> <span class="nav-text">Method2 : Take advantage of the property of non-decreasing order</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-Remove-Elements-link"><span class="nav-number">8.</span> <span class="nav-text">27.Remove Elements (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Check-and-insert"><span class="nav-number">8.1.</span> <span class="nav-text">Method2 : Check and insert</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-Search-Insertion-Position-link"><span class="nav-number">9.</span> <span class="nav-text">35.Search Insertion Position (link)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Search"><span class="nav-number">9.1.</span> <span class="nav-text">Binary Search :</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-iterative-binary-search"><span class="nav-number">9.2.</span> <span class="nav-text">Method1 : iterative binary search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-recursive-binary-search"><span class="nav-number">9.3.</span> <span class="nav-text">Method2 : recursive binary search</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-Length-of-Last-Word"><span class="nav-number">10.</span> <span class="nav-text">58. Length of Last Word</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Naive"><span class="nav-number">10.1.</span> <span class="nav-text">Method : Naive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Using-module"><span class="nav-number">10.2.</span> <span class="nav-text">Method : Using module</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-Plus-one"><span class="nav-number">11.</span> <span class="nav-text">66. Plus one</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-convert-to-integer-and-increment-it"><span class="nav-number">11.1.</span> <span class="nav-text">Method1 : convert to integer and increment it</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-digits-operation"><span class="nav-number">11.2.</span> <span class="nav-text">Method2 : digits operation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67-Add-binary"><span class="nav-number">12.</span> <span class="nav-text">67. Add binary</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-math"><span class="nav-number">12.1.</span> <span class="nav-text">Method : math</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-Climbing-Stairs"><span class="nav-number">13.</span> <span class="nav-text">70. Climbing Stairs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-calculate-the-arrangement-and-combination-%E6%8E%92%E5%88%97%E7%B5%84%E5%90%88"><span class="nav-number">13.1.</span> <span class="nav-text">Method : calculate the arrangement and combination(排列組合)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-Remove-Duplicates-From-Sorted-Linked-List"><span class="nav-number">14.</span> <span class="nav-text">83. Remove Duplicates From Sorted Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-connect-the-%E2%80%9Cnext%E2%80%9D-to-the-%E2%80%9Cnext-next%E2%80%9D"><span class="nav-number">14.1.</span> <span class="nav-text">Method : connect the “next” to the “next next”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#88-Merge-Sorted-Array"><span class="nav-number">15.</span> <span class="nav-text">88. Merge Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort"><span class="nav-number">15.1.</span> <span class="nav-text">Method1 : create new list from the first m elements of nums1 and use Merge Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Using-the-reverse-index%EF%BC%88link%EF%BC%89"><span class="nav-number">15.2.</span> <span class="nav-text">Method2 : Using the reverse index（link）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal"><span class="nav-number">16.</span> <span class="nav-text">94. Binary Tree Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-depth-first-search-recursion"><span class="nav-number">16.1.</span> <span class="nav-text">Method1 : depth-first-search(recursion)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-depth-first-search-stack"><span class="nav-number">16.2.</span> <span class="nav-text">Method1 : depth-first-search(stack)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#100-Same-Tree"><span class="nav-number">17.</span> <span class="nav-text">100. Same Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-%E2%80%9Cjust-compare-both-of-them%E2%80%9D-recursion"><span class="nav-number">17.1.</span> <span class="nav-text">Method1 : “just compare both of them”(recursion)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#106-Convert-sorted-array-to-bst"><span class="nav-number">18.</span> <span class="nav-text">106. Convert sorted array to bst</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-recursive"><span class="nav-number">18.1.</span> <span class="nav-text">Method1 : recursive</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-number">19.</span> <span class="nav-text">108. Convert Sorted Array to Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-recursion"><span class="nav-number">19.1.</span> <span class="nav-text">Method1 : recursion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#110-Balanced-Binary-Tree"><span class="nav-number">20.</span> <span class="nav-text">110. Balanced Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-recursive-postorder-traversal"><span class="nav-number">20.1.</span> <span class="nav-text">Method1 : recursive(postorder traversal)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">21.</span> <span class="nav-text">111. Minimum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-dfs-postorder-traversal"><span class="nav-number">21.1.</span> <span class="nav-text">Method : dfs(postorder traversal)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number">22.</span> <span class="nav-text">112. Path Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-recursive-1"><span class="nav-number">22.1.</span> <span class="nav-text">Method1 : recursive</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-Pascal%E2%80%99s-Triangle"><span class="nav-number">23.</span> <span class="nav-text">118. Pascal’s Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-double-for-loops"><span class="nav-number">23.1.</span> <span class="nav-text">Method1 : double for loops</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#119-Pascal%E2%80%99s-Triangle-II"><span class="nav-number">24.</span> <span class="nav-text">119. Pascal’s Triangle II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-double-for-loops-1"><span class="nav-number">24.1.</span> <span class="nav-text">Method1 : double for loops</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Mathematics"><span class="nav-number">24.2.</span> <span class="nav-text">Method2 : Mathematics</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding"><span class="nav-number">25.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock(Window Sliding)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Window-Sliding-two-pointers"><span class="nav-number">25.1.</span> <span class="nav-text">Method1 : Window Sliding(two pointers)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-number">26.</span> <span class="nav-text">125. Valid Palindrome</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-traverse-forward-and-backward-synchronously"><span class="nav-number">26.1.</span> <span class="nav-text">Method : traverse forward and backward synchronously</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number-Wiki-XOR"><span class="nav-number">27.</span> <span class="nav-text">136. Single Number (Wiki: XOR)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-sort-it-first-then-compare-them"><span class="nav-number">27.1.</span> <span class="nav-text">Method1 : sort it first, then compare them</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-XOR"><span class="nav-number">27.2.</span> <span class="nav-text">Method2 : XOR</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-number">28.</span> <span class="nav-text">141. Linked List Cycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-hash-map"><span class="nav-number">28.1.</span> <span class="nav-text">Method1 : hash map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-number">29.</span> <span class="nav-text">160. Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">30.</span> <span class="nav-text">169. Majority Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-hash-map-1"><span class="nav-number">30.1.</span> <span class="nav-text">Method1 : hash map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-Boyer-Moore-Voting-Algorithm-%E5%A4%9A%E6%95%B8%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="nav-number">30.2.</span> <span class="nav-text">Method2 : Boyer-Moore Voting Algorithm(多數投票算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-number">31.</span> <span class="nav-text">171. Excel Sheet Column Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-%E9%80%B2%E4%BD%8D%E5%88%B6"><span class="nav-number">31.1.</span> <span class="nav-text">Method1 : 進位制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190-Reverse-Bits"><span class="nav-number">32.</span> <span class="nav-text">190. Reverse Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-Just-coding"><span class="nav-number">32.1.</span> <span class="nav-text">Method1 : Just coding</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-number">33.</span> <span class="nav-text">206. Reverse Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1-iterative"><span class="nav-number">33.1.</span> <span class="nav-text">Method1 : iterative</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2-recursion"><span class="nav-number">33.2.</span> <span class="nav-text">Method2 : recursion</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Francis"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Francis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
