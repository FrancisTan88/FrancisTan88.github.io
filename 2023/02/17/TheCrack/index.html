<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>TheCrack | FrancisTan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. Find the two sum (link)Method 1 : Brute force (O(n^2))觀念：  從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。 當固定某個current value，如果掃過一遍都沒有match的，則該cu">
<meta property="og:type" content="article">
<meta property="og:title" content="TheCrack">
<meta property="og:url" content="http://example.com/2023/02/17/TheCrack/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:description" content="1. Find the two sum (link)Method 1 : Brute force (O(n^2))觀念：  從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。 當固定某個current value，如果掃過一遍都沒有match的，則該cu">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-16T19:08:18.000Z">
<meta property="article:modified_time" content="2023-02-16T19:09:01.496Z">
<meta property="article:author" content="Francis">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FrancisTan" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FrancisTan</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Just For Fun</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-TheCrack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/17/TheCrack/" class="article-date">
  <time class="dt-published" datetime="2023-02-16T19:08:18.000Z" itemprop="datePublished">2023-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      TheCrack
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Find-the-two-sum-link"><a href="#1-Find-the-two-sum-link" class="headerlink" title="1. Find the two sum (link)"></a>1. Find the two sum (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">link</a>)</h1><h2 id="Method-1-Brute-force-O-n-2"><a href="#Method-1-Brute-force-O-n-2" class="headerlink" title="Method 1 : Brute force (O(n^2))"></a>Method 1 : Brute force (O(n^2))</h2><p>觀念：</p>
<ul>
<li>從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。</li>
<li>當固定某個current value，如果掃過一遍都沒有match的，則該current value就不用再看了</li>
</ul>
<p>Programming：</p>
<ul>
<li>if x in dictionary → 只能用於判斷dictionary的「key」有沒有包含x，不能用於「value」</li>
</ul>
<h2 id="Method-2-Two-pass-hash-map-O-n"><a href="#Method-2-Two-pass-hash-map-O-n" class="headerlink" title="Method 2 : Two pass hash map (O(n))"></a>Method 2 : Two pass hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>先利用dictionary跑一個for loop，將陣列中的值存入(key: array value, value: array index)，再跑一圈for loop遍歷陣列，將complement當作key查找dictionary，如果該值存在且該索引不等於current value的索引，則return兩個值的index。</li>
<li>dictionary的查找每次只需要用到O(1)的時間，因此能夠滿足O(n)。</li>
</ul>
<h1 id="9-Check-if-an-integer-is-a-palindrome-link"><a href="#9-Check-if-an-integer-is-a-palindrome-link" class="headerlink" title="9.Check if an integer is a palindrome (link)"></a>9.Check if an integer is a palindrome (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/submissions/">link</a>)</h1><h2 id="Method3-Revert-half-of-the-number-Olog-n"><a href="#Method3-Revert-half-of-the-number-Olog-n" class="headerlink" title="Method3 : Revert half of the number (Olog(n))"></a>Method3 : <strong><strong>Revert half of the number (Olog(n))</strong></strong></h2><p>作法：</p>
<ul>
<li><p>利用一個變數”reverse”(一開始為0)每次對integer%10去取他的個位數(得到current value)，再將current value + reverse * 10，達到revert的效果</p>
</li>
<li><p>While loop :</p>
<ul>
<li>條件：當reverse &lt; integer</li>
<li>跑完迴圈後要比較兩個number(reverse &amp; integer)，(1)如果integer為奇數位數: revert會比integer多一位(e.g. integer &#x3D;&#x3D; 12, revert &#x3D;&#x3D; 123)   (2)如果integer為偶數位數: integer會剛好等於revert</li>
</ul>
</li>
<li><p>最後：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reverse == integer <span class="keyword">or</span> <span class="built_in">int</span>(reverse/<span class="number">10</span>) == integer:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：一開始要先處理負數、個位數為0的情況(e.g. 4440)，不然reverse會不正確</p>
</li>
</ul>
<h1 id="13-Convert-Roman-numerial-to-integer-link"><a href="#13-Convert-Roman-numerial-to-integer-link" class="headerlink" title="13.Convert Roman numerial to integer (link)"></a>13.Convert Roman numerial to integer (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">link</a>)</h1><h2 id="Method2-Hash-map-O-n"><a href="#Method2-Hash-map-O-n" class="headerlink" title="Method2 : Hash map (O(n))"></a>Method2 : Hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>利用一個dictionary去紀錄roman numerial所代表的數字</li>
<li>用一個for loop遍歷string，依照roman numerial的規則，如果current value &lt; next value，則代表current value需要被扣掉（須注意在比較current, next的大小時，next value不能超過string的長度）</li>
</ul>
<h1 id="14-Find-the-longest-common-prefix-link"><a href="#14-Find-the-longest-common-prefix-link" class="headerlink" title="14.Find the longest common prefix (link)"></a>14.Find the longest common prefix (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">link</a>)</h1><h2 id="Method1-Vertical-scanning-O-N-M"><a href="#Method1-Vertical-scanning-O-N-M" class="headerlink" title="Method1 : Vertical scanning (O(N*M))"></a>Method1 : Vertical scanning (O(N*M))</h2><p>觀念：</p>
<ul>
<li>直接以第一個string為比對基準，每次取一個character出來和list裡的其他string相比，如果based string的長度超過了某個其他string，或是當based string和任一string不相等時，則return目前取到的string</li>
<li>最差的情況為list裡的所有string都相等，這樣等於要把所有的character都看過一遍才可以return，意即O(N*M)</li>
</ul>
<h2 id="Method2-Compare-the-most-two-different-strings-O-N-M"><a href="#Method2-Compare-the-most-two-different-strings-O-N-M" class="headerlink" title="Method2 : Compare the most two different strings (O(N*M))"></a>Method2 : Compare the most two different strings (O(N*M))</h2><p>觀念：</p>
<ul>
<li>利用function min( ), max( ) 分別找出alphabet排序最前面和最後面的string，再比較此兩個strings，return答案。</li>
<li>由於min, max讓我們得到list中差異最大的兩個strings，直接比較這兩個strings就可代表其他所有的strings，我們無需再對其他的strings作比對。</li>
</ul>
<h1 id="20-Valid-Parentheses（link）"><a href="#20-Valid-Parentheses（link）" class="headerlink" title="20.Valid Parentheses（link）"></a>20.<strong>Valid Parentheses（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">link</a>）</strong></h1><h2 id="Method1-Using-hash-map-and-stack-O-N"><a href="#Method1-Using-hash-map-and-stack-O-N" class="headerlink" title="Method1 : Using hash map and stack (O(N))"></a>Method1 : Using hash map and stack (O(N))</h2><p>觀念：</p>
<ul>
<li>hash map: 把左括號當作key, 右括號當作value。</li>
<li>stack: 只要是左括號就push, 右括號就pop。</li>
<li>如果current char為右括號，須檢查stack是否為empty以及current char和stack裡的top char是否配對，若沒有則return false。</li>
<li>最後若stack不為empty表示有左括號沒被配對到，則return false，否則就return true。</li>
</ul>
<h1 id="21-Merge-two-sorted-lists-singly-linked-list-link-reference"><a href="#21-Merge-two-sorted-lists-singly-linked-list-link-reference" class="headerlink" title="21.Merge two sorted lists (singly linked list) (link, reference)"></a>21.Merge two sorted lists (singly linked list) (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">link</a>, <a target="_blank" rel="noopener" href="https://medium.com/@tobby168/%E7%94%A8python%E5%AF%A6%E4%BD%9Clinked-list-524441133d4d">reference</a>)</h1><h2 id="Method1-Using-the-concept-of-“merge-sort”"><a href="#Method1-Using-the-concept-of-“merge-sort”" class="headerlink" title="Method1 : Using the concept of “merge sort”"></a>Method1 : Using the concept of “merge sort”</h2><p>time: O(m+n), given that m, n are the length of two lists respectively</p>
<p>space: O(1)</p>
<p>觀念：</p>
<ol>
<li><p>linked list起手式：要用node.next &#x3D; …去把鏈結串起來，不能直接assign(因為會改變記憶體位置) e.g y &#x3D; 5 → x &#x3D; y → y &#x3D; 8 —&gt; (x, y) &#x3D; (5, 8)  </p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node = ListNode()</span><br><span class="line">head = node</span><br><span class="line"><span class="keyword">while</span> ... :</span><br><span class="line">	node.<span class="built_in">next</span> = ...</span><br><span class="line">	node = node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>traverse的時候不用另外再創建新的ListNode，應該要直接用list裡面的node去串接以節省記憶體空間，實踐方法為利用一個nxt變數先保存curr_node.next，再將current_node斷掉來直接取用current_node，最後再將current_node接回nxt變數即可達到inplace traverse。</p>
</li>
</ol>
<h1 id="26-Remove-Duplicates-from-Sorted-Array-link"><a href="#26-Remove-Duplicates-from-Sorted-Array-link" class="headerlink" title="26.Remove Duplicates from Sorted Array (link)"></a>26.<strong>Remove Duplicates from Sorted Array (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a>)</strong></h1><h2 id="Method1-Just-delete-it"><a href="#Method1-Just-delete-it" class="headerlink" title="Method1 : Just delete it"></a>Method1 : Just delete it</h2><p>觀念：</p>
<ul>
<li>若遇到duplicates，則利用function remove(”value”)直接把它刪掉，否則就跳到下一個繼續檢查 。</li>
<li>function remove(”value” ) : 會刪掉陣列中第一個符合”value”的element。</li>
</ul>
<h2 id="Method2-Take-advantage-of-the-property-of-non-decreasing-order"><a href="#Method2-Take-advantage-of-the-property-of-non-decreasing-order" class="headerlink" title="Method2 : Take advantage of the property of non-decreasing order"></a>Method2 : Take advantage of the property of non-decreasing order</h2><p>觀念：</p>
<ul>
<li>利用一個變數(e.g. “ind”)去紀錄前幾個sorted values的位置，接著一個個比大小，若找到比較大的值(代表非duplicates)就將該值插到前面，最後return ind。</li>
</ul>
<h1 id="27-Remove-Elements-link"><a href="#27-Remove-Elements-link" class="headerlink" title="27.Remove Elements (link)"></a>27.<strong>Remove Elements (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">link</a>)</strong></h1><h2 id="Method2-Check-and-insert"><a href="#Method2-Check-and-insert" class="headerlink" title="Method2 : Check and insert"></a>Method2 : Check and insert</h2><p>觀念：</p>
<ul>
<li>利用一個for loop遍歷整個list，如果current element和題目給的val不相等，則將他插入前面，最後return “first part of sorted array”</li>
</ul>
<h1 id="35-Search-Insertion-Position-link"><a href="#35-Search-Insertion-Position-link" class="headerlink" title="35.Search Insertion Position (link)"></a>35.<strong>Search Insertion Position (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/">link</a>)</strong></h1><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search :"></a>Binary Search :</h2><ul>
<li>two pointers : left, right</li>
<li>middle : $(left+right);&#x2F;&#x2F;;2$ → (1)目標為奇數個: middle在正中間 (2)目標為偶數個: middle在中間偏前面的位置</li>
<li>每一個iteration透過移動left or right把當前問題減半直到找到目標值或是當前問題無法再被減少</li>
</ul>
<h2 id="Method1-iterative-binary-search"><a href="#Method1-iterative-binary-search" class="headerlink" title="Method1 : iterative binary search"></a>Method1 : iterative binary search</h2><p>時間：O(logn)</p>
<p>空間：O(1)</p>
<p>主體：middle和目標值比大小</p>
<ol>
<li><p>while condition：left &lt; right<br>why &lt; rather than ≤ → 試想當目標被我們減少到只剩一個時，此時left, right, middle指在同個位置，而若target又剛好小於middle，這時透過right &#x3D; middle並無法縮減目標，會陷入infinite while loop，e.g. nums &#x3D; [8], target &#x3D; 7</p>
</li>
<li><p>$if;middle &#x3D;&#x3D;target:;return ;midddle$ </p>
<p> $if;middle &gt; target:;search;left;half$ → right &#x3D; middle</p>
<p> $if;middle &lt; target:;search;right;half$ → left &#x3D; middle + 1</p>
</li>
<li><p>edge case：若while loop結束還沒有return，代表target不在陣列裡，此時分成兩種情況</p>
<ol>
<li>target要被插在陣列的中間某個位置 → return left or right</li>
<li>target大於陣列所有的值，此時要被插在最後面 → return len(arr)</li>
</ol>
</li>
</ol>
<h2 id="Method2-recursive-binary-search"><a href="#Method2-recursive-binary-search" class="headerlink" title="Method2 : recursive binary search"></a>Method2 : recursive binary search</h2><p>時間：O(logn)</p>
<p>空間：O(logn)</p>
<p>主體：（略）</p>
<h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-last-word/">Length of Last Word</a></h1><h2 id="Method-Naive"><a href="#Method-Naive" class="headerlink" title="Method : Naive"></a>Method : Naive</h2><p>觀念：</p>
<ul>
<li>loop由後往前掃，用一個variable去紀錄last word的長度，如果不是empty string就++，所以如果current value為empty string且variable又不為零，代表loop遇到了last word之後(由後往前)的第一個斷點，此時可以return result。</li>
</ul>
<h2 id="Method-Using-module"><a href="#Method-Using-module" class="headerlink" title="Method : Using module"></a>Method : Using module</h2><p>觀念：</p>
<ul>
<li>利用”string”.split( )，當此function的parameter為None時，它會自動將空格、換行等當作separator，並回傳一個string list，此時return len(list[-1])即是答案。</li>
</ul>
<h1 id="66-Plus-one"><a href="#66-Plus-one" class="headerlink" title="66. Plus one"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. Plus one</a></h1><h2 id="Method1-convert-to-integer-and-increment-it"><a href="#Method1-convert-to-integer-and-increment-it" class="headerlink" title="Method1 : convert to integer and increment it"></a>Method1 : convert to integer and increment it</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>Note：</p>
<ol>
<li>join( )只能用在string iterable(e.g. string, string list)</li>
<li>map(<function>, <iterable>)可以但不限於用在list，但其return的是一個物件，要把他再轉成list</li>
</ol>
<p>觀念：把陣列中的每個數字合併成一個string，再把他轉成integer後+1，再轉回string回傳整數陣列</p>
<h2 id="Method2-digits-operation"><a href="#Method2-digits-operation" class="headerlink" title="Method2 : digits operation"></a>Method2 : digits operation</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：由後往前遍歷，如果不是9就直接+1回傳，否則就更新為0</p>
<p>注意：如果the most significant number是9且需要進位，則最後回傳會多一位，e.g. num &#x3D; [9, 9]，return [1, 0, 0]</p>
<h1 id="67-Add-binary"><a href="#67-Add-binary" class="headerlink" title="67. Add binary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/">67. Add binary</a></h1><h2 id="Method-math"><a href="#Method-math" class="headerlink" title="Method : math"></a>Method : math</h2><p>觀念：</p>
<ol>
<li>數學進位題要想到”%” operation</li>
</ol>
<p>主體：</p>
<ol>
<li>利用兩個pointer分別代表兩個str的index，將對應的每一位相加並且由右往左算，額外利用一個bool去判斷是否需要進位，如此算出answer的每一位char，即$ans&#x3D;curr%2;+;ans$  </li>
<li>注意：有種special case需要在head新增”1”，e.g. 11 + 1 &#x3D; 100</li>
</ol>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></strong></h1><h2 id="Method-calculate-the-arrangement-and-combination-排列組合"><a href="#Method-calculate-the-arrangement-and-combination-排列組合" class="headerlink" title="Method : calculate the arrangement and combination(排列組合)"></a>Method : calculate the arrangement and combination(排列組合)</h2><p>觀念：</p>
<ul>
<li>把該值想成是很多‘2’和’1’的組合，而計算出這些可能的排列組合即為題目所求。<br>排列組合的公式：(total amount of numbers)!  &#x2F;  (the amount of number which are in the same catogory)! multiplied by each other</li>
<li>先算出2最多可能有幾個(e.g. “5”→2, “12”→6)，而每一次iteration拿題目給的value扣掉2 * ”2的個數”所剩即為”1的個數”，由此去計算每一種組合(e.g. “4”→[ (一個2+兩個1), (兩個2+零個1) ] )的可能排列，即可得出答案。</li>
<li>階乘的計算：math.factorial(”number”)<br>e.g. math.factorial(5) &#x3D; 5! , math.factorial(0) &#x3D; 0! &#x3D; 1</li>
</ul>
<h1 id="83-Remove-Duplicates-From-Sorted-Linked-List"><a href="#83-Remove-Duplicates-From-Sorted-Linked-List" class="headerlink" title="83. Remove Duplicates From Sorted Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates From Sorted Linked List</a></h1><h2 id="Method-connect-the-“next”-to-the-“next-next”"><a href="#Method-connect-the-“next”-to-the-“next-next”" class="headerlink" title="Method : connect the “next” to the “next next”"></a>Method : connect the “next” to the “next next”</h2><p>觀念：</p>
<ul>
<li>Traverse整個linked list，當current value &#x3D;&#x3D; next value就把current node的next接到next next，如此達到delete的效果，若current value !&#x3D; next value就(head &#x3D; head.next)繼續traverse下去。</li>
</ul>
<h1 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h1><h2 id="Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort"><a href="#Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort" class="headerlink" title="Method1 : create new list from the first m elements of nums1 and use Merge Sort"></a>Method1 : create new list from the first m elements of nums1 and use Merge Sort</h2><p>觀念：</p>
<ul>
<li>將first m elements of nums1擷取出來，再和nums2比大小（Merge Sort），這邊可以將排序後的elements放進新的陣列，也可以inplace放進nums1裡面。</li>
</ul>
<h2 id="Method2-Using-the-reverse-index（link）"><a href="#Method2-Using-the-reverse-index（link）" class="headerlink" title="Method2 : Using the reverse index（link）"></a>Method2 : Using the reverse index（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/discuss/785646/Python-3-greater-99.78-faster">link</a>）</h2><p>觀念：</p>
<ul>
<li>利用reverse index將first m elements of nums1 and total nums2由後往前比，較大的就插入nums1的last element，直到兩個陣列其中一個被traverse完為止，而最後還沒被traverse完的那個陣列若是nums1則不用做任何事（因為題目所求為nums1的inplace），但若是nums2則要將nums2內剩下的所有elements依序插入nums1。</li>
</ul>
<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h1><p>Inorder Traversal:</p>
<ul>
<li>traverse left subtree</li>
<li>do something with root value</li>
<li>traverse right sub tree</li>
</ul>
<h2 id="Method1-depth-first-search-recursion"><a href="#Method1-depth-first-search-recursion" class="headerlink" title="Method1 : depth-first-search(recursion)"></a>Method1 : depth-first-search(recursion)</h2><p>觀念：</p>
<ul>
<li>先往左下探到底，直到root.left為None的時候再將root.val append到list，接著traverse root.right。</li>
<li>每個遞迴都會創建一個新的list，如此利用list +&#x3D; list的方式將每次遞迴所return的陣列接起來。</li>
</ul>
<h2 id="Method1-depth-first-search-stack"><a href="#Method1-depth-first-search-stack" class="headerlink" title="Method1 : depth-first-search(stack)"></a>Method1 : depth-first-search(stack)</h2><p>觀念：</p>
<ul>
<li>一樣先往左traverse並將沿路看到的nodes push到stack裡，直到遇到null node時，就將stack的top node pop出來並放到result list，再將root更新為popedNode.right，只要stack不為empty且root ≠ null就繼續重複上述動作直到return。</li>
<li>此做法即是利用stack後進先出的特性，由於我們都是優先往左traverse，而根據Inorder traversal的特性越靠左下角的node越會先被traverse到，所以當我們撞到null node時，只要將stack pop出來，再把root移到popedNode.right繼續traverse，即可得到題目所求。</li>
</ul>
<h1 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h1><h2 id="Method1-“just-compare-both-of-them”-recursion"><a href="#Method1-“just-compare-both-of-them”-recursion" class="headerlink" title="Method1 : “just compare both of them”(recursion)"></a>Method1 : “just compare both of them”(recursion)</h2><p>觀念：</p>
<p>直接比對兩個tree(true or false)：</p>
<ul>
<li>若兩者皆為null → true</li>
<li>若其中一個為null → false</li>
<li>若都不是null(都有值) → (1)值不相等: false (2)值相等: look further</li>
</ul>
<h1 id="106-Convert-sorted-array-to-bst"><a href="#106-Convert-sorted-array-to-bst" class="headerlink" title="106. Convert sorted array to bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">106. Convert sorted array to bst</a></h1><h2 id="Method1-recursive"><a href="#Method1-recursive" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>觀念：</p>
<p>先找到middle value並initialize為root，middle value的左邊都小於自己，所以要放到root.left，相反地，將middle value的右邊都放到root.right，最後return root。</p>
<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a></h1><h2 id="Method1-recursion"><a href="#Method1-recursion" class="headerlink" title="Method1 : recursion"></a>Method1 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(logn)$</p>
<p>觀念：</p>
<h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></strong></h1><h2 id="Method1-recursive-postorder-traversal"><a href="#Method1-recursive-postorder-traversal" class="headerlink" title="Method1 : recursive(postorder traversal)"></a>Method1 : recursive(postorder traversal)</h2><p>觀念：</p>
<ul>
<li><p>postorder traversal</p>
</li>
<li><p>終止條件：null node → return 0(什麼都沒有)</p>
</li>
<li><p>遞迴：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftNodes = func(root.left)</span><br><span class="line">rightNodes = func(root.right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當$abs(leftNodes - rightNodes) &gt;&#x3D; 2$時，表示已經出現unbalanced情形所以其他的部分都不重要了(現在只要想辦法把這個結果一路傳回root)，於是return -1(這邊-1只是為了標記沒有其他含義)</li>
<li>當$leftNodes&#x3D;&#x3D;-1 ;||; rightNodes&#x3D;&#x3D;-1$，表示先前已經找到unbalanced，所以繼續return -1</li>
<li>當1.和2.都沒發生，則$return;1+max(leftNodes, ;rightNodes)$，要用max是因為對於任一個node來說，當出現左右不對稱情形，會用較深的那邊表示該節點的高度。</li>
</ol>
</li>
</ul>
<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></strong></h1><h2 id="Method-dfs-postorder-traversal"><a href="#Method-dfs-postorder-traversal" class="headerlink" title="Method : dfs(postorder traversal)"></a>Method : dfs(postorder traversal)</h2><p>時間：O(n)</p>
<p>空間：O(h)</p>
<p>觀念： </p>
<ol>
<li><p>當left_nodes和right_nodes其中一個為0且另一個不為0，代表只有一條路可以到leaf node(不為零的那條)，所以要return 1 + max(left_nodes, right_nodes)</p>
</li>
<li><p>除了1.以外的情況可再分為兩種：</p>
<ol>
<li>兩條路都可走：由於是找最短路徑，所以要走nodes較少的那條</li>
<li>兩條路都不可走：代表current node為leaf node(left &amp; right &#x3D;&#x3D; 0)</li>
</ol>
<p> 綜合a,b → return 1 + min(left_nodes, right_nodes)</p>
</li>
</ol>
<h1 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/description/">112. Path Sum</a></strong></h1><h2 id="Method1-recursive-1"><a href="#Method1-recursive-1" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>time: $O(n)$ , space: </p>
<p>觀念：</p>
<ul>
<li><p>由於是要traverse到leaf node，不太可能先”遞迴”再”做事”，所以為preorder traversal</p>
</li>
<li><p>終止條件：null node → return False</p>
</li>
<li><p>遞迴：</p>
<p>  由於要做加總，所以要把”total一路傳下去到leaf node”，而target也要傳因為要做比對</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = func(root.left, total, target)</span><br><span class="line">r = func(root.right, total, target)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當left或right其中一邊為True表示找到了sum path，這時return True，把True這個資訊接續傳上去</li>
<li>除了1.以外的情況，表示兩邊都是False(沒有找到)，這時就要看current node的total是否等於target sum，且因為題目限制為leaf node，所以要限制條件為沒有children node</li>
<li>如果1. 2.都不符合表示沒戲了，直接return False</li>
</ol>
</li>
</ul>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/description/">118. Pascal’s Triangle</a></strong></h1><h2 id="Method1-double-for-loops"><a href="#Method1-double-for-loops" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>觀念：</p>
<ul>
<li>由於return format為2d array → 直覺想到double for loops</li>
<li>架構：<ol>
<li>第一圈為2d array內所有sub array的iterations，也就是題目的numRows</li>
<li>第二圈為每個sub array內integer的iterations</li>
</ol>
</li>
<li>主體：<ol>
<li>對於triangle每一層的integer，只要是頭或尾都必為1</li>
<li>若不符合1.，代表是位於中間的integer，因此若我們假設current position為”i”，則其值為$prevArray[i];+;prevArray[i+1]$</li>
</ol>
</li>
</ul>
<h1 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/description/">119. Pascal’s Triangle II</a></strong></h1><h2 id="Method1-double-for-loops-1"><a href="#Method1-double-for-loops-1" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>time: $O(n^2)$ , space: $O(n^2)$</p>
<p>觀念：跟118.一樣，只是變成return最後一個array</p>
<h2 id="Method2-Mathematics"><a href="#Method2-Mathematics" class="headerlink" title="Method2 : Mathematics"></a>Method2 : Mathematics</h2><p>time: $O(n^2)$ , space: $O(n)$</p>
<p>觀念：帕斯克三角形第i列的第j個值為 → $C^i_j$ （i, j為0-indexed, 利用模組math的函式factorial計算）</p>
<p>→ $\frac{factorial(i)}{factorial(j)*factorial(i-j)}$</p>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding" class="headerlink" title="121. Best Time to Buy and Sell Stock(Window Sliding)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a>(<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/window-sliding-technique/">Window Sliding</a>)</strong></h1><h2 id="Method1-Window-Sliding-two-pointers"><a href="#Method1-Window-Sliding-two-pointers" class="headerlink" title="Method1 : Window Sliding(two pointers)"></a>Method1 : Window Sliding(two pointers)</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>profit最重要的就是買、賣價 → 所以想到用two pointers去紀錄</li>
<li>架構：初始化purchase_price、max_profit，一邊維護這兩個變數一邊遍歷陣列</li>
<li>主體：<ol>
<li>先比較current price和purchase_price<ol>
<li>current price &lt; purchase_price → 無利可圖，但需要更新purchase_price(買低就是賺)</li>
<li>current price ≥ purchase_price → 去看max_profit</li>
</ol>
</li>
<li>若情況為1-b，看當前利潤是否大於最大利潤 → $max(maxProfit,;currentPrice;-;purchasePrice)$</li>
</ol>
</li>
</ul>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></strong></h1><h2 id="Method-traverse-forward-and-backward-synchronously"><a href="#Method-traverse-forward-and-backward-synchronously" class="headerlink" title="Method : traverse forward and backward synchronously"></a>Method : traverse forward and backward synchronously</h2><p>time : O(n)</p>
<p>space : O(1)</p>
<p>補充：</p>
<ol>
<li>letters的大小寫轉換：string.upper() , string.lower()</li>
<li>判斷是否為letters or numbers：isalnum(<string>)</li>
</ol>
<p>觀念：</p>
<p>題目所給的string包含許多不是alphanumeric的符號，而palindrome的前後比對必須是pairs by pairs，所以當前或後遇到不是alphanumeric的時候必須跳過，只有當前後都為alphanumeric時才有比較的意義</p>
<h1 id="136-Single-Number-Wiki-XOR"><a href="#136-Single-Number-Wiki-XOR" class="headerlink" title="136. Single Number (Wiki: XOR)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/description/">136. Single Number</a> (<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">Wiki: XOR</a>)</strong></h1><h2 id="Method1-sort-it-first-then-compare-them"><a href="#Method1-sort-it-first-then-compare-them" class="headerlink" title="Method1 : sort it first, then compare them"></a>Method1 : sort it first, then compare them</h2><p>time: $O(nlogn)$ → the cost of built-in function sorted( ), note that every compare-based sorting algorithm at least cost nlogn</p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li><p>排序後一樣的number會比鄰排在一起</p>
</li>
<li><p>主體：</p>
<p>  每個number和它下一個比，如果一樣就跳到下下個繼續比，如果不一樣就return single number</p>
<ol>
<li>single number位在array的”非最後位置” → 發現不一樣時，single number一定是current number</li>
<li>single number位在array的最後 → 若已經看到最後一個位置，代表前面的numbers都是duplicates，這時不能和下一個比，直接return current number。</li>
</ol>
</li>
</ul>
<h2 id="Method2-XOR"><a href="#Method2-XOR" class="headerlink" title="Method2 : XOR"></a>Method2 : XOR</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>XOR：</p>
<ol>
<li><p>同性相斥：同樣的boolean: return False , 同樣的integer: return 0</p>
<p> e.g.</p>
<table>
<thead>
<tr>
<th>(a,b)</th>
<th>a^b</th>
</tr>
</thead>
<tbody><tr>
<td>(True, False)</td>
<td>True</td>
</tr>
<tr>
<td>(True, True)</td>
<td>False</td>
</tr>
<tr>
<td>(100, 0)</td>
<td>100</td>
</tr>
<tr>
<td>(100, 100)</td>
<td>0</td>
</tr>
<tr>
<td>(100, 10)</td>
<td>some number</td>
</tr>
</tbody></table>
</li>
<li><p>a^b^c^b^c &#x3D; b^b^c^c^a &#x3D; a</p>
</li>
</ol>
<p>觀念：0有還原某個數的特性 → 0^100 &#x3D; 100 , 0^0 &#x3D; 0，所以利用上述2.的特性，初始化一個變數為0，讓他去和整個array的number作XOR即可得到single number</p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></strong></h1><h2 id="Method1-hash-map"><a href="#Method1-hash-map" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：</p>
<ul>
<li><p>Node的結構為object，實質為某個unique的記憶體位址，所以即便有兩個node.val一樣，他們對於記憶體而言仍然是兩個不同的東西，利用此特性去儲存traverse到的每個node，就可以判斷是否有cycle</p>
</li>
<li><p>主體：</p>
<p>  儲存traverse過的每個node，如此判斷同一個node是否重複出現</p>
<ol>
<li><p>由於儲存的方式不用去管順序，且希望使用O(1)查找，所以適合用set( ) （<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-set.html">set相關用法</a>）</p>
<p> <em>→ set( ) is an unsorted and unique data structure</em></p>
</li>
<li><p>檢查每個node是否已在set( )內，如果有就代表出現cycle → return True，否則就將current node存到set( )</p>
</li>
<li><p>若traverse完整個node list都沒有return則代表沒有出現cycle → return False</p>
</li>
</ol>
</li>
</ul>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists</a></strong></h1><h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169. Majority Element</a></strong></h1><h2 id="Method1-hash-map-1"><a href="#Method1-hash-map-1" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：利用一個dictionary去統計不同數字出現的次數，直到發現某數的次數$&gt;\frac{1}{2}n$時就return該數</p>
<h2 id="Method2-Boyer-Moore-Voting-Algorithm-多數投票算法"><a href="#Method2-Boyer-Moore-Voting-Algorithm-多數投票算法" class="headerlink" title="Method2 : Boyer-Moore Voting Algorithm(多數投票算法)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Method2 :</a> <strong><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Boyer-Moore Voting Algorithm(多數投票算法)</a></strong></strong></h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>將$majority$想像成一個最強的軍隊，$count$想像成此軍隊的生命值，而其他的數通通組成較弱的一隊，在traverse的過程中如果$current;number&#x3D;&#x3D;majority$，表示他們為同一國的，則$count$+1，反之則為敵人，$count$-1，根據題目由於$majority$的數量一定超過總數的一半，所以可以確保最後必會產生出$majority$(至少剩一命)</li>
<li>注意：$if;count&#x3D;&#x3D;0$，表示目前最強軍隊的人都死光了，那就必須將<em>current number</em>變成新的王</li>
</ul>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel Sheet Column Number</a></strong></h1><h2 id="Method1-進位制"><a href="#Method1-進位制" class="headerlink" title="Method1 : 進位制"></a>Method1 : 進位制</h2><p>time:  O(n)</p>
<p>space: O(1), given the number of alphabet is fixed at 26</p>
<p>觀念：</p>
<ol>
<li>此題考進位制的概念，如同我們熟悉的十進位制計算一般，e.g. $18&#x3D;10^0<em>8;+;10^1</em>1$，英文字母(alphabet)的26進位制也是一樣的概念，e.g. $AB&#x3D;26^0<em>2;+;26^1</em>1&#x3D;28$</li>
<li>迴圈從string的右掃到左比較容易寫</li>
</ol>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></strong></h1><p>先備知識：</p>
<ol>
<li>Bits(Binary digits)：為二元進位的意思，每一位為0或1，e.g. 32bits的意思即為用32個位置的0或1來表示某一個數，沒用到的位置補零(補在前面)</li>
<li>function bin(<int>)：將integer轉成二進位制，return format為string，使用上通常為bin(<int>)[2:]，其中[2:]是為了省略開頭的”0b…”</li>
<li>int(<str>, <int>)：將<int>進位制的<str>轉換為一般的10進位制int，e.g. int(”0110”, 2) → 6</li>
</ol>
<h2 id="Method1-Just-coding"><a href="#Method1-Just-coding" class="headerlink" title="Method1 : Just coding"></a>Method1 : Just coding</h2><p>time:  O(n)</p>
<p>space: O(n) </p>
<p>觀念：</p>
<ol>
<li>利用func bin()將input轉換為二進位制的string，由於題目說input必須是32-bits，而因為func bin()返回的string會自動省略掉前面的0，所以必須將string的前面補零至32個character</li>
<li>reverse(1)得到的32-bits string </li>
<li>最後將reversed string利用func int()轉回正常的10進位int即可得答案</li>
</ol>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">20<strong>6. Reverse Linked List</strong></a></h1><h2 id="Method1-iterative"><a href="#Method1-iterative" class="headerlink" title="Method1 : iterative"></a>Method1 : iterative</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：想像成這個list會由右往左長，且方向是往右指</p>
<ol>
<li>初始化一個None </li>
<li>主體：每次將head的next紀錄起來，然後就可以將head接到answer node，接著把answer node往左移一格到剛接好的head，如此一來answer node就完成，最後將head指回一開始我們紀錄的next的位置</li>
</ol>
<h2 id="Method2-recursion"><a href="#Method2-recursion" class="headerlink" title="Method2 : recursion"></a>Method2 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：和iterative差不多只是換種寫法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/17/TheCrack/" data-id="cle7i0ew90000p2d388qehf7e" data-title="TheCrack" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/02/17/TheDeep/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TheDeep
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/17/TheDeep/">TheDeep</a>
          </li>
        
          <li>
            <a href="/2023/02/17/TheCrack/">TheCrack</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Francis<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>