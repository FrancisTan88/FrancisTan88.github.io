<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="String matching">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm - String Matching">
<meta property="og:url" content="http://example.com/2023/02/17/Algorithm-StringMatching/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:description" content="String matching">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-16T20:18:08.000Z">
<meta property="article:modified_time" content="2023-02-16T21:58:30.500Z">
<meta property="article:author" content="Francis">
<meta property="article:tag" content="String matching">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/17/Algorithm-StringMatching/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Algorithm - String Matching | FrancisTan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FrancisTan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just For Fun</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-StringMatching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Algorithm - String Matching
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:18:08 / Modified: 05:58:30" itemprop="dateCreated datePublished" datetime="2023-02-17T04:18:08+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="String-matching"><a href="#String-matching" class="headerlink" title="String matching"></a>String matching</h1><span id="more"></span>
<p>給兩個字串 T 和 P，找出 T 當中是否有一段字串正好是 P，並且找出其位置</p>
<blockquote>
<p>字串搜尋當中，通常將兩字串的象徵符號取做 T 和 P</p>
<ul>
<li>T 意指 Text</li>
<li>P 意指 Pattern</li>
</ul>
<p>可以想作是從長篇文字 T 之中搜索小段文字 P</p>
</blockquote>
<ul>
<li>若 P 在平移 s 個單位後（**T [s+1 … s+m] &#x3D; P [1 … m]**，0 ≦ s ≦ n-m）<ul>
<li>可以在 T 中該片段被找到<ul>
<li>稱為「合法平移」（Valid shift）</li>
</ul>
</li>
<li>無法在 T 中該片段被找到<ul>
<li>稱為「非法平移」（Invalid shift）</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- ![1549517694185](\willywangkaa\images\1549517694185.png) -->



<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Preprocessing time</th>
<th>Matching time</th>
</tr>
</thead>
<tbody><tr>
<td>Native</td>
<td>0</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr>
<td>Rabin-Karp</td>
<td>θ(∣P∣)</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr>
<td>Morris-Pratt Automaton</td>
<td>O(∣P∣×∣Σ∣)</td>
<td>θ(∣T∣)</td>
</tr>
<tr>
<td>Knuth-Morris-Pratt</td>
<td>θ(∣P∣)</td>
<td>θ(∣T∣)</td>
</tr>
</tbody></table>
<h2 id="Naive-string-matching（窮舉法）"><a href="#Naive-string-matching（窮舉法）" class="headerlink" title="Naive string matching（窮舉法）"></a>Naive string matching（窮舉法）</h2><p>最直覺的算法</p>
<ol>
<li>挪動 P 以對準 T 的各個位置</li>
<li>逐一比對字元、判斷是否相等</li>
</ol>
<!-- Example

![1549518031466](\willywangkaa\images\1549518031466.png)

![1549518053082](\willywangkaa\images\1549518053082.png)

![1549518063746](\willywangkaa\images\1549518063746.png)
 -->
<!-- ![1549518076863](\willywangkaa\images\1549518076863.png) -->



<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nativestrinmatcher</span><span class="params">(string T,string P)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = P.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>時間複雜度</p>
<ul>
<li>O( (|T|-|P|+1)×|P| )<ul>
<li><strong>O( |T||P| )</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>空間複雜度</p>
<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h2 id="Rabin-Karp-演算法"><a href="#Rabin-Karp-演算法" class="headerlink" title="Rabin-Karp 演算法"></a>Rabin-Karp 演算法</h2><p>由 Michael O. Rabin 及 Richard M. Karp 在 1987 年發展利用<strong>雜湊作字串判斷</strong>，帶有數學味道的演算法</p>
<ul>
<li>一個長度為 m 的模板字串 P<ul>
<li>視為一個 d 進制（d &#x3D; ∣Σ∣）的數字 p</li>
<li>令 $t_s$ 為 T[s+1…s+m] 轉換後的結果</li>
</ul>
</li>
<li>問題轉換成「是否存在一個 k(0 ≤ k ≤ n − m)，使得 $p &#x3D; t_k$」</li>
</ul>
<blockquote>
<p>p &#x3D;  ∣Σ∣(P[m-1]+(∣Σ∣(P[m-2]+… (∣Σ∣(P[2]+∣Σ∣P[1]) …))) + P[m]</p>
<p>$\Rightarrow p &#x3D; ｜Σ｜^{m-1}P[1]+｜Σ｜^{m-2}P[2]+\ldots+｜Σ｜^{0}P[m]$</p>
<p>$t_{s+1} &#x3D; ｜Σ｜(t_s - ｜Σ｜^{m-1}T[s+1])+T[s+m+1]$</p>
</blockquote>
<p>Example</p>
<p>Σ &#x3D; ｛0, 1, …, 9｝，d &#x3D; ∣Σ∣ &#x3D; 10</p>
<ul>
<li>Pattern P[1…m]<ul>
<li>p 為對應的十進位數字</li>
</ul>
</li>
<li>Text T[1…n]<ul>
<li>$t_s$ 為<strong>長度為 m 子字串</strong>（T[s+1…s+m]，s &#x3D; 0, 1, …, n-m）中對應的十進位數字</li>
</ul>
</li>
<li>字串 ［3 1 4 1 5 2］<ul>
<li>轉換後為 314,152</li>
</ul>
</li>
</ul>
<blockquote>
<p>$t_{s+1}$ 與 $t_s$ 的關係</p>
<p>$t_{s+1} &#x3D; 10(t_s - 10^{m-1}T[s+1])+T[s+m+1]$</p>
<p>所以，上述表示為</p>
<p>T &#x3D; ［3 1 4 1 5 2］、m &#x3D; 5、d &#x3D; 10</p>
<p>$t_s &#x3D; t_0 &#x3D; 31,415$</p>
<p>$\Rightarrow t_{s+1} &#x3D; t_1 &#x3D; 10(31,415-10^{5-1}\cdot3)+2 &#x3D; 14,152$</p>
</blockquote>
<blockquote>
<ul>
<li>因為 p 以及 $t_k$ <strong>可能非常大</strong><ul>
<li>因此比較時間不能視為常數</li>
</ul>
</li>
<li>通常將其 mod 一個大質數 q<ul>
<li>因為如此當 $p &#x3D; t_k$ 時，不一定匹配成功，須再作進一步驗證<ul>
<li>Spurious hit（假性命中）<ul>
<li>$p &#x3D; t_k$ 但 P[1…m] <strong>≠</strong> T[s+1…s+m]</li>
</ul>
</li>
<li>Valid hit（完全命中）<ul>
<li>$p &#x3D; t_k$ 與 P[1…m] <strong>&#x3D;</strong> T[s+1…s+m]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>Example</p>
<ul>
<li>P[1…5] &#x3D; 31,415<ul>
<li>p &#x3D; <strong>31,415 mod 13</strong> &#x3D; 7</li>
</ul>
</li>
</ul>
<!-- ![1549521217587](\willywangkaa\images\1549521217587.png) -->

<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rabinkarpmatcher</span> <span class="params">(T,P,d,q)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = T.<span class="built_in">length</span>();</span><br><span class="line">    h = <span class="built_in">pow</span>(d,m<span class="number">-1</span>) % q;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Preprocessing</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to m &#123;</span><br><span class="line">        p = (d*p + P[i]) % q;</span><br><span class="line">        t[<span class="number">0</span>] = (d*t_0 + T[i]) % q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Matching</span></span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == t[s])&#123;</span><br><span class="line">            <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next substring</span></span><br><span class="line">        <span class="keyword">if</span>(s &lt; n-m)&#123;</span><br><span class="line">            t[s+<span class="number">1</span>] = (d*(t[s]-T[s+<span class="number">1</span>]*h)+T[s+m+<span class="number">1</span>]) % q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>時間複雜度</p>
<ul>
<li>預處理<ul>
<li>θ (∣P∣)</li>
</ul>
</li>
<li>比對程序<ul>
<li><strong>O( (∣T∣-∣P∣+1)×∣P∣ )</strong></li>
<li>發生在「Worst case」情況</li>
<li>在多數比對次數少、q 大於 m 的情況為線性複雜度</li>
</ul>
</li>
</ul>
</li>
<li><p>空間複雜度</p>
<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h2 id="Knuth-Morris-Pratt-演算法"><a href="#Knuth-Morris-Pratt-演算法" class="headerlink" title="Knuth-Morris-Pratt 演算法"></a>Knuth-Morris-Pratt 演算法</h2><p>由 Donald Knuth、Vaughan Pratt、J. H. Morris 三人於西元 1977 年共同聯合發表，<strong>最差情況為 O(n) 的字串匹配演算法</strong></p>
<blockquote>
<p><strong>觀察暴力演算法</strong></p>
<ul>
<li>存在不必要的工作<ul>
<li>從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位</li>
<li>往右挪動 P 之前，當下比對成功的字串片段，可以不必花時間在上面</li>
</ul>
</li>
</ul>
<p>Example</p>
<ul>
<li>T &#x3D; [aabzabzabcz]</li>
<li>P &#x3D; [abzabc]</li>
</ul>
<p>（從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位）</p>
</blockquote>
<!-- > ![1549522985570](\willywangkaa\images\1549522985570.png) -->
<blockquote>
<p>（在往右挪動 P 之前，當下比對成功的字串片段「abzab」可以加以利用）</p>
</blockquote>
<!-- > ![1549523718157](\willywangkaa\images\1549523718157.png) -->
<blockquote>
<p>（繼續往右挪動 P，挪動一個位置、挪動兩個位置、…）</p>
</blockquote>
<!-- > ![1549523787809](\willywangkaa\images\1549523787809.png) -->
<blockquote>
<p>觀察上述行為</p>
<ul>
<li><p>挪動一個位置</p>
<ul>
<li>比較『abzab 的<strong>後四個字元</strong>』與『abzab 的<strong>前四個字元</strong>』</li>
</ul>
</li>
<li><p>挪動兩個位置</p>
<ul>
<li>比較『abzab 的<strong>後三個字元</strong>』與『abzab 的<strong>前三個字元</strong>』</li>
</ul>
</li>
<li><p>因此若預先知道『 abzab 之「次長相同前綴後綴」是 ab』</p>
<ul>
<li><strong>可大幅挪動 P</strong><ul>
<li>從「V」處繼續向右一一比對字元</li>
<li>每當比對失敗，就從當前比對成功的字串片段，取其「次長的相同前綴後綴」大幅挪動 P</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<!-- > ![1549524105095](\willywangkaa\images\1549524105095.png) -->
<blockquote>
<p><strong>「相同前綴後綴」</strong>（Prefix-suffix）</p>
</blockquote>
<!-- > ![1549524327132](\willywangkaa\images\1549524327132.png) -->
<blockquote>
<p><strong>「次長相同前綴後綴」</strong></p>
<ul>
<li>一個字串的「最長相同前綴後綴」為<strong>原字串</strong></li>
<li>「最短相同前綴後綴」為<strong>空字串</strong></li>
<li>「次長相同前綴後綴」就是第二長的「相同前綴後綴」</li>
</ul>
</blockquote>
<!-- > ![1549524493648](\willywangkaa\images\1549524493648.png) -->
<blockquote>
<p>窮舉法的過程當中，<strong>當前比對成功的字串片段是 P 的前綴</strong></p>
<ul>
<li>因為無法預測是 P 的哪個前綴<ul>
<li>所以<strong>預先計算 P 每個前綴的「次長的相同前綴後綴」</strong></li>
<li>衍生出了「Failure function」</li>
</ul>
</li>
</ul>
</blockquote>
<p>步驟</p>
<ol>
<li>預先計算 P 的每種前綴的「次長相同前綴後綴」<ul>
<li>意旨算出 P 的「Failure function」</li>
</ul>
</li>
<li>從左往右依序比對字元<ul>
<li>比對成功時<ul>
<li>繼續比對下個字元</li>
</ul>
</li>
<li>比對失敗時<ul>
<li>從比對成功的<strong>字串片段取其「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul>
</li>
<li>當全部比對成功搜尋到 P 時<ul>
<li><strong>取 P「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( pattern[k] != pattern[i+<span class="number">1</span>]   <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; i&gt;=<span class="number">0</span> )&#123;                    <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Morris_Pratt</span><span class="params">(string T, string P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> P.size &gt; T.size</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">GetFailureFunction</span>(P);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 進行字串搜尋，時間複雜度：O(T)</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to T.size &#123;</span><br><span class="line">        s = <span class="number">-1</span>;                                      <span class="comment">// 目前 P 字元比對已成功的位置</span></span><br><span class="line">        <span class="comment">// 比對 P 的下一個尚未比對位置（s+1）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若 T[k] != P[s+1]，尋找大幅挪動的步伐數</span></span><br><span class="line">        <span class="comment">// 在 P 中找出 P[1..s] == T[k-s..k] 以大幅挪動 P</span></span><br><span class="line">        <span class="keyword">while</span> ( P[s+<span class="number">1</span>] != T[k]                       <span class="comment">// T[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; s &gt;= <span class="number">0</span> ) &#123;                          <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            s = failure[s];                          <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// T[k] 與 P[s+1] 比對成功</span></span><br><span class="line">        <span class="keyword">if</span> (P[s+<span class="number">1</span>] == T[k]) &#123;                         </span><br><span class="line">            s++;                                     <span class="comment">// P 字元比對已成功的位置後移一位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s == P.size<span class="number">-1</span>) &#123;                        <span class="comment">// P 字元比對已成功的位置已移完</span></span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&quot; P出現的位置&quot;</span> + (s-P.size+<span class="number">1</span>) );</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            s = failure[s];                         <span class="comment">// 如果字串結尾不是&#x27;\0&#x27;的時候，就必須挪動 P</span></span><br><span class="line">                                                    <span class="comment">// 如果字串結尾是&#x27;\0&#x27;的時候，就能省略這一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="時間複雜度分析（均攤分析）"><a href="#時間複雜度分析（均攤分析）" class="headerlink" title="時間複雜度分析（均攤分析）"></a>時間複雜度分析（均攤分析）</h3><p>以「Multipop stack」概念作均攤分析，以<strong>字元兩兩比對總次數</strong>作為時間複雜度</p>
<p>（1）進行字串搜尋的過程中</p>
<ul>
<li>「Stack」S 的元素<ul>
<li>當下比對成功的字串片段 S<ul>
<li><strong>一開始 S 長度是零</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>若字元比對成功</strong><ul>
<li>S 增加一字元，<strong>視為「Push stack」</strong></li>
</ul>
</li>
<li><strong>若字元比對失敗</strong><ul>
<li>大幅挪動 P，S 只剩下「次長的相同前綴後綴」，<strong>視為「Multipop」</strong></li>
<li>實際上 S 瞬間大幅變短只需要 O(1) ，時間複雜度遠比「Multipop」小</li>
</ul>
</li>
</ul>
<ol>
<li><p>最多有 T 個字元放入 S（S 增加一字元）</p>
</li>
<li><p>最多有 T 個字元彈出 S（大幅挪動 P，S 只剩下「次長的相同前綴後綴」）</p>
</li>
</ol>
<p>$\Rightarrow$<strong>字元兩兩比對的總次數不超過 2T 次</strong></p>
<p>（2）計算 P 的「Failure function」過程中</p>
<p>原理相同，字元兩兩比對的總次數不超過 2P 次</p>
<ul>
<li><strong>總時間複雜度</strong><ul>
<li>O(∣T∣+∣P∣)</li>
</ul>
</li>
</ul>
<h3 id="Failure-function"><a href="#Failure-function" class="headerlink" title="Failure function"></a>Failure function</h3><p>在比對失敗時會使用之</p>
<p>因為函數的<strong>定義域</strong>是 Prefix，又稱作 Prefix function </p>
<p>因為此函數的<strong>值域</strong>是 Border，又稱作 Border function</p>
<ul>
<li><strong>字串函數</strong><ul>
<li>輸入字串的其中一個前綴，<strong>輸出該前綴的「次長的相同前綴後綴」</strong></li>
</ul>
</li>
</ul>
<!-- ![1549524903137](\willywangkaa\images\1549524903137.png)

![1549529928795](\willywangkaa\images\1549529928795.png) -->

<ul>
<li>計算「Failure function」 <ul>
<li>Dynamic Programming</li>
<li>分割問題<ul>
<li>P[0…i] 除去尾端字元 P[i] </li>
<li>利用已知 P[0…i-1] 的「次長相同前綴後綴」</li>
<li>得到 P[0…i] 的「次長相同前綴後綴」</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>F[k]：P[0…k] 之「次長的相同前綴後綴」<strong>長度</strong></p>
<p>（1）將 F[0] 初始化為 -1</p>
<ul>
<li>長度為 1 的子字串，不存在「次長相同前綴後綴」</li>
</ul>
<p>（2）F[k]：<strong>探討 P[1…k-1] 與 P[k] 之間的關係</strong></p>
<!-- ![1549530552160](\willywangkaa\images\1549530552160.png) -->

<ul>
<li><strong>P[ F[k-1]+1 ] &#x3D;&#x3D; P[k]</strong><ul>
<li>意旨「<strong>第 k 個字元</strong>」與「<strong>P[1…k-1] 之『次長的相同前綴後綴』下一個字元</strong>」相等</li>
<li>$\Rightarrow$ <strong>F[k] &#x3D; F[k-1]+1</strong></li>
</ul>
</li>
</ul>
<!-- ![1549530722575](\willywangkaa\images\1549530722575.png) -->



<blockquote>
<p><strong>對「P[1…k-1] 之『次長的相同前綴後綴』」作探討</strong></p>
</blockquote>
<!-- > ![1549534207507](\willywangkaa\images\1549534207507.png) -->



<ul>
<li>P[ F[k-1]+1 ] ≠ P[k]<ul>
<li>「<strong>第 k 個字元</strong>」與「P[1…k-1] 之『次長的相同前綴後綴』下一個字元」相異</li>
</ul>
</li>
</ul>
<p><strong>若存在 P[ F…[F[k-1]]+1 ] &#x3D;&#x3D; P[k]，則 F[k] &#x3D; F…[F[k-1]]+1</strong></p>
<!-- ![1549535284950](\willywangkaa\images\1549535284950.png) -->



<p><strong>若不存在 P[ F…[F[k-1]]+1 ] &#x3D;&#x3D; P[k]，則 F[k] &#x3D; -1</strong></p>
<!-- ![1549535607960](\willywangkaa\images\1549535607960.png) -->



<p>上述可以表達為：</p>
<ul>
<li><p>$f[k]\left{\begin{matrix}<br>-1 &amp; if ;k &#x3D; 0\ f^m[k-1] +1 &amp; 最小的整數; m;使得; P[f^m[k-1]+1] &#x3D;&#x3D; P[k]<br>\ -1 &amp; 不存在整數; m ;可以使得 P[f^m[k-1]+1] &#x3D;&#x3D; P[k]\end{matrix}\right.$</p>
</li>
<li><p>Algorithm</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((pattern[k]!=pattern[i+<span class="number">1</span>]) &amp;&amp; <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              i&gt;=<span class="number">0</span>)&#123;                        <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Morris-Pratt-Automaton"><a href="#Morris-Pratt-Automaton" class="headerlink" title="Morris-Pratt Automaton"></a>Morris-Pratt Automaton</h3><p>此演算法可以化作自動機，轉化的時間複雜度為 O( ∣P∣×∣Σ∣ ) </p>
<ul>
<li>Σ 為字元集合</li>
</ul>
<blockquote>
<p>化作自動機之後，字串搜尋的過程就變得更簡單了，甚至可以設計成電子迴路</p>
<p>轉化的原理，是針對每個狀態，都找出經由「Failure function」能到達的狀態們，然後建立轉移邊，連到那些狀態們的下一個狀態</p>
</blockquote>
<!-- ![1549541112414](\willywangkaa\images\1549541112414.png) -->

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/String-matching/" rel="tag"># String matching</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/17/TheDeep/" rel="prev" title="Leetcode - Top Interview">
      <i class="fa fa-chevron-left"></i> Leetcode - Top Interview
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/17/Algorithm-DynamicProgramming/" rel="next" title="Algorithm - Dynamic Programming">
      Algorithm - Dynamic Programming <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#String-matching"><span class="nav-number">1.</span> <span class="nav-text">String matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Naive-string-matching%EF%BC%88%E7%AA%AE%E8%88%89%E6%B3%95%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">Naive string matching（窮舉法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rabin-Karp-%E6%BC%94%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">Rabin-Karp 演算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Knuth-Morris-Pratt-%E6%BC%94%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">Knuth-Morris-Pratt 演算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E5%9D%87%E6%94%A4%E5%88%86%E6%9E%90%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">時間複雜度分析（均攤分析）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Failure-function"><span class="nav-number">1.3.2.</span> <span class="nav-text">Failure function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Morris-Pratt-Automaton"><span class="nav-number">1.3.3.</span> <span class="nav-text">Morris-Pratt Automaton</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Francis"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Francis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
