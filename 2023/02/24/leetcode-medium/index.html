<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Medium">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode - Medium">
<meta property="og:url" content="http://example.com/2023/02/24/leetcode-medium/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:description" content="Medium">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-24T10:35:28.000Z">
<meta property="article:modified_time" content="2023-03-12T10:34:10.319Z">
<meta property="article:author" content="Francis">
<meta property="article:tag" content="Medium">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/24/leetcode-medium/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Leetcode - Medium | FrancisTan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FrancisTan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just For Fun</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/leetcode-medium/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode - Medium
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-24 18:35:28" itemprop="dateCreated datePublished" datetime="2023-02-24T18:35:28+08:00">2023-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-12 18:34:10" itemprop="dateModified" datetime="2023-03-12T18:34:10+08:00">2023-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h1><span id="more"></span>


<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/description/">Add Two Numbers</a></h1><h2 id="Method1：just-add-them-best-solution"><a href="#Method1：just-add-them-best-solution" class="headerlink" title="Method1：just add them(best solution)"></a>Method1：just add them(best solution)</h2><p>time：O(max(n, m)), given n, m represent the length of two lists</p>
<p>space：O(max(n, m)), given n, m represent the length of two lists</p>
<p>觀念：</p>
<ol>
<li>利用一個變數carry來處理進位的問題，每一個iteration的addition為：list1.val + list2.val + carry，而由於是十進位的加法，所以作完加法的每一個digit &#x3D; addition % 10<ol>
<li>若addition ≥ 10：需要進位 → carry &#x3D; True</li>
<li>若addition &lt; 10：carry &#x3D; False</li>
</ol>
</li>
<li>Edge case：當the most significant digit(最大的位數)要進位時，此時需要增加list的長度，故若iteration結束而carry &#x3D; True，就在最後增加一個ListNode(val&#x3D;1)</li>
</ol>
<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></strong></h1><h2 id="Method1：two-pointers-sliding-window-best-solution"><a href="#Method1：two-pointers-sliding-window-best-solution" class="headerlink" title="Method1：two pointers - sliding window(best solution)"></a>Method1：two pointers - sliding window(best solution)</h2><p>time：O(n)</p>
<p>space：O(n)</p>
<p>觀念：</p>
<ol>
<li>利用hashmap去紀錄每一個char的idx</li>
<li>利用兩個變數left, right，left一開始為零、right則是一直往前跑，當出現repeating char時可分為兩種情況：<ol>
<li>repeating char在[left, right]區間裡：將left往前拉到repeating char的next position，因為對於現在區間而言若left還停留在repeating char之前，則[left, right]無論如何都不會是longest panlindrome，且更新hashmap的idx為right的位置</li>
<li>repeating char不在[left, right]區間裡：考慮case “tmmzuxt”，t為duplicates，只是當第二個t被traverse到的時候，第一個t已不在[left, right]區間內，所以可以照常計算max_len</li>
</ol>
</li>
<li>若沒有出現2-(a)的情況則計算當前長度以持續維護max_len</li>
</ol>
<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></strong></h1><h2 id="Method1：Expand-from-every-center"><a href="#Method1：Expand-from-every-center" class="headerlink" title="Method1：Expand from every center"></a>Method1：Expand from every center</h2><p>time：O(n^2)</p>
<p>space：O(1)</p>
<p>觀念：</p>
<ol>
<li>新增一個函式，利用兩個變數(left_pos、right_pos)將每個character視為center，同步往左右兩邊擴展，一一比對左右兩個char是否相同，若相同就繼續擴展，直到左右不一樣或是左右某一個char超出string的範圍時，就回傳左右的位置（Note：迴圈中斷時，要馬是(1)左右兩個char不相同，或是(2)左右之中至少一個超出string的範圍，所以在回傳left_pos、right_pos之前需要將left +&#x3D; 1、right -&#x3D;1）</li>
<li>palindrome有兩種：(1)長度為奇數，e.g “aba”  (2)長度為偶數，e.g. “abba”，所以這兩種情形都要考慮到，即對於string的每個char，都要進行兩次expand，一次為current char當作center、一次為current char和其next char當作center</li>
<li>注意題目是問最長的回文，所以在解題時其實只要maintain相距最遠的left_pos, right_pos就好，即初始化兩個變數start, end為零，檢查每次expand回傳的left_pos, right_pos，若有比start, end相距還遠，就更新start, end，最後再return “string[start : end+1]”即可（這樣就不用浪費O(n)的空間去真的maintain一個longest string）</li>
</ol>
<h2 id="Method2：dynamic-programming"><a href="#Method2：dynamic-programming" class="headerlink" title="Method2：dynamic programming"></a>Method2：dynamic programming</h2><p>先備知識：DP</p>
<ol>
<li>DP的核心觀念：將一個問題切成子問題，將子問題切成子子問題，以此類推，並透過儲存每一次的計算成果，達到減少重複計算的目的</li>
<li>儲存計算結果的方式通常為1D-table或是2D-table </li>
<li>就如同遞迴函式一樣，DP一定會有基本(初始)條件，所以在建完用來儲存計算結果的表後，我們通常需要assign一些值進去</li>
<li>續(3)：舉個基本條件的例子，以計算階乘為例，我們知道n! &#x3D; (n-1)! * n，而1! &#x3D; 1，所以我們可以利用”1! &#x3D; 1”這個基本條件去計算2以後的所有階乘，可以列出以下式子 → For function f(n): (1)f(n) &#x3D; 1 , n &#x3D;&#x3D; 1 (2)f(n) &#x3D; f(n-1)*n , n ≥ 2</li>
</ol>
<p>time：O(n^2)</p>
<p>space：O(n^2)</p>
<p>觀念：</p>
<ol>
<li><p>此題利用DP的精髓在於：若s[ i ] &#x3D;&#x3D; s[ j ]，且s[ i+1 : j-1 ]為palindrome，則s[ i : j ]為palindrome，如此達到”重複利用先前計算結果”的效果，所以2D-table的任一entry實際上為bool，即table[ i ][ j ]代表的就是s[ i : j ]是否為palindrome</p>
</li>
<li><p>上述先備知識(3)應用於此題為：每單一個char自己就是palindrome，所以在建完2D-table後，需要將table[ 1 ][ 1 ], table[ 2 ][ 2 ] … 等初始化為True</p>
</li>
<li><p>利用double for loops分別去迭代start_pos, end_pos，並利用兩個變數leftmost、rightmost去maintain最長的回文區間，當s[ start_pos ] &#x3D;&#x3D; s[ end_pos]時，需要更新table有兩種情形：</p>
<ol>
<li>end_pos -  start_pos &#x3D;&#x3D; 1：表示為偶數的回文</li>
<li>s[start_pos+1 : end_pos-1]為palindrome(去table看)</li>
</ol>
<p> 以上兩種皆為有效的palindrome，此時就檢查當前區段是否為longest，是的話就更新leftmost、rightmost，並更新table[start_pos][end_pos]為True
 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/solutions/474664/commented-clean-python-dp-solution/#:~:text=hungapp,end">(explanation見評論區)</a>%3A)</p>
<p> 由於我們想要以最短的substring為開始去填dp table，迴圈(start, end)的設置必須是由”短到長”，e.g. s &#x3D; “abba”，double for loops的起始點(start_pos, end_pos)依序為”ab”, “bb”, “ba”，而非”ab”, “ab”, “aa”，這是由於觀念(1)，我們現在考慮start_pos, end_pos分別在first “a”, last “a”，演算法會去table看”bb”是否為palindrome，而若我們不是由”短到長”去iterate的話，此時”bb”根本還沒被iterate到，因此無法找出所求，反之則可以求出正解</p>
</li>
</ol>
<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/description/">Container With Most Water</a></h1><h2 id="Method1：Two-pointers-sliding-window-best-solution"><a href="#Method1：Two-pointers-sliding-window-best-solution" class="headerlink" title="Method1：Two pointers - sliding window(best solution)"></a>Method1：Two pointers - sliding window(best solution)</h2><p>time：O(n)</p>
<p>space：O(1)</p>
<p>concept：由於是算面積，要想到用”夾住”的概念(top down)，即一開始就直接考慮最寬的情況，然 後慢慢往內縮</p>
<p>main：</p>
<ol>
<li>每次都移動較矮的那根，試想，如果是移動較高的那根只會有兩種情況，(1): 新的那根高於較矮的那根，此情況則還是會以矮的那根為主 (2): 新的那根低於較矮的那根，此情況面積只會更小，所以以上兩種情況都沒有意義。</li>
<li>濃縮1.的概念，由於一開始已經是從”最寬”的情況往內縮，所以得到較大面積唯一的可能為找到比當前更高的高度，則只有移動矮的那根才可能做得到。</li>
</ol>
<p>terminal condition：</p>
<p>當兩個pointer碰到</p>
<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/description/">15. 3Sum</a></strong></h1><p>time：O(n^2)</p>
<p>space：O(n)</p>
<h2 id="Method1：Two-pointers-and-set-best-solution"><a href="#Method1：Two-pointers-and-set-best-solution" class="headerlink" title="Method1：Two pointers and set(best solution)"></a>Method1：Two pointers and set(best solution)</h2><p>觀念：</p>
<p>set</p>
<ol>
<li>由於題目要求三個數不能有duplicates，且不要求順序，所以使用set來存取答案 → set的unique property：<ol>
<li>當set裡存的是一個個number → 只要值不同就可以被存入 </li>
<li>當set裡存的是一個個tuple(set只能存hashable object) → 只要tuple裡的值順序不同就可以被存入，e.g. (1,2,3) &amp; (1,3,2)→可以、(1,2,3) &amp; (1,2,3)→不行</li>
</ol>
</li>
<li>插入：set.add(<hashable object>)，e.g. tuple &#x3D; (1,2,3), set.add(tuple)</li>
<li>刪除：set.remove(<hashable object>)，e.g. set.remove(tuple) </li>
<li>註：”All of Python’s immutable built-in objects are hashable”，所以set可以存tuple(不可被修改)，但不能存lists, sets</li>
</ol>
<p>two pointers </p>
<ol>
<li>先排序number array，從左到右(len-2)iterate，將current pointer(i)視為base number，剩下的兩個數則是我們要找的target，也就是-1*base number </li>
<li>利用left(i+1), right(last element)去夾住base number之後的elements：<ol>
<li>while condition：由於題目要求三個數的index不能重複，所以條件會是while left &lt; right</li>
<li>當(left + right) &lt; target : 表示要變大，所以left往右移動一格 </li>
<li>當(left + right) &gt; target : 表示要變小，所以right左移動一格 </li>
<li>當(left + right) &#x3D; target : 表示找到答案，將三個數按照順序放入set，此時因為我們每次都是將值按照順序插入set，所以set會自動幫我們過濾掉duplicates，而也因為題目不允許答案有duplicates，此時就將兩個pointers都往中間移。</li>
</ol>
</li>
</ol>
<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">Remove Nth Node From End of List</a></h1><p>先備知識：linked list世界裡的”remove”常常是將previous node接到current node的next node</p>
<h3 id="Method1：count"><a href="#Method1：count" class="headerlink" title="Method1：count"></a>Method1：count</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>先traverse一次linked list統計nodes數量，為了刪除該node，我們需要得到其”前一個”node的位置，因此拿node總數減掉題目所給的n可得該位置</li>
<li>第二次traverse時也是一邊count nodes去走到由(1)所得的位置，走到該位置後利用”先備知識”所述的方法刪除node並return head即可</li>
<li>special case：若(2)的情況沒有發生(no return)，則代表要刪除node為第一個node，而由於first node並無所謂的previous node，因此無法利用(2)的方法將其刪除，此時的post processing為直接return head.next即可</li>
</ol>
<h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><strong>22. Generate Parentheses</strong></h1><h3 id="Method1：backtracking"><a href="#Method1：backtracking" class="headerlink" title="Method1：backtracking"></a>Method1：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/solutions/2542620/python-java-w-explanation-faster-than-96-w-proof-easy-to-understand/">backtracking</a></h3><h3 id="Method2：DP"><a href="#Method2：DP" class="headerlink" title="Method2：DP"></a>Method2：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/solutions/10127/an-iterative-method/">DP</a></h3><p>f(0): “”</p>
<p>f(1): “(“f(0)”)”</p>
<p>f(2): “(“f(0)”)”f(1), “(“f(1)”)”</p>
<p>f(3): “(“f(0)”)”f(2), “(“f(1)”)”f(1), “(“f(2)”)”</p>
<p>So f(n) &#x3D; “(“f(0)”)”f(n-1) , “(“f(1)”)”f(n-2) “(“f(2)”)”f(n-3) … “(“f(i)”)”f(n-1-i) ,  “(f(n-1)”)”</p>
<p>Note: i為1~n-2</p>
<h1 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array">Search in Rotated Sorted Array</a></h1><h3 id="Method1：variation-of-binary-search"><a href="#Method1：variation-of-binary-search" class="headerlink" title="Method1：variation of binary search"></a>Method1：variation of binary search</h3><p>時間：O(logn)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>稍微思考一下此題rotate後的樣子會長成”兩個ascending order interval”，且左邊的interval &gt; 右邊的interval</li>
<li>知道了(1)之後，接著判斷mid所處的位置進而決定要怎麼移動left和right： <ol>
<li>若nums[mid] &#x3D;&#x3D; target : return mid</li>
<li>若nums[mid] &lt; nums[right] : 代表mid位在”right ascending order interval”，此時只要比較target是否位在此右區間，若是的話就往右search，反之則往左</li>
<li>若nums[mid] &gt; nums[right] : 代表mid位在”left ascending order interval”，此時只要比較target是否位在此左區間，若是的話就往左search，反之則往右</li>
</ol>
</li>
</ol>
<h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum">Combination Sum</a></h1><p>先備知識：backtracking</p>
<ul>
<li><p>使用時機：當一個問題在於”找出所有可能解”的時候</p>
</li>
<li><p>觀念：backtracking通常包含三個部分</p>
<ul>
<li>choose: 找出可能的解(candidates)，可以試著思考”找解的步驟或是方式為何”</li>
<li>constraints: 在找解的過程中，思考在什麼情況下”不用繼續找下去” 或是 ”才要繼續找下去”，像是”最大不能超過某個值”或是”要符合某種條件(e.g. panlidrome)”，而不符合此限制時演算法會向”下一步邁進”</li>
<li>target: 即在什麼情況下current candidates符合題目所求，達到target時通常此時會用某種資料結構將current candidates存起來，然後演算法向”下一步邁進”</li>
</ul>
<p>  → 思考以上三點後通常可以整理出一個固定的模式，所以在解題時不需要先想code怎麼寫，而是先想辦法歸納出演算法的模式
  </p>
</li>
<li><p>寫法：通常會包含(1)loop (2)recursive 這兩部分，而recursive負責實際的統計或計算、loop負責充當發生「不符合constraints」或「滿足target」後，將演算法向下一步推進的角色</p>
</li>
</ul>
<h3 id="Method1：dfs-backtracking"><a href="#Method1：dfs-backtracking" class="headerlink" title="Method1：dfs(backtracking)"></a>Method1：dfs(backtracking)</h3><p>時間：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/solutions/1755084/detailed-time-and-space-complexity-analysis-c-java-backtracking/?orderBy=most_votes">https://leetcode.com/problems/combination-sum/solutions/1755084/detailed-time-and-space-complexity-analysis-c-java-backtracking/?orderBy=most_votes</a></p>
<p>空間：(同上)</p>
<p>觀念：</p>
<p>e.g nums &#x3D; [2,3,6,7] , target &#x3D; 7</p>
<ol>
<li><p>choose: 此題可以允許同一個number(自己)被使用多次，所以想法上為：由左至右，先一直”加自己”直到不符合constraints或滿足target，再往右移一格並重複做一樣的事，而在寫法上因為有多組可能，所以需要一個curr_arr、ans_arr分別去紀錄當前可能的答案和所有的答案，另外需要有個變數summation去紀錄當前的加總值</p>
<p> 注意：以上提到的幾個變數都是寫在遞迴參數內，而非寫在其他行，為的就是當不符合constraints或滿足target return後，算法可以自己回到”上一個狀態”而不需要再去手動對curr_arr和summation進行處理</p>
</li>
<li><p>constraints: 當summation &gt; target時，代表不用再”累加自己”上去，而因為是遞迴，所以此時為了回到上一個狀態，e.g. <a href="%E7%88%86%E6%8E%89">2,2,2,2</a> 回到 [2,2,2]，要return回去，而return後的位置在迴圈內，此時如同”先備知識 - 寫法”所述，迴圈會負責將算法往前推進一格，即[2,2,2,3]</p>
<p> 注意：迴圈的起始點需要隨著算法的推進而往前，e.g.(續上例) 在[2,2,2,2]return回[2,2,2]後，此時迴圈的起始點會往前移動到3的位置(即 i 從 0<del>3 到 1</del>3)，如此才能達到繼續”加自己”的效果，i.e. curr_arr之後只可能會長成[2,2,2,3,3,3…..]，而非[2,2,2,3,2,2,2…]</p>
</li>
<li><p>target: 當summation &#x3D;&#x3D; target時，表示candidate符合條件，將curr_arr加進ans_arr中，再return(不用沿著這條路繼續找下去，因為，e.g. [2,2,3]之後[2,2,3,3]不可能是答案)</p>
</li>
</ol>
<h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image">Rotate Image</a></h1><h3 id="Method1：Rotate-Groups-of-Four-Cells"><a href="#Method1：Rotate-Groups-of-Four-Cells" class="headerlink" title="Method1：Rotate Groups of Four Cells"></a>Method1：<strong><strong>Rotate Groups of Four Cells</strong></strong></h3><p>時間：O(n^2)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<p>假設矩陣的邊長為n</p>
<ol>
<li>觀察規律可發現，For each cell(i, j)，將它旋轉90度後會變成cell( j, n-1-i )，且循著此規律一直search其位置最終會回到原點，每四次一個循環</li>
<li>而得知(1)的特性後再觀察一下可發現，從第一列開始，若對於每一列的index 0~n-2都做一次”四次循環的modify”，即可將該列所處的四個邊順利完成旋轉，如此利用兩個變數start_col、end_col當作界線，每完成一次”四個邊的旋轉”(i.e. 從最外圍開始往內)，就將此界線往內各縮一格，並將row往下移動一格，直到兩條界線碰觸到或是交錯(Note: 兩條界線最後若交疊代表陣列邊長為奇數，若交錯代表為偶數)，即代表矩陣所有的cells都已被我們旋轉完成</li>
</ol>
<h3 id="Method2：transpose-and-swap-the-matrix-best-solution"><a href="#Method2：transpose-and-swap-the-matrix-best-solution" class="headerlink" title="Method2：transpose and swap the matrix(best solution)"></a>Method2：transpose and swap the matrix(best solution)</h3><p>時間：O(n^2)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<p>利用矩陣的特性，透過transpose(swap列和欄) 和 swap rows, columns(上下或是左右顛倒)這兩個操作來完成rotation</p>
<ol>
<li>若資料結構為一個方陣，python中的swap()可以直接用assign的方式寫在同一行，e.g. swap(matrix[i][j], matrix[j][i]): matrix[i][j], matrix[ j ][i]&#x3D; matrix[j][i], matrix[i][ j ]</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/solutions/1449737/rotation-90-code-180-270-360-explanation-inplace-o-1-space/">旋轉180度, 270度</a>: <ol>
<li>180度：上下左右顛倒，即swap rows then swap columns 或是 swap columns then swap rows</li>
<li>270度：transpose(swap列和欄) then swap rows</li>
</ol>
</li>
</ol>
<h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></strong></h1><h3 id="Method1：Kadane’s-Algorithm"><a href="#Method1：Kadane’s-Algorithm" class="headerlink" title="Method1：Kadane’s Algorithm"></a><a target="_blank" rel="noopener" href="https://www.interviewbit.com/blog/maximum-subarray-sum/">Method1：<strong>Kadane’s Algorithm</strong></a></h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用兩個變數curr_sum、maximum分別去紀錄當前的加總以及最大加總，且一開始將curr_sum和maximum初始化為nums[0](畢竟returned answer至少須為陣列中的某個數)：<ol>
<li>maximum &#x3D; max(maximum, curr_sum)</li>
<li>if curr_sum &lt; 0 : curr_sum &#x3D; 0</li>
</ol>
</li>
<li>此算法的核心概念為1-b：當curr_sum為負時，我們要將其歸零，這是因為當curr_sum為負時，表示”current position以前”的那坨數對於”current position以後”的數(不管之後的數為何)都是”拖油瓶”，它們只會讓以後的加總”更小”，而既然到”目前為止”的最大加總都已經被maximum紀錄起來了，我們就可以放心的放棄之前看過的累積值(curr_sum)並將其歸零重新開始計算</li>
<li>Ex: [3, -5, 2, 2] :</li>
</ol>
<table>
<thead>
<tr>
<th>i</th>
<th>curr_sum</th>
<th>maximum</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>-2 → 0</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<h1 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/description/">Spiral Matrix</a></h1><h3 id="Method1：use-four-pointers-and-just-do-spiral-traverse-best-solution"><a href="#Method1：use-four-pointers-and-just-do-spiral-traverse-best-solution" class="headerlink" title="Method1：use four pointers and just do spiral traverse(best solution)"></a>Method1：use four pointers and just do spiral traverse(best solution)</h3><p>時間：O(m*n), means that we traverse all elements in the matrix</p>
<p>空間：O(m*n), means that we traverse all elements in the matrix</p>
<p>觀念：</p>
<ol>
<li>利用四個pointers分別指向start_row, end_row, start_col, end_col </li>
<li>對matrix作spiral traverse：即start_row → end_col → end_row → start_col，而每traverse完一邊，指向該邊的pointer就往內縮一格，直到start_row &gt; end_row 或是 start_col &gt; end_col(Note: while condition也可以寫成：while len(ans) ≠ m*n)</li>
<li>Tricky part : if condition只需要擺在traverse left, traverse up那邊，因為(1)traverse right: while condition檢查了 (2)traverse down: for loop condition檢查了</li>
</ol>
<h3 id="Method2：pop-and-rotate-worse-time-complexity-but-more-beautiful"><a href="#Method2：pop-and-rotate-worse-time-complexity-but-more-beautiful" class="headerlink" title="Method2：pop and rotate(worse time  complexity but more beautiful)"></a>Method2：pop and rotate(worse time  complexity but more beautiful)</h3><p>先備知識：some functions in Python</p>
<ol>
<li><p>pop(): retrieval本身的時間複雜度為O(1), 但取完值後shift element會花O(n)，e.g. lst.pop(0) &#x3D; O(n), lst.pop() &#x3D; O(1)</p>
</li>
<li><p>zip(<multiple lists>): pack elements by columns for each row as tuple, return an zip object，time complexity為m*n(m for the number of iterables, n for length of each list, i.e. all elements in multiple lists)</p>
</li>
<li><p>star sigh(*<em>iterables</em>): unpack <em>iterables</em> and passed as parameters to function，e.g. matrix &#x3D; </p>
<p> [ […], […], … , […] ] → zip(*matrix)</p>
</li>
</ol>
<p>時間：O(m*n), but the total time is definitely larger than the above</p>
<p>空間：O(m*n)</p>
<p>觀念：</p>
<ol>
<li>pop matrix的first row</li>
<li>將剩下的elements往左rotate 90度(i.e. transpose and reverse by rows) </li>
<li>重複以上兩個步驟直到matrix為empty</li>
</ol>
<h1 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-interval/description/">57. Insert Interval</a></strong></h1><h3 id="Method1：brute-force"><a href="#Method1：brute-force" class="headerlink" title="Method1：brute force"></a>Method1：brute force</h3><p>時間：O(n^2), given n is the number of intervals and pop() costs O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li><p>新增兩個函式(1)func overlap: 判斷任兩個inverval是否為overlap (2)func merge: 當兩個interval發生overlap時將他們合併成一個interval</p>
</li>
<li><p>為了不改變原本的陣列結構，所以將newInterval直接插在陣列最後面，由後往前檢查： </p>
<ol>
<li>是否發生overlap：若True，則將current interval更新為merged interval，再將前一個interval pop掉（Note: pop完一般會產生是否改變index正確性的疑慮，然而仔細思考一下就知道此題不會有這個問題，因為這邊的做法是merge完的interval要繼續跟它的前一個interval做檢查，所以正常將index -&#x3D; 1後current position還是會回到自己身上） </li>
<li>start(i)的是否為ascending order：若(a)不成立，而current start point &lt; prev start point，則swap兩個interval</li>
</ol>
<p> Note: 需要優先判斷(a)，因為如果有overlap則不管順序怎樣都要merge
 </p>
</li>
<li><p>依照(2)遍歷完整個陣列即可確保得到一個ascending, non-overlapping interval</p>
</li>
</ol>
<p>補充(續觀念(2))：</p>
<p>在陣列作pop操作後常常會遇到index跑掉的問題，做個整理：</p>
<ol>
<li>pop完的變動為 → ”poped position之後”的index全部-1</li>
<li>以lst &#x3D; [0, 1, 2, 3]為例，after lst.pop(1)，lst &#x3D; [0, 2, 3]，2, 3的pos分別會被更新為1, 2  </li>
<li>所以視情況而定，看pop之後希望curr position落在哪就可清楚地維持正確性</li>
</ol>
<h3 id="Method2-use-extra-space-to-store-the-answer-best-solution"><a href="#Method2-use-extra-space-to-store-the-answer-best-solution" class="headerlink" title="Method2: use extra space to store the answer(best solution)"></a>Method2: use extra space to store the answer(best solution)</h3><p>時間：O(n), given n is the number of intervals</p>
<p>空間：O(n)</p>
<p>觀念：</p>
<ol>
<li><p>將intervals和newInterval的關係分成三種cases :</p>
<ol>
<li>沒有overlap且interval在newInterval前面：直接把interval append到answered list。</li>
<li>有overlap：將newInterval更新為merged interval，這邊的迴圈結束後表示所有有overlap的interval都被處理完了，所以append merged interval到answered list。</li>
<li>沒有overlap且interval在newInterval後面：直接把interval append到answered list。</li>
</ol>
<p> → 利用一個idx”接力似地”並且按照a、b、c的順序去traverse intervals，即可得到一個non-overlapping and ascending-ordered intervals。</p>
</li>
</ol>
<p>Note : 此題有說明不能使用extra space，所以事實上這是一個illegal solution，但若無此限制確實為一個best solution。</p>
<h1 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-matrix-zeroes/description/">Set Matrix Zeroes</a></h1><h3 id="Method1：first-row-and-column-as-signals-best-solution"><a href="#Method1：first-row-and-column-as-signals-best-solution" class="headerlink" title="Method1：first row and column as signals(best solution)"></a>Method1：first row and column as signals(best solution)</h3><p>時間：O(M*N), given M, N are the number of rows and columns, respectively</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用第一列和第一欄當作label：若cell(i, j)為0，則label matrix[ 0 ][ j ]和matrix[ i ][ 0 ]為0，label完後再次traverse matrix的時候只要任一element所對應的matrix[ 0 ][ j ] 或 matrix[ i ][ 0 ]為0，就將該element assign為0</li>
<li>注意：由於第一列和第一欄要拿來當作signals，所以”第一列和第一欄是否要填0”必須分開看：在label前先行判斷第一列和第一欄是否有0(用bool表示)，判斷完之後即可traverse matrix，而也因為前述，所以matrix的traversal要保留第一列和第一欄(i.e. 從[1, 1]開始)</li>
<li>等到該填0的cell都填完，表示我們不再需要signals，最後就可以處理第一列和第一欄，將列和欄該填滿0的填上去</li>
</ol>
<h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/description/">Subsets</a></h1><h3 id="Method1：-dfs-backtracking-best-solution"><a href="#Method1：-dfs-backtracking-best-solution" class="headerlink" title="Method1： dfs(backtracking)(best solution)"></a>Method1： dfs(backtracking)(best solution)</h3><p>時間：O(n * 2^n)</p>
<p>空間：O(n)</p>
<p>觀念： </p>
<p>e.g. nums &#x3D; [1,2,3]</p>
<ol>
<li>題目所求為”找到所有可能的subsets” → 想到要用backtracking，而此題相較於一般backtracking較單純，在於其沒有特定的constraints和target(e.g. 像是”combination sum”、”palindrome partitioning”那樣)，而是一直把可能的組合append到ans內 </li>
<li>for loop：和一般backtracking一樣，擔任「每次return後將位置往前推進一格」的角色</li>
<li>recursion：將”curr_ans”寫在參數內而非寫在其他行，目的是為了希望return後直接回復到”前一個狀態”，如此每次return後就不用對curr_ans另外進行處理</li>
<li>此題curr_ans的變化為：1 → 12 → 123 → 13 → 2 → 23 → 3</li>
</ol>
<h1 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-search/description/">Word Search</a></h1><h3 id="Method1：dfs-best-solution"><a href="#Method1：dfs-best-solution" class="headerlink" title="Method1：dfs(best solution)"></a>Method1：dfs(best solution)</h3><p>時間：O(n<em>m</em>4^len(word))</p>
<p>空間：O(n*m)</p>
<p>觀念：</p>
<ol>
<li>DFS：對於任一個”有效的”且”尚未被visit過”的cell(i, j)，判斷其是否等於word的current char，若不相等則return，否則就朝”上下左右”四個方向分別去search下一個char，直到所有的char被找到，For each cell(i, j)：<ol>
<li>若row or column超出方格的範圍：return False </li>
<li>若cell(i, j) ≠ curr_char 或 cell(i, j) is visited ： return False </li>
<li>若(a), (b)為False，表示此cell(i, j)為effective且與char匹配，此時若char已經是word的最後一個，表示成功找到word，則將True一路傳回主函式，反之則繼續朝上述四個方向分頭繼續搜尋</li>
<li>為了避免搜尋的過程中cell被重複visit，直接利用題目所給的方格紀錄看過的cell，i.e. 可暫時assign visited cell隨便一個char(e.g. “@”)</li>
</ol>
</li>
<li>Main function：對於方格中的每一個cell，若其與word[0]匹配，則進入search階段(func DFS)，直到double for loops結束都沒有成功找到word，代表word不存在，return False</li>
</ol>
<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. <strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">Construct Binary Tree from Preorder and Inorder Traversal</a></strong></h1><h3 id="Method1：recursion-best-solution"><a href="#Method1：recursion-best-solution" class="headerlink" title="Method1：recursion(best solution)"></a>Method1：recursion(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<ul>
<li>hashmap: O(n)</li>
<li>Tree: O(n)</li>
<li>recursive system stack: O(n) in worst case, O(logn) in average case</li>
</ul>
<p>觀念：</p>
<ol>
<li><p>preorder traversal的特性可以讓我們輕鬆找到root，所以我們透過preorder array得知root的value為何，我們就可以去inorder array找root所在的位置，而這裡為了達到O(1)查找，需要事先建立一個inorder array的hashmap，接著，我們可以知道在inorder array中，root左邊的elements為left subtree、root右邊的elements為right subtree。</p>
</li>
<li><p>整理(1)的步驟：</p>
<ol>
<li><p>每一個新的遞迴開始(新的subtree)，先去preorder array找current subtree的root並將其生成為TreeNode。</p>
</li>
<li><p>透過事先建立的hashmap索引到inorder array中root的位置。</p>
</li>
<li><p>將左區間、右區間分別assign為root.left、root.right。</p>
<p> → 利用left, right兩個變數切出left subtree, right subtree的區間，並遞迴下去重複(a)~(c)，直到left &gt; right(區間耗盡)。</p>
</li>
</ol>
</li>
<li><p>小細節：遞迴的過程中，會有一個index variable跟著preorder array往前跑(因為每生成一個新的subtree都意味著要找一個新的root)，但因為遞迴的特性return後會讓這個index variable一層一層回復到原本的值，而稍微思考一下就知道不能讓這種事情發生(index variable在preorder array中必須一直往前跑)，所以設計遞迴的return時也要一併將這個variable一起傳回去。</p>
</li>
</ol>
<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/">Populating Next Right Pointers in Each Node</a></h1><h3 id="Method1：dfs-best-solution-1"><a href="#Method1：dfs-best-solution-1" class="headerlink" title="Method1：dfs(best solution)"></a>Method1：dfs(best solution)</h3><p>時間：O(n), given that we traverse all the nodes in the tree</p>
<p>空間：O(1), given that the system stack is not counted as extra space according to the problem.</p>
<p>觀念：</p>
<p>看完題目後，對於「串連同一個subtree的children nodes」應該還蠻直覺可以想到的，就root.left.next &#x3D; root.right就好，比較可能有問題的地方為「串連兩個subtree的children nodes」，所以有了以下想法。</p>
<ol>
<li><p>在使用DFS traverse tree時最大的特點就是演算法會沿著leftmost的方向往下探到底，然而若要應用於此題最大的問題就是「DFS沒有橫向移動的能力」，也就是上述提到的問題。</p>
</li>
<li><p>然而此題的”next pointer”正好賦予了我們「橫向移動的能力」，仔細思考一下就會發現next pointer做的事就是「在兩個子樹的roots之間架一座橋樑」，所以每一個recursion要做的事就是：</p>
<ol>
<li>若root存在children，將children串連起來。</li>
<li>基於(a)(i.e. 有children)，再檢查root是否有next pointer，若有(i.e. root不是last node by level order)就將root.right與root.next.left接起來。</li>
</ol>
<p> 其他就如正常的DFS一般，最後都接完後回傳root即可。</p>
</li>
</ol>
<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Longest Consecutive Sequence</a></h1><p>先備知識：</p>
<ol>
<li>subarray v.s sequence：subarray必須是contiguous，而sequence不用，e.g. For [1,2,3,4]: [1,2,3] is a subarray，[1,2,4] is a subsequence</li>
<li>此題所指的consecutive sequence指的其實就是subarray，差別在於此題要從一個unsorted array找出答案，e.g. For [100, 4, 2, 3, 3, 200]: ans  &#x3D; 3 ([2, 3, 4])</li>
</ol>
<h3 id="Method1：sort-it"><a href="#Method1：sort-it" class="headerlink" title="Method1：sort it"></a>Method1：sort it</h3><p>時間：O(nlogn)</p>
<p>空間：O(1)</p>
<p>觀念：利用三個變數max_len、curr_len、prev_num去找出max_len</p>
<ol>
<li>prev_num初始化為nums[0]，for loop從nums[1]開始，而由於已經sorted：<ol>
<li>若curr_num - prev_num &gt; 1：表示斷掉，新的sequence重新開始，curr_len設為1</li>
<li>若curr_num - prev_num &#x3D;&#x3D; 1：curr_len +&#x3D; 1  </li>
<li>若curr_num - prev_num &#x3D;&#x3D; 0：代表兩個數為duplicates，注意，由先備知識(2)的例子可知此時長度是不會增加的(此題不考慮duplicates)</li>
</ol>
</li>
<li>為了maintain max_len，每一個iteration都要更新max_len &#x3D; max(max_len, curr_len) </li>
<li>每一個iteration都要在下一個iteration開始前更新prev_num為curr_num</li>
</ol>
<h3 id="Method2：hashset-best-solution"><a href="#Method2：hashset-best-solution" class="headerlink" title="Method2：hashset(best solution)"></a>Method2：hashset(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<p>觀念：可以想像陣列存在多個consecutive sequence，對於每一個”starting point”，利用hashset尋找其下一個number直到斷掉為止，如此去maintain max_len</p>
<ol>
<li>先將所有numbers存入set()，以便後續做到O(1)查找</li>
<li>starting point：對於陣列中的任一number，若number - 1不存在於set，則代表其為某個sequence的”starting point”，此時開始去set找它的consecutive number直到找不到，以此去計算該sequence的長度</li>
<li>not starting point：若(2)為False，表示curr_num不是”starting point”，而是存在於某個sequence之間的numbers之一，此時不需要計算長度所以不用做任何事</li>
</ol>
<h1 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions</a></strong></h1><h3 id="Method1：dfs-best-solution-2"><a href="#Method1：dfs-best-solution-2" class="headerlink" title="Method1：dfs(best solution)"></a>Method1：dfs(best solution)</h3><p>時間：</p>
<p>O(m<em>n), given that m, n are the number of rows and columns, respectively.(Note:the func dfs() has to traverse all cells in the matrix in the worst case, which costs O(m</em>n), but in return, it only costs O(1)’s for other starting point. So, it costs O(m*n) in total)。</p>
<p>空間：</p>
<p>O(m<em>n), given that func dfs() has to traverse all cells in the matrix in the worst case, and  the recursive stack would store m</em>n elements in that case。</p>
<p>觀念：</p>
<ol>
<li>根據題目，”flip”的條件為”<em>4-directionally surrounded by ‘X‘</em> ”，言下之意就是「位在四個邊」的’O’都不能flip，而且與之相鄰的一系列’O’也連帶的不能flip(因為若某個’O’是某個不能被翻的’O’的鄰居，則它一定不是”<em>4-directionally surrounded by ‘X‘ “</em>)。</li>
<li>搞清楚(1)的條件之後解法就很明確了，檢查matrix的四條邊，若遇到’O’就以它為出發點，遍歷所有與之相鄰的一系列cells：<ol>
<li><p>若cell為’O’：代表不能flip，將其用某個特殊符號label起來(e.g. “#”)。</p>
<p> Note: 由於我們是以四條邊的’O’作為dfs的起始點，所以凡是我們遇到(沒有被return)的cell，他一定是某個「不能被翻」的鄰居，所以這邊直接label即可，不用另加條件判斷。</p>
</li>
<li><p>若cell為invalid position(超出matrix長度) 或 本身為’X’ 或 visited(簡單來說: cell ≠ ‘O’)：回溯到原本的位置，看其他方向有沒有路可走。</p>
</li>
</ol>
</li>
<li>完成(2)的操作後，我們會得到一個labeled matrix，可能包含三種char：<ol>
<li>“O”：應該要被flip → 把它改成”X”</li>
<li>“X”：不用管它</li>
<li>“#”：原本是”O”但不用被flip → 還原成”O”</li>
</ol>
</li>
</ol>
<h1 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/description/">131. Palindrome Partitioning</a></strong></h1><p>reference: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/solutions/182307/java-backtracking-template-general-approach/">https://leetcode.com/problems/palindrome-partitioning/solutions/182307/java-backtracking-template-general-approach/</a></p>
<h3 id="Method1：DFS-DP-best-solution"><a href="#Method1：DFS-DP-best-solution" class="headerlink" title="Method1：DFS + DP(best solution)"></a>Method1：DFS + DP(best solution)</h3><p>時間：O(n^2 + 2^n)</p>
<ul>
<li>construct the dp table → O(n^2)</li>
<li>the backtracking algorithm → for each substring in string, either it would be the “one of the partition in the current answer(i.e. add this substring to the “curr” and  call a new recursive function)”, or it would be the “prefix of other substring(i.e. backtracking happens, and the for loop iterate forward, and call the recursive function)”. In other word, each substring will call the function itself for two times in the worst case. So, the function dfs() costs O(2^n).</li>
</ul>
<p>空間：O(n^2), which is the cost of dp table.</p>
<p>觀念：</p>
<ol>
<li><p>演算法的想法主要為：</p>
<p> 判斷current substring是否為palindromic</p>
<ol>
<li>True: 將當前substring加入答案中，對remaining substring遞迴進行判斷(將start position移動到「end position的下一格」)。</li>
<li>False: 擴展end position，繼續判斷直到for loop結束或是找到回文(回到part(a))。</li>
</ol>
</li>
<li><p>延續以上想法，此題主要可以分成兩件事：(a)palindrome check (b)partition substring using backtracking</p>
<ol>
<li>試想，如果把palindrome check寫在backtracking內，那勢必會重複計算到substring很多次，很浪費時間複雜度，為了避免一直重複計算，此時就是DP進場的時候，所以我們預先建立一張二維表(boolean)將所有的palindrome substring紀錄起來(row: substring starting index, column: substring ending index. e.g. For “aba”: DP[0][2] &#x3D; True)</li>
<li>利用template說明：<ol>
<li>how to choose &amp; explore: 找到所有可能的palindrome substring組合，而若「當前substring並非palindromic」，或是「backtracking回來之後」，此時”end position”將往前擴展(利用for loop實現)。</li>
<li>constraints: current substring必須為palindromic → 用事先建好的DP O(1)判斷。</li>
<li>target: 當starting index超出string的長度，代表”current ans”目前已經成功儲存了答案之一 → 將其保存起來return回去。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/gas-station/">Gas Station</a></h1><h3 id="Method1：two-pointers-best-solution"><a href="#Method1：two-pointers-best-solution" class="headerlink" title="Method1：two pointers(best solution)"></a>Method1：two pointers(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li><p>將gas, cost兩個陣列想像成一個陣列( arr[i] &#x3D; gas[i] - cost[i] )，arr[i]表示從 i 開到 i + 1所剩下的油量，將arr的每個element加總，由於不論從哪個起始點開始，車子繞一圈相當於就是在將陣列中的「所有elements」做加總，只是順序不同罷了(起始點不同)，所以：</p>
<ol>
<li>若≥0: 表示一定存在有效的起始點  </li>
<li>反之: 不存在有效起始點</li>
</ol>
</li>
<li><p>此題最關鍵的概念：若從某起始點”s”只能開到另一點”e”(油不夠開到e+1)，則[s, e]這段區間都不會有有效的起始點，所以此時應該要跨過這個區間直接從”e+1”繼續。</p>
<p> 反證法：假設[s, e]存在有效的起始點</p>
<p> (1)let’s say start from “s+1”，For sum(s+1, s+2, …, e) &gt; 0 (?)，已知起始點(s)必為正，所以<br> sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+1, s+2, …, e) &lt; 0</p>
<p> (2)let’s say start from “s+2”，For sum(s+2, s+3, …, e) &gt; 0 (?)，已知sum(s, s+1)必為正(否則車子開不到s+2)，因此sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+2, s+3, …, e) &lt; 0</p>
<p> → 以此類推即可得證。</p>
</li>
<li><p>實際操作：</p>
<ol>
<li>用變數curr_surplus對”當前幾個”elements進行加總，在陣列中的任一位置，若curr_surplus&lt;0表示車只能開到該位置，此時根據觀念(2)，我們將curr_surplus歸零，並把起始點往前拉到該位置的下一個位置，繼續演算法。</li>
<li>用變數total_surplus對陣列中的每個elements進行加總，迴圈結束後若total_surplus&lt;0表示不存在有效起始點，反之則一定存在有效起始點(此時return該起始點)。</li>
<li>若看code會發現一個容易產生疑慮的地方：”start &#x3D; i + 1”這行，不禁讓人思考若i此時為last element則start不是就超出陣列長度了嗎？<br> Ans: 若i為last element且被+1，表示車子開到last position(i)勢必會沒油，而不管從哪個起始點開始繞一圈車子一定會經過last position，所以可得陣列一定不存在有效起始點(i.e. total_surplus勢必&lt;0，演算法會return -1)。</li>
</ol>
</li>
</ol>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></strong></h1><h1 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/description/">LRU Cache</a></h1><h3 id="Method1：hashmap-and-doubly-linked-list-best-solution"><a href="#Method1：hashmap-and-doubly-linked-list-best-solution" class="headerlink" title="Method1：hashmap and doubly linked list(best solution)"></a>Method1：hashmap and doubly linked list(best solution)</h3><p>時間：O(1) for each function in class</p>
<p>空間：O(n), which is the number of “capacity”</p>
<p>觀念：</p>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/description/">Maximum Product Subarray</a></h1><h3 id="Method1：Two-pointers-maintain-max-and-min-best-solution"><a href="#Method1：Two-pointers-maintain-max-and-min-best-solution" class="headerlink" title="Method1：Two pointers(maintain max and min)(best solution)"></a>Method1：Two pointers(maintain max and min)(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用兩個變數”curr_max”, ”curr_min”去maintain在陣列中到任一位置 i 的最大最小值，值得思考的是題目所求為「最大乘積」，那為何會需要maintain一個最小值？因為在陣列中我們有可能會遇到「負值」，此時若什麼都不做就乘下去會使得「大的變成小的、小的變成大的」，所以我們需要一個「最小值幫手」，讓我們在遇到負值時依然可以維護正確的極值。</li>
<li>續(1)，當我們遇到負值時，就將”curr_max”, ”curr_min”互換，如此各自乘以該負值得到的乘積才會是正確的，另外，要知道對於陣列中的任一數，有時候「不乘而只取其本身」反而更貼近我們想要的結果(e.g. 考慮求nums &#x3D; [-8, 8]的max product → ans &#x3D; 8)，所以我們每次都要拿極值與”其本身”作比較(i.e. 我們有「乘」與「不乘」兩種選擇) → $Let ; i ;be ; [1, ;len(nums))$<ol>
<li>$currMax &#x3D; max(nums[i],;nums[i]*currMax)$</li>
<li>$currMin &#x3D; min(nums[i],;nums[i]* currMin)$</li>
<li>$ans &#x3D; max(ans,; currMax)$</li>
</ol>
</li>
<li>最後return ans即為所求。</li>
</ol>
<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/">Min Stack</a></h1><h3 id="Method1：Use-tuple-to-keep-track-of-the-minimum"><a href="#Method1：Use-tuple-to-keep-track-of-the-minimum" class="headerlink" title="Method1：Use tuple to keep track of the minimum"></a>Method1：Use tuple to keep track of the minimum</h3><p>時間：O(1) for each function called</p>
<p>空間：O(n), the cost of stack</p>
<p>觀念：</p>
<ol>
<li>關鍵在於implement “push”時：利用tuple(<em>val, minimum</em>)來儲存要插入的值，以及目前為止的最小值，即在每次插入值之前，比較「欲插入的值」與「stack最上方的minimum」(如果stack不為空)，將較小的值塞到tuple內一併與<em>val</em> append到stack內，如此一來每個tuple就成功紀錄到目前為止的最小值，而整個stack的最小值就永遠等於self.stack[-1][1]。</li>
</ol>
<h1 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a>189. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/description/">Rotate Array</a></h1><p>此題要做的事講白一點就是「把last element丟到最前面」，重複k次，而關鍵在於如何in place做到這件事。</p>
<h3 id="Method1：shift-the-n-k-elements"><a href="#Method1：shift-the-n-k-elements" class="headerlink" title="Method1：shift the n-k elements"></a>Method1：shift the n-k elements</h3><p>時間：max(O(n-k), O(k)) &#x3D; O(n)</p>
<p>空間：O(k) &#x3D; O(n)</p>
<p>觀念：將last k elements用extra space存起來 → 將first n-k elements往後平移k格 → 將last k elements貼到最前面。</p>
<h3 id="Method2：reverse-the-array-best-solution"><a href="#Method2：reverse-the-array-best-solution" class="headerlink" title="Method2：reverse the array(best solution)"></a>Method2：reverse the array(best solution)</h3><p>時間：O(2n) &#x3D; O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<p>swap和shift的差別在於：swap完的順序會呈顛倒狀態，而shift不會，但在實作上我們較難在不改變陣列長度(i.e. in place) 或是 利用額外空間紀錄一些值的情況下做到shift，然而swap倒是可以很容易利用two pointers完成。</p>
<ol>
<li>reverse整個陣列，其實就是SWAP last k elements和first n-k elements，為的就是讓「last k elements和first n-k elements的位置互換」，結束後因為順序呈顛倒狀態，要將他們再倒回來。</li>
<li>reverse first k elements。</li>
<li>reverse the rest n-k elements。</li>
</ol>
<p>code :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: shift the n-k elements</span></span><br><span class="line"><span class="string">    time: max(O(n-k), O(k)) = O(n)</span></span><br><span class="line"><span class="string">    sapce: O(k) = O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        rotate = nums[n-k:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,k-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            nums[i] = nums[i-k]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            nums[i] = rotate[i]</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    method: reverse the array</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    sapce: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums, start, end</span>):</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                nums[start], nums[end]= nums[end], nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        nums = reverse(nums, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        nums = reverse(nums, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">        nums = reverse(nums, k, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a></h1><h3 id="Method1：dfs-best-solution-3"><a href="#Method1：dfs-best-solution-3" class="headerlink" title="Method1：dfs(best solution)"></a>Method1：dfs(best solution)</h3><p>時間：</p>
<p>O(m<em>n), given that m, n are the number of rows and columns, respectively.(Note:the func dfs() has to traverse all cells in the matrix in the worst case, which costs O(m</em>n), but in return, it only costs O(1)’s for other starting point. So, it costs O(m*n) in total)。</p>
<p>空間：</p>
<p>O(m<em>n), given that func dfs() has to traverse all cells in the matrix in the worst case, and  the recursive stack would store m</em>n elements in that case。</p>
<p>觀念：</p>
<ol>
<li><p>此題的”surrounded”和leetcode-130(surrounded region)很像，差別在於此題題敘「You may assume all four edges of the grid are all surrounded by water.」，意思是matrix的周圍都被我們看不到的”0”(water)包圍，這句話很關鍵，其意味著matrix所有的”1”(if exist)最終都一定會被”0”所包圍。</p>
</li>
<li><p>遍歷整個matrix：</p>
<p> 若cell為”1” : dfs開始</p>
<ol>
<li>若cell為”1”：根據題目，”一座島”是由所有相鄰的”1”所組合起來，所以從起始點開始遇到的所有”1”我們都將它label起來(e.g. “#”)，表示已經訪問過，如此利用dfs即可將所有屬於「同一座島」的區塊標記起來，該次dfs結束後，代表我們「標完了一座島」，於是我們利用一個變數(e.g. count)加一。</li>
<li>若cell為invalid position 或 ”0” 或 visit過(即 cell ≠ “1”)：回溯到原本位置，嘗試其他方向。</li>
</ol>
</li>
<li><p>完成(2)的操作後，此時我們的count理論上已經成功將島的數量計算完，return即為所求。</p>
</li>
</ol>
<h1 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a>210. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a></h1><p>ref: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/">https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/</a></p>
<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/">Kth Smallest Element in a BST</a></h1><p>先備知識：binary search tree</p>
<ol>
<li>binary tree</li>
<li>value由小到大滿足左→中→右的順序</li>
</ol>
<h3 id="Method1：Recursive-Inorder-Traversal"><a href="#Method1：Recursive-Inorder-Traversal" class="headerlink" title="Method1：Recursive Inorder Traversal"></a>Method1：<strong><strong>Recursive Inorder Traversal</strong></strong></h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<p>觀念：</p>
<ol>
<li>題目所求為第k小的值，而對一個binary search tree作inorder traversal可以得到一個ascending order array，return arr[k-1]即可滿足所求</li>
</ol>
<h1 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a>238. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">Product of Array Except Self</a></h1><p>既然題目是計算「除了本身之外的乘積」，那就想辦法湊出「從前面乘過來」(prefix)以及「從後面乘過來」(suffix)。</p>
<h3 id="Method1：prefix-amp-suffix-two-pass"><a href="#Method1：prefix-amp-suffix-two-pass" class="headerlink" title="Method1：prefix &amp; suffix (two-pass)"></a>Method1：prefix &amp; suffix (two-pass)</h3><p>時間：O(2n) &#x3D; O(n)</p>
<p>空間：O(1), note that the array used to store the answer is not counted as extra space in this problem.</p>
<p>觀念：</p>
<ol>
<li>利用一個陣列prefix儲存prefix product的計算結果，陣列中每個位置pos為「pos之前」的乘積(不包含pos本身)，Note: nums[0]之前沒有東西，所以prefix[0]初始化為1。</li>
<li>得到prefix陣列後，我們預期要將陳列中的每個值乘以suffix以得到答案，所以這次我們由後往前遍歷，並利用一個變數suffix(Note: nums[-1]之後沒有東西，所以suffix初始化為1)代表nums中每個位置其所對應的後綴乘積。</li>
<li>如此由後往前將prefix[i] * suffix即可得到in place的答案。</li>
</ol>
<h3 id="Method2：prefix-amp-suffix-one-pass-best-solution"><a href="#Method2：prefix-amp-suffix-one-pass-best-solution" class="headerlink" title="Method2：prefix &amp; suffix (one-pass, best solution)"></a>Method2：prefix &amp; suffix (one-pass, best solution)</h3><p>時間：O(n)</p>
<p>空間：O(1), note that the array used to store the answer is not counted as extra space in this problem.</p>
<p>觀念：</p>
<ol>
<li>Method1需要兩個for loops：(1)建立prefix (2)乘以suffix並得出答案，然而其實不用先將每個prefix都儲存下來，若我們將prefix、suffix視為兩個pointer，一個「由前往後遍歷」、一個「由後往前遍歷」，沿途持續更新這兩個變數並將nums每個位置所對應的prefix和suffix product儲存起來，試想，當兩個pointer「開始發生交錯」時，理論上即可算出所求。</li>
</ol>
<p>Ex: nums &#x3D; [2,3,4,5]</p>
<table>
<thead>
<tr>
<th>iteration</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
</tr>
<tr>
<td>suffix</td>
<td>1</td>
<td>5</td>
<td>20</td>
<td>60</td>
</tr>
</tbody></table>
<p>For iteration: 0~4, ans:</p>
<table>
<thead>
<tr>
<th>iteration</th>
<th>pos 0</th>
<th>pos 1</th>
<th>pos 2</th>
<th>pos 3</th>
</tr>
</thead>
<tbody><tr>
<td>0(初始化)</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>40</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>60</td>
<td>40</td>
<td>30</td>
<td>24</td>
</tr>
</tbody></table>
<h1 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334. Increasing Triplet Subsequence"></a>334. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-triplet-subsequence/">Increasing Triplet Subsequence</a></h1><h3 id="Method1：two-pointers-best-solution-1"><a href="#Method1：two-pointers-best-solution-1" class="headerlink" title="Method1：two pointers (best solution)"></a>Method1：two pointers (best solution)</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>既然題目所求為三個數，那就Maintain兩個變數(say, “first” and “second”，為了讓變數順利吃到陣列中的數，都先初始化為一個「大於nums中所有elements」的數)分別代表「到目前為止最小和第二小的數」，而當出現比這兩個數都大的數時，代表increasing triplet形成 → return True，反之若遍歷完整個陣列都沒有找到就return False。</li>
<li>此題關鍵之處在於：<ol>
<li>當遇到 ≤ first的數時：更新first</li>
<li>當遇到 &gt; first &amp;&amp; ≤ second的數時：更新second</li>
</ol>
</li>
<li>探討(2)：<ol>
<li>其實(b)還蠻直觀的，考慮nums &#x3D; [1, 3, 2, …]：當遍歷到2時，first &#x3D; 1, second &#x3D; 3，此時我們會將second更新為2，想法上為無論2以後遇到哪個數，只要它 &gt; 3 → 他也一定會 &gt; 2，那用[1,3]還不如用[1,2]繼續往後找，而比較不直觀的在於(a)。</li>
<li>考慮nums &#x3D; [4, 5, 1, …]，通常遍歷到1時不禁會想，到底是要(1)保留[4, 5]然後期望在之後遇到6，還是(2)放棄[4, 5]然後由1重新開始，於是有了以下想法：看到1時就大膽地將4更新成1，變成[1, 5]，此時的5扮演分水嶺的角色，若之後遇到 &gt; 5的數，它可以告訴我們找到increasing triplet了(e.g. [4, 5, 6])，而若之後又遇到一個 &lt; 5 的數也是直接更新5(e.g. nums&#x3D;[4, 5, 1, 2]，當遍歷到2時，[1, 5] → [1, 2] )，因為用[4, 5]還不如用[1, 2]。</li>
</ol>
</li>
</ol>
<h1 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378. Kth Smallest Element in a Sorted Matrix"></a>378. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">Kth Smallest Element in a Sorted Matrix</a></h1><h3 id="min-heap-max-heap-："><a href="#min-heap-max-heap-：" class="headerlink" title="min heap(max heap)："></a>min heap(max heap)：</h3><ol>
<li>為一個complete binary tree，又被稱為priority queue(優先佇列) </li>
<li>對於任一node而言，其子節點必定 &gt; 其本身，i.e. 最小值永遠在root(max heap則相反)</li>
<li>常見的implement為array(or list)</li>
</ol>
<h3 id="min-heap-in-python："><a href="#min-heap-in-python：" class="headerlink" title="min heap in python："></a>min heap in python：</h3><p>min_heap &#x3D; [ ]</p>
<ol>
<li><p>常用的套件為heapq </p>
</li>
<li><p>heapq.heappush(min_heap, <em>item: tuple</em>): 將item插入heap內，並維持heap的特性，item可以是一個tuple，其中，heap內的優先順序會依照tuple的第一個parameter當作依據</p>
<p> → time complexity &#x3D; O(logn), n: the number of nodes in heap</p>
</li>
<li><p>heapq.heappop(min_heap): 將heap中最小的item pop出來，並維持heap的特性</p>
<p> → time complexity &#x3D; O(logn), n: the number of nodes in heap</p>
</li>
</ol>
<h3 id="Method1：min-heap-best-solution"><a href="#Method1：min-heap-best-solution" class="headerlink" title="Method1：min heap(best solution)"></a>Method1：min heap(best solution)</h3><p>時間：O(k * logn), where k is that k of “kth smallest”, and n is the number of rows(or columns)</p>
<p>空間：O(n)</p>
<p>觀念：</p>
<ol>
<li>將問題想成「在n個sorted lists內找出第k小的值」，通常在這種「有關取最小值或最大值的問題，且資料數量維持固定」時，要想到可以用heap，因為用heap給予我們取極值很大的便利性，i.e. 相較於在一個普通的list上使用min(), max()，heap可以做到O(1)取值、O(1)插入、O(logn)維護。</li>
<li>每個heap node儲存(value, row, column)：一開始就先將每列的first element push進heap，而之所以要儲存每個value的位置，是因為我們必須知道每次在當前最小值被取出之後，它的下一個value的位置為何，並將與該值同列的下一個值push進heap內，以維持演算法的正確性，重複以上動作直到我們找到第k小的值(i.e. 第k次pop)即為所求。</li>
</ol>
<h1 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395. Longest Substring with At Least K Repeating Characters"></a>395. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/">Longest Substring with At Least K Repeating Characters</a></h1><h3 id="Method1：sliding-window-best-solution"><a href="#Method1：sliding-window-best-solution" class="headerlink" title="Method1：sliding window(best solution)"></a>Method1：sliding window(best solution)</h3><p>時間：O(26*n) &#x3D; O(n), given that the number of alphabet is 26, and the n is the length of “s”</p>
<p>空間：O(n), which is the cost of hashmap used to count frequency of charactersproblem.</p>
<p>觀念：</p>
<p>這題看完題敘可以蠻直觀地想到要用sliding window，但困難的點在於，考慮case<code>s = aabbb...</code> and <code>k = 3</code>，當我們traverse到”aabbb”這個區間時(i.e. left&#x3D;0, right&#x3D;4)問題來了，究竟我們是要(1)繼續擴展pointer right然後期望我們會遇到下一個”a”，還是(2)放棄”aa”，將pointer left往前拉到first b的位置？答案是無法確定，所以有了以下的解法：</p>
<ol>
<li>既然我們已知s一定只包含lowercase English letters，那大不了就是在一開始先看s總共包含幾種characters，假設今天s有8種char，我們就從「僅有一個unique char的所有sliding windows」，一直測試到「包含8個unique char的所有sliding windows」，這樣一定可以找到題目所求的longest substring。</li>
<li>the outermost loop為「1 to ”the number of unique char in s”」，接著For每一個迭代，我們都初始化left &#x3D; 0、right &#x3D; 0 to len(s)，並利用一個hashmap(say, counter_curr)去統計current sliding window內每個char的數量：<ol>
<li>當current sliding window內「unique char的數量」&gt; 該次iteration所限制的數量：<br> 此時我們要”shrink sliding window”(i.e. 將pointer left往前拉)直到window內unique char的數量符合限制，而具體作法不只是讓left +&#x3D; 1，還要去counter_curr將left所指的char次數減一，且當次數歸零時，我們要將其從counter_curr pop掉(這樣hashmap長度才會減少)。</li>
<li>當current sliding window內「unique char的數量」≤ 該次iteration所限制的數量：<br> 代表此刻的sliding window是一個”valid”的window，我們就可以透過counter_curr去檢查這些char的數量是否都有≥K，如果有，我們就利用$max(maxLen,;r-l+1)$去保存最大長度，並且繼續擴展我們的window，直到某天window的unique char數量超出限制 或是 right超出s的長度。</li>
</ol>
</li>
</ol>
<h1 id="958-Check-Completeness-of-a-Binary-Tree"><a href="#958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="958. Check Completeness of a Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/">958. Check Completeness of a Binary Tree</a></strong></h1><h3 id="complete-binary-tree"><a href="#complete-binary-tree" class="headerlink" title="complete binary tree"></a>complete binary tree</h3><ol>
<li>last level：由左連續排到右，不能斷掉 </li>
<li>other than last level：full binary tree</li>
</ol>
<h3 id="Method1：dfs-label"><a href="#Method1：dfs-label" class="headerlink" title="Method1：dfs(label)"></a>Method1：dfs(label)</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<p>觀念：</p>
<ol>
<li>利用binary tree的特性：對於任一個node(n)，其left child必為2<em>n，right child必為2</em>n+1，透過此特性可得到任一個node的position，如此traverse整棵樹並搭配$max(maxPos, ;currPos)$每當遇到更大的label就更新max_pos並把結果傳回去，即可得到最大的node label</li>
<li>接續1.，在traverse的過程中一邊計算最大label，一邊去count整棵樹的node數量</li>
<li>最後會得到兩個變數：(1)maxPos , (2)num_nodes，若該棵樹為complete binary tree則它的max_label勢必等於它的總nodes數，反之就不是complete binary tree</li>
</ol>
<h3 id="Method2：bfs"><a href="#Method2：bfs" class="headerlink" title="Method2：bfs"></a>Method2：bfs</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<p>觀念：</p>
<ol>
<li>初始化一個idx，將所有nodes依照level order存進list裡，即對於任一node，依序存入它的left child、right child，直到遇到None就跳出迴圈</li>
<li>延續1.，若該棵樹為complete binary tree，則None的後面不應該有任何node，若有則不是complete binary tree，利用此特性，在1.跳出迴圈後我們會得到一個idx(None的位置)，接著只要檢查idx之後的位置是否存在node即可判斷是不是complete binary tree</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Medium/" rel="tag"># Medium</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/18/DataStructures-trie/" rel="prev" title="Data Structures - Trie">
      <i class="fa fa-chevron-left"></i> Data Structures - Trie
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/26/Algorithm-DepthFirstSearch/" rel="next" title="Algorithm - Depth First Search">
      Algorithm - Depth First Search <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Medium"><span class="nav-number">1.</span> <span class="nav-text">Medium</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Add-Two-Numbers"><span class="nav-number">2.</span> <span class="nav-text">2. Add Two Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1%EF%BC%9Ajust-add-them-best-solution"><span class="nav-number">2.1.</span> <span class="nav-text">Method1：just add them(best solution)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">3.</span> <span class="nav-text">3. Longest Substring Without Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1%EF%BC%9Atwo-pointers-sliding-window-best-solution"><span class="nav-number">3.1.</span> <span class="nav-text">Method1：two pointers - sliding window(best solution)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Longest-Palindromic-Substring"><span class="nav-number">4.</span> <span class="nav-text">5. Longest Palindromic Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1%EF%BC%9AExpand-from-every-center"><span class="nav-number">4.1.</span> <span class="nav-text">Method1：Expand from every center</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method2%EF%BC%9Adynamic-programming"><span class="nav-number">4.2.</span> <span class="nav-text">Method2：dynamic programming</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">5.</span> <span class="nav-text">11. Container With Most Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1%EF%BC%9ATwo-pointers-sliding-window-best-solution"><span class="nav-number">5.1.</span> <span class="nav-text">Method1：Two pointers - sliding window(best solution)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-3Sum"><span class="nav-number">6.</span> <span class="nav-text">15. 3Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Method1%EF%BC%9ATwo-pointers-and-set-best-solution"><span class="nav-number">6.1.</span> <span class="nav-text">Method1：Two pointers and set(best solution)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">7.</span> <span class="nav-text">19. Remove Nth Node From End of List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Acount"><span class="nav-number">7.0.1.</span> <span class="nav-text">Method1：count</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Generate-Parentheses"><span class="nav-number">8.</span> <span class="nav-text">22. Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Abacktracking"><span class="nav-number">8.0.1.</span> <span class="nav-text">Method1：backtracking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9ADP"><span class="nav-number">8.0.2.</span> <span class="nav-text">Method2：DP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="nav-number">9.</span> <span class="nav-text">33. Search in Rotated Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Avariation-of-binary-search"><span class="nav-number">9.0.1.</span> <span class="nav-text">Method1：variation of binary search</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-Combination-Sum"><span class="nav-number">10.</span> <span class="nav-text">39. Combination Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-backtracking"><span class="nav-number">10.0.1.</span> <span class="nav-text">Method1：dfs(backtracking)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-Rotate-Image"><span class="nav-number">11.</span> <span class="nav-text">48. Rotate Image</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9ARotate-Groups-of-Four-Cells"><span class="nav-number">11.0.1.</span> <span class="nav-text">Method1：Rotate Groups of Four Cells</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Atranspose-and-swap-the-matrix-best-solution"><span class="nav-number">11.0.2.</span> <span class="nav-text">Method2：transpose and swap the matrix(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">12.</span> <span class="nav-text">53. Maximum Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9AKadane%E2%80%99s-Algorithm"><span class="nav-number">12.0.1.</span> <span class="nav-text">Method1：Kadane’s Algorithm</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">13.</span> <span class="nav-text">54. Spiral Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Ause-four-pointers-and-just-do-spiral-traverse-best-solution"><span class="nav-number">13.0.1.</span> <span class="nav-text">Method1：use four pointers and just do spiral traverse(best solution)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Apop-and-rotate-worse-time-complexity-but-more-beautiful"><span class="nav-number">13.0.2.</span> <span class="nav-text">Method2：pop and rotate(worse time  complexity but more beautiful)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-Insert-Interval"><span class="nav-number">14.</span> <span class="nav-text">57. Insert Interval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Abrute-force"><span class="nav-number">14.0.1.</span> <span class="nav-text">Method1：brute force</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2-use-extra-space-to-store-the-answer-best-solution"><span class="nav-number">14.0.2.</span> <span class="nav-text">Method2: use extra space to store the answer(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#73-Set-Matrix-Zeroes"><span class="nav-number">15.</span> <span class="nav-text">73. Set Matrix Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Afirst-row-and-column-as-signals-best-solution"><span class="nav-number">15.0.1.</span> <span class="nav-text">Method1：first row and column as signals(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-Subsets"><span class="nav-number">16.</span> <span class="nav-text">78. Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9A-dfs-backtracking-best-solution"><span class="nav-number">16.0.1.</span> <span class="nav-text">Method1： dfs(backtracking)(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79-Word-Search"><span class="nav-number">17.</span> <span class="nav-text">79. Word Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-best-solution"><span class="nav-number">17.0.1.</span> <span class="nav-text">Method1：dfs(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-number">18.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Arecursion-best-solution"><span class="nav-number">18.0.1.</span> <span class="nav-text">Method1：recursion(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-number">19.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-best-solution-1"><span class="nav-number">19.0.1.</span> <span class="nav-text">Method1：dfs(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-number">20.</span> <span class="nav-text">128. Longest Consecutive Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Asort-it"><span class="nav-number">20.0.1.</span> <span class="nav-text">Method1：sort it</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Ahashset-best-solution"><span class="nav-number">20.0.2.</span> <span class="nav-text">Method2：hashset(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-number">21.</span> <span class="nav-text">130. Surrounded Regions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-best-solution-2"><span class="nav-number">21.0.1.</span> <span class="nav-text">Method1：dfs(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-number">22.</span> <span class="nav-text">131. Palindrome Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9ADFS-DP-best-solution"><span class="nav-number">22.0.1.</span> <span class="nav-text">Method1：DFS + DP(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-number">23.</span> <span class="nav-text">134. Gas Station</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Atwo-pointers-best-solution"><span class="nav-number">23.0.1.</span> <span class="nav-text">Method1：two pointers(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-number">24.</span> <span class="nav-text">142. Linked List Cycle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-number">25.</span> <span class="nav-text">146. LRU Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Ahashmap-and-doubly-linked-list-best-solution"><span class="nav-number">25.0.1.</span> <span class="nav-text">Method1：hashmap and doubly linked list(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">26.</span> <span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9ATwo-pointers-maintain-max-and-min-best-solution"><span class="nav-number">26.0.1.</span> <span class="nav-text">Method1：Two pointers(maintain max and min)(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-Min-Stack"><span class="nav-number">27.</span> <span class="nav-text">155. Min Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9AUse-tuple-to-keep-track-of-the-minimum"><span class="nav-number">27.0.1.</span> <span class="nav-text">Method1：Use tuple to keep track of the minimum</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-number">28.</span> <span class="nav-text">189. Rotate Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Ashift-the-n-k-elements"><span class="nav-number">28.0.1.</span> <span class="nav-text">Method1：shift the n-k elements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Areverse-the-array-best-solution"><span class="nav-number">28.0.2.</span> <span class="nav-text">Method2：reverse the array(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-number">29.</span> <span class="nav-text">200. Number of Islands</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-best-solution-3"><span class="nav-number">29.0.1.</span> <span class="nav-text">Method1：dfs(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-number">30.</span> <span class="nav-text">210. Course Schedule II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="nav-number">31.</span> <span class="nav-text">230. Kth Smallest Element in a BST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9ARecursive-Inorder-Traversal"><span class="nav-number">31.0.1.</span> <span class="nav-text">Method1：Recursive Inorder Traversal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-Product-of-Array-Except-Self"><span class="nav-number">32.</span> <span class="nav-text">238. Product of Array Except Self</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Aprefix-amp-suffix-two-pass"><span class="nav-number">32.0.1.</span> <span class="nav-text">Method1：prefix &amp; suffix (two-pass)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Aprefix-amp-suffix-one-pass-best-solution"><span class="nav-number">32.0.2.</span> <span class="nav-text">Method2：prefix &amp; suffix (one-pass, best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-Increasing-Triplet-Subsequence"><span class="nav-number">33.</span> <span class="nav-text">334. Increasing Triplet Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Atwo-pointers-best-solution-1"><span class="nav-number">33.0.1.</span> <span class="nav-text">Method1：two pointers (best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-number">34.</span> <span class="nav-text">378. Kth Smallest Element in a Sorted Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#min-heap-max-heap-%EF%BC%9A"><span class="nav-number">34.0.1.</span> <span class="nav-text">min heap(max heap)：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min-heap-in-python%EF%BC%9A"><span class="nav-number">34.0.2.</span> <span class="nav-text">min heap in python：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Amin-heap-best-solution"><span class="nav-number">34.0.3.</span> <span class="nav-text">Method1：min heap(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters"><span class="nav-number">35.</span> <span class="nav-text">395. Longest Substring with At Least K Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Asliding-window-best-solution"><span class="nav-number">35.0.1.</span> <span class="nav-text">Method1：sliding window(best solution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#958-Check-Completeness-of-a-Binary-Tree"><span class="nav-number">36.</span> <span class="nav-text">958. Check Completeness of a Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#complete-binary-tree"><span class="nav-number">36.0.1.</span> <span class="nav-text">complete binary tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method1%EF%BC%9Adfs-label"><span class="nav-number">36.0.2.</span> <span class="nav-text">Method1：dfs(label)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method2%EF%BC%9Abfs"><span class="nav-number">36.0.3.</span> <span class="nav-text">Method2：bfs</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Francis"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Francis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
