<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="FrancisTan">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="FrancisTan">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Francis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>FrancisTan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FrancisTan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just For Fun</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-RangeQueryProblem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/Algorithm-RangeQueryProblem/" class="post-title-link" itemprop="url">Algorithm-RangeQueryProblem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:56:01 / Modified: 04:57:57" itemprop="dateCreated datePublished" datetime="2023-02-17T04:56:01+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- title: Algorithm - Range query problem
author: Willy Wang (willywangkaa)

date: 2018-10-03 20:42:00
--- -->

<h1 id="Segement-tree"><a href="#Segement-tree" class="headerlink" title="Segement tree"></a>Segement tree</h1><p>用來存放紀錄在特定區間內 ( segement, interval ) 的資訊。</p>
<ul>
<li>Pros<ul>
<li>可以動態的更新欲求數組之元素。</li>
<li>數組區間的查詢<ul>
<li>區間求和值</li>
<li>區間最大值</li>
<li>區間最小值</li>
<li>區間<strong>異或值 ( Exclusive or；XOR )</strong></li>
</ul>
</li>
</ul>
</li>
<li>Cons<ul>
<li>無法刪除數值</li>
</ul>
</li>
</ul>
<blockquote>
<p>線段樹無法新增節點，只能更新節點的數值並保持區間的最大最小值仍保持正確。</p>
</blockquote>
<h2 id="實現"><a href="#實現" class="headerlink" title="實現"></a>實現</h2><ul>
<li>特性<ul>
<li>完全二元樹</li>
<li>節點保存<strong>特定區間的訊息</strong></li>
<li>採取 Buttom-up 的方式建構，從每一個葉節點建構</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<!-- ![STree_1](\willywangkaa\images\STree_1.png) -->
<blockquote>
</blockquote>
<!-- > - 上面的分段樹根節點保存 0 ~ 7 的資訊，2 號節點保存 0 ~ 3 的資訊，以此類推。 -->



<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在建構的過程中，內部節點之建構會使用兩個子節點的資訊，而建構的方式以處理的問題而作法不同 ( 最大、最小、和、XOR )。</p>
<ul>
<li>Segement create ( 求區間最小值 )<ul>
<li>ST：線段樹</li>
<li>A：欲判斷之數組資料</li>
<li>線段樹因為為<strong>完全二元樹</strong>所以通常以陣列製作<ul>
<li>陣列大小需求：$2 \times 2^{\lfloor\lg N\rfloor + 1}$，N 為數組大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- ![STree_2](\willywangkaa\images\STree_2.png) -->

<ul>
<li>程式碼 ( c++ )</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ST:segement tree; A: target number array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">st_create</span><span class="params">(vi &amp;ST, <span class="type">const</span> vi &amp;A)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">2</span>&lt;&lt;(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) - __buildin_clz((<span class="type">unsigned</span> <span class="type">int</span>)A.<span class="built_in">size</span>()));</span><br><span class="line">	ST.<span class="built_in">assign</span>(len, <span class="number">0</span>); <span class="comment">// 線段樹歸零</span></span><br><span class="line">	<span class="built_in">st_build</span>(ST, A, <span class="number">1</span>, <span class="number">0</span>, (<span class="type">int</span>) A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">st_build</span><span class="params">(vi &amp;ST, <span class="type">const</span> vi &amp;A, <span class="type">int</span> vetex, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;     </span><br><span class="line">	<span class="keyword">if</span> (L==R)</span><br><span class="line">        ST[vertex] = L;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> nL =  vertex &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> nR = (vertex &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">		<span class="built_in">st_build</span>(ST, A, nL, L           , ((L+R)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="built_in">st_build</span>(ST, A, nR, ((L+R)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, R         ); </span><br><span class="line">			</span><br><span class="line">		<span class="type">int</span> lContent=ST[nL], rContent=ST[nR];</span><br><span class="line">		<span class="type">int</span> lValue=A[lContent], rValue=A[rContent];</span><br><span class="line">		ST[vertex]=(lValue &lt;= rValue)? lContent : rContent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>時間複雜度<ul>
<li>$\Theta(\log n)$</li>
</ul>
</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>與建立線段樹的方法相同，將位於數組 <code>i</code> 的數字更新後，即從此葉節點向上執行更新至根節點。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以數值 v 更新 A[p]</span></span><br><span class="line"><span class="comment">// x: 數根</span></span><br><span class="line"><span class="comment">// L: 數組左端</span></span><br><span class="line"><span class="comment">// R: 數組右端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span> <span class="params">(vi &amp;ST, vi &amp;A, <span class="type">int</span> x, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;  </span><br><span class="line">	<span class="type">int</span> mid=L+(R-L)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L == R)</span><br><span class="line">		A[x] = v;</span><br><span class="line">	<span class="keyword">else</span> &#123;     </span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">			<span class="built_in">update</span>(ST, A, x*<span class="number">2</span>  , L    , mid, p, v); <span class="comment">// 更新左子樹</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">update</span>(ST, A, x*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, R  , p, v); <span class="comment">// 更新右子樹</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ST[x] = (A[ST[x*<span class="number">2</span>]]&lt;=A[ST[x*<span class="number">2</span>+<span class="number">1</span>]])? ST[x*<span class="number">2</span>]:ST[x*<span class="number">2</span>+<span class="number">1</span>]; <span class="comment">// 以左右子樹的資訊更新母節點</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查詢"><a href="#查詢" class="headerlink" title="查詢"></a>查詢</h3><p>分為三種情形討論，若<strong>當前節點所代表的區間</strong></p>
<ul>
<li><strong>完全位於</strong>欲求取之區間之<strong>外</strong></li>
<li><strong>完全位於</strong>欲求取之區間之<strong>內</strong></li>
<li><strong>部分位於</strong>欲求取之區間</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span> <span class="params">(vi &amp;ST, <span class="type">const</span> vi &amp;A, <span class="type">int</span> x, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;  </span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = (L+R)/<span class="number">2</span>, ans = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 當前節點完全位於欲求取之區間之內</span></span><br><span class="line">	<span class="keyword">if</span> (L&gt;=ql &amp;&amp; R&lt;=qr)</span><br><span class="line">		<span class="comment">// 取出該區間值最小的位址</span></span><br><span class="line">		<span class="keyword">return</span> ST[x];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 當前節點部分或無位於欲求取之區間之內</span></span><br><span class="line">	<span class="keyword">if</span> (ql&lt;=mid) &#123;</span><br><span class="line">		<span class="comment">// 取出左區間</span></span><br><span class="line">		ans = <span class="built_in">query</span>(ST, A, x*<span class="number">2</span>  , L    , mid, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qr&gt;mid) &#123;</span><br><span class="line">		<span class="comment">// 取出右區間以及比較</span></span><br><span class="line">		<span class="type">int</span> tmp = </span><br><span class="line">		      <span class="built_in">query</span>(ST, A, x*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, R  , ql, qr);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">			ans = tmp;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans = (A[ans] &lt; A[tmp])? ans:tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h2 id="其它實現"><a href="#其它實現" class="headerlink" title="其它實現"></a>其它實現</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Oq2E2yGadnU">Efficient Segment Tree Tutorial</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SegmentTree</span>(<span class="type">int</span> count) &#123;</span><br><span class="line">		n = count;</span><br><span class="line">		data = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SegmentTree</span>(std::vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;values) &#123;</span><br><span class="line">		n = values.<span class="built_in">size</span>();</span><br><span class="line">		data = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n);</span><br><span class="line">		std::<span class="built_in">copy</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), &amp;data[<span class="number">0</span>] + n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> idx = n - <span class="number">1</span>; idx &gt; <span class="number">0</span>; idx--)</span><br><span class="line">			data[idx] = std::<span class="built_in">min</span>(data[idx * <span class="number">2</span>], data[idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		idx += n;</span><br><span class="line">		data[idx] = value;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (idx &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			idx /= <span class="number">2</span>;</span><br><span class="line">			data[idx] = std::<span class="built_in">min</span>(data[<span class="number">2</span> * idx], data[<span class="number">2</span> * idx + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">minimum</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; <span class="comment">// interval [left, right)</span></span><br><span class="line">		<span class="type">int</span> ret = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">		left += n;</span><br><span class="line">		right += n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">if</span> (left &amp; <span class="number">1</span>) ret = std::<span class="built_in">min</span>(ret, data[left++]);</span><br><span class="line">			<span class="keyword">if</span> (right &amp; <span class="number">1</span>) ret = std::<span class="built_in">min</span>(ret, data[--right]);</span><br><span class="line">			left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">SegmentTree <span class="title">st</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; st.<span class="built_in">minimum</span>(i, i+<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">	st.<span class="built_in">update</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; st.<span class="built_in">minimum</span>(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">SegmentTree <span class="title">st2</span><span class="params">(&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Sparse-table"><a href="#Sparse-table" class="headerlink" title="Sparse table"></a>Sparse table</h1><blockquote>
<p>「Sparse table」為古代之稱，如今詞不達意</p>
</blockquote>
<ul>
<li><p>Pros</p>
<ul>
<li>數組區間的查詢<ul>
<li>區間最大值</li>
<li>區間最小值</li>
</ul>
</li>
</ul>
</li>
<li><p>Cons</p>
<ul>
<li>不能更新、插入、刪除值</li>
<li><strong>浪費空間</strong></li>
<li>無法數組區間的<ul>
<li>求和值</li>
<li><strong>異或值 ( Exclusive or；XOR )</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="實現-1"><a href="#實現-1" class="headerlink" title="實現"></a>實現</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>Construct sparse table<ul>
<li>N：資料量</li>
<li>value[N]：數組</li>
<li>cnt［logN］[N]：Sparse table</li>
</ul>
</li>
</ul>
<p>依序先求出寬度為 $2^0, 2^1, 2^2, \ldots, 2^{\lfloor\lg N\rfloor}$ 的區間<strong>最小值</strong>，區間的所有可能位置都要算一遍。兩個窄區間可以快速合成出一個寬區間。</p>
<!-- ![STable_1](\willywangkaa\images\STable_1.png) -->



<p>將所有區間算完存入 Sparse table</p>
<!-- ![STable_2](\willywangkaa\images\STable_2.png) -->

<blockquote>
<p>實作時，通常表格中記錄的是索引值、指標，而不是直接記錄數值的最小值。(如下程式碼)</p>
</blockquote>
<ul>
<li>程式碼 (c++)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000000</span>; <span class="comment">//No. of elements</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> logN = <span class="built_in">ceil</span>(<span class="built_in">log</span>(N));</span><br><span class="line"><span class="comment">//const int logN = sizeof(unsigned int) - __builtin_clz((unsigned int)dist) - 1;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value[N];</span><br><span class="line"><span class="type">int</span> cnt[logN][N]; <span class="comment">//cnt[i][j]: RMQ index</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Initialization</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line">		cnt[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2^i - 1 &lt; N &lt;=&gt; i &lt; ceil(log(N))</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt; N; i++)</span><br><span class="line">        <span class="comment">// j + (2^i-1) &lt; N ; buttom-up 建立</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span> &lt; N; j++) &#123;</span><br><span class="line">			<span class="type">int</span> L = cnt[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="type">int</span> R = cnt[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))];</span><br><span class="line">			cnt[i][j] = (value[L] &lt;= value[R])? L : R;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>時間複雜度</p>
<ul>
<li>$\Theta(N\log N)$</li>
</ul>
</li>
<li><p>空間複雜度</p>
<ul>
<li>$\Theta(N \log N)$</li>
</ul>
</li>
</ul>
<h4 id="查詢-1"><a href="#查詢-1" class="headerlink" title="查詢"></a>查詢</h4><p>從表格中找到寬度略短於（相等於）查詢區間的區間，以靠左、靠右的兩條等寬區間，求得查詢區間的最小值：</p>
<!-- ![STable_3](\willywangkaa\images\STable_3.png) -->



<ul>
<li>如何知道要查「Range」大小為何的表？<ul>
<li>令 $k$ 為我們所求 → $k &#x3D; \lfloor \lg N \rfloor$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> dist = <span class="built_in">abs</span>(b - a) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 2^i &lt; N &lt;=&gt; i &lt; cel(logN) ; 區間計算</span></span><br><span class="line">	<span class="type">int</span> i = <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) - __builtin_clz((<span class="type">unsigned</span> <span class="type">int</span>)dist) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> L = cnt[i][a];          <span class="comment">// 左區間</span></span><br><span class="line">	<span class="type">int</span> R = cnt[i][b-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>]; <span class="comment">// 右區間</span></span><br><span class="line">	<span class="keyword">return</span> value[L] &lt;= value[R]? L : R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>時間複雜度<ul>
<li>$\Theta(1)$</li>
</ul>
</li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809">线段树（segment tree)，看这一篇就够了</a></li>
</ul>
<!-- - 輔大張信宏老師講義 -->



<!-- - [演算法筆記](http://www.csie.ntnu.edu.tw/~u91029/Sequence2.html#5) -->
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/Algorithm-Graph/" class="post-title-link" itemprop="url">Algorithm - Graph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:41:21 / Modified: 04:48:39" itemprop="dateCreated datePublished" datetime="2023-02-17T04:41:21+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- title: Algorithm - Graph algorithm
author: Willy Wang (willywangkaa)

date: 2018-10-15 16:51:00
--- -->
<h1 id="Graph-algorithm"><a href="#Graph-algorithm" class="headerlink" title="Graph algorithm"></a>Graph algorithm</h1><h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth first search"></a>Depth first search</h2><ul>
<li><p>考慮圖中一點 u</p>
<ul>
<li>color(u)：目前 u 節點的狀態<ul>
<li>White<ul>
<li>初始值，<strong>尚未訪查過</strong></li>
</ul>
</li>
<li>Gray<ul>
<li><strong>已被訪查過</strong>，但未訪查完其子節點</li>
</ul>
</li>
<li>Black<ul>
<li><strong>已經訪查完其子節點</strong></li>
</ul>
</li>
</ul>
</li>
<li>d(u)<ul>
<li>發現時間點（Discover time）</li>
<li>第一次被訪查的時間點</li>
</ul>
</li>
<li>f(u)<ul>
<li>完結時間點（Finish time）</li>
<li>訪查完其子節點的時間點</li>
</ul>
</li>
</ul>
</li>
<li><p>演算法（P.4-6）</p>
<ul>
<li>**DFS(G)**：自 G 中任一點開始做 DFS<ul>
<li>dfs_visit(u)：訪查 u 節點</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V           <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">    time = <span class="number">0</span>;                 <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span> <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">dfs_visit</span><span class="params">(u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_visit</span><span class="params">(Graph G, node u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white)</span><br><span class="line">            <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">    </span><br><span class="line">    time++;</span><br><span class="line">    <span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Time complexity<ul>
<li>$\Theta(\vert V\vert+\vert E\vert)$ ：點數加上邊數</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>將整個圖的所有點與邊訪查一次</strong></p>
</blockquote>
<h3 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h3><h4 id="DFS-tree-Edge"><a href="#DFS-tree-Edge" class="headerlink" title="DFS tree - Edge"></a>DFS tree - Edge</h4><p>深度優先搜尋時，可以將圖中的邊分成四類：</p>
<ol>
<li><strong>Tree edge</strong><ul>
<li>u 透過 (u,v) 邊以訪查 v 節點</li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li>可在訪查的過程表示為一個「DFS tree」</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>Back edge</strong><ul>
<li>不為「Tree edge」，而在「DFS tree」上由<strong>子孫節點至祖先節點</strong>的邊</li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li><strong>自旋邊（Self loop）亦為「Back edge」</strong></li>
</ul>
</blockquote>
<ol start="3">
<li><strong>Forward edge</strong><ul>
<li>不為「Tree edge」，而在「DFS tree」上由<strong>祖先節點至子孫節點</strong>的邊</li>
</ul>
</li>
<li><strong>Cross edge</strong><ul>
<li>無祖孫關係的邊</li>
</ul>
</li>
</ol>
<p>在實現中，通常在執行 DFS 時就會直接以<strong>節點的狀態</strong>判斷邊的種類</p>
<ol>
<li><strong>Tree edge</strong></li>
</ol>
<p>$$<br>u_{灰} \rightarrow_{Tree–edge} v_{白}<br>$$</p>
<ol start="2">
<li><strong>Back edge</strong></li>
</ol>
<p>$$<br>u_{灰} \rightarrow_{Back–edge} v_{灰}<br>$$</p>
<ol start="3">
<li><strong>Forward edge</strong></li>
</ol>
<p>$$<br>u_{灰} \rightarrow_{Forward–edge} ｛v_{黑} ;＆＆ ; d(u)&lt;d(v) ｝<br>$$</p>
<!-- ![forwardedge](\willywangkaa\images\forwardedge.png) -->



<ol start="4">
<li><strong>Cross edge</strong></li>
</ol>
<p>$$<br>u_{灰} \rightarrow_{Cross–edge} ｛v_{黑} ;＆＆ ; d(v)&lt;d(u) ｝<br>$$</p>
<!-- ![crossedge](\willywangkaa\images\crossedge.png)

- Ex （96 年台大資工） -->



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V &#123;          <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">        <span class="built_in">edge</span>(u)  = <span class="literal">NULL</span>;       <span class="comment">// DFS tree 初始化邊(雙向邊)</span></span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;                  <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span> <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">dfs_visit</span><span class="params">(G,u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_visit</span><span class="params">(Graph G,node u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white) &#123;</span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            <span class="built_in">edge</span>(v).attribute     = tree;</span><br><span class="line">            <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">color</span>(v) == gray) &#123;</span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            <span class="built_in">parent</span>(v).attribute   = back;</span><br><span class="line">			<span class="built_in">dfs_visit</span>(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 黑節點</span></span><br><span class="line">            <span class="built_in">edge</span>(v)               = u;       <span class="comment">// 相連節點設為 u</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">d</span>(u) &gt; <span class="built_in">d</span>(v))                  <span class="comment">// 無祖孫關係</span></span><br><span class="line">				<span class="built_in">edge</span>(v).attribute = cross;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">d</span>(u) &lt; <span class="built_in">d</span>(v))             <span class="comment">// 有祖孫關係</span></span><br><span class="line">				<span class="built_in">edge</span>(v).attribute = forward;</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">dfs_visit</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	time++</span><br><span class="line">	<span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DFS-tree-Acyclic"><a href="#DFS-tree-Acyclic" class="headerlink" title="DFS tree - Acyclic"></a>DFS tree - Acyclic</h4><blockquote>
<p><strong>存在「Back edge」時，代表有迴圈產生</strong></p>
</blockquote>
<!-- - 演算法（94 台大資工）（99 台大資工） -->

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acyclic</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    foreach u ∈ G.V                      <span class="comment">// G 的點集合</span></span><br><span class="line">        <span class="built_in">color</span>(u) = white;</span><br><span class="line">    time = <span class="number">0</span>;                            <span class="comment">// 紀錄目前的時間</span></span><br><span class="line"></span><br><span class="line">    foreach u ∈ G.<span class="function">V</span></span><br><span class="line"><span class="function">        <span class="title">if</span><span class="params">(color(u) == white)</span>            <span class="comment">// 找到一個尚未被訪查過的節點</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span><span class="params">(dfs_visit(G,u) == CYCLIC)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">return</span> CYCLIC</span>;</span><br><span class="line">    <span class="keyword">return</span> ACYCLIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CYCLIC = true, ACYCLIC = false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs_visit</span><span class="params">(Graph G, node u)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">color</span>(u) = gray;</span><br><span class="line">    <span class="built_in">d</span>(u)     = ++time;</span><br><span class="line"></span><br><span class="line">    foreach v ∈ G.<span class="built_in">adj</span>(u) &#123;</span><br><span class="line">        f = ACYCLIC;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">color</span>(v) == white)</span><br><span class="line">            f = f || <span class="built_in">dfs_visit</span>(G,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">color</span>(v) == gray)        <span class="comment">// 找到 Back-edge</span></span><br><span class="line">            f = f || CYCLIC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    time++;</span><br><span class="line">    <span class="built_in">f</span>(u)     = time;</span><br><span class="line">    <span class="built_in">color</span>(u) = black;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Time complexity</strong><!-- - **有向圖**（94 台大資工） -->
<ul>
<li>$\Theta(∣V∣+∣E∣)$<!-- - **無向圖**（99 台大資工） --></li>
<li>$\Theta(∣V∣)$</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>無向圖</strong></p>
<ul>
<li><p>根據鴿籠原理，最多只要檢查 V 個邊即可知道此圖是否為「Cyclic」</p>
<ul>
<li>$\Theta(∣V∣+∣V∣) &#x3D; \Theta(∣V∣)$</li>
</ul>
</li>
<li><p><strong>在無向圖中只含有</strong></p>
<ul>
<li><strong>Tree edge</strong></li>
<li><strong>Back edge</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>有向圖</strong>不能以上述判斷</p>
<p>Example</p>
<ul>
<li>兩節點 A、B<ul>
<li>五條邊皆從 A 節點至 B 節點</li>
<li><strong>此圖不包含「Cycle」</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Minimum-spainning-tree"><a href="#Minimum-spainning-tree" class="headerlink" title="Minimum spainning tree"></a>Minimum spainning tree</h2><h3 id="問題探討"><a href="#問題探討" class="headerlink" title="問題探討"></a>問題探討</h3><ul>
<li><strong>假設 (u,v) 為 G 權重最小的邊，則 (u,v) 必在 G 的某一個「最小生成樹」中</strong></li>
</ul>
<p>（<strong>反證法</strong>）</p>
<!-- ![minimumspainingtree_1](\willywangkaa\images\minimumspainingtree_1.png) -->



<ul>
<li>假設 T 為 G 的一個最小生成樹<ul>
<li>(u,v)∉T</li>
<li>則 T ∪ {(u,v)} 會產生一個環路 C<ul>
<li>C 存在一邊 e≠(u,v)，其 Weight(e) ≧ Weight(u,v)</li>
</ul>
</li>
</ul>
</li>
<li>令 T’ &#x3D; T ∪ {(u,v)} - {e}<ul>
<li>則 Weight(T’) ≦ Weight(T)</li>
<li><strong>T 不為 G 的最小生成樹</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>有兩種矛盾的現象產生</p>
<ul>
<li>當 $Weight(T’)&lt;Weight(T)$ 時<ul>
<li>代表原本的生成樹不為最小生成樹</li>
</ul>
</li>
<li>當 $Weight(T’) &#x3D; Weight(T)$ 時<ul>
<li>代表該最小生成樹的集合中，必有一個樹包含 (u,v) 邊</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>「Cycle」：<strong>由三條邊組成的環路</strong></p>
</blockquote>
<ul>
<li>☆ 假設 (u,v) 為 G 中「權重」（Weight）<strong>第二小</strong>的邊<ul>
<li>則 (u,v) 必在 G 的某一個「最小生成樹」中</li>
</ul>
</li>
</ul>
<p>（<strong>反證法</strong>）</p>
<!-- > 前提為該圖 G 各個權重不相等，否則反例如下：
>
> ![minimumspainingtree_2](\willywangkaa\images\minimumspainingtree_2.png) -->


<ul>
<li>假設 T 為 G 的一個最小生成樹<ul>
<li>(u,v)∉T</li>
<li>則 T ∪ {(u,v)} 會產生一個環路 C<ul>
<li>因為環路必由三個邊組成<ul>
<li>C 存在一邊 e≠(u,v)，其 Weight(e) ≧ Weight(u,v)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>令 T’ &#x3D; T ∪ {(u,v)} - {e}<ul>
<li>則 Weight(T’) ≦ Weight(T)</li>
<li><strong>T 不為 G 的最小生成樹</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>G 中<strong>權重第三小</strong>的邊不一定存在於 G 的某一個「最小生成樹」中</p>
</blockquote>
<!-- > - Counter example -->
<blockquote>
</blockquote>
<!-- ![minimumspainingtree_3](\willywangkaa\images\minimumspainingtree_3.png) -->



<h4 id="Kruskal’s-algorithm-的正確性"><a href="#Kruskal’s-algorithm-的正確性" class="headerlink" title="Kruskal’s algorithm 的正確性"></a>Kruskal’s algorithm 的正確性</h4><ul>
<li>T&#x3D;(V,E)<ul>
<li>使用「Kruskal’s algorithm」找出的生成樹</li>
</ul>
</li>
<li>T’&#x3D;(V,E’)<ul>
<li>真正的最小生成樹</li>
</ul>
</li>
</ul>
<ol>
<li>若 T &#x3D; T’​ <ul>
<li>得證</li>
</ul>
</li>
<li>若 T ≠ T’<ul>
<li>T 必有邊不包含在 T’ 之中<ul>
<li>則挑一權重最小的邊 e ∈ E - E’</li>
<li>T’ ∪ {e} 形成一環路 C</li>
<li>T’ ∪ {e} 存在 e’ ≠ e 且 w(e’) ≧ w(e)<ul>
<li>若 w(e’) &lt; w(e)，「Kruskal’s algorithm」執行時必優先選擇 e’（矛盾）</li>
</ul>
</li>
</ul>
</li>
<li>可造一個生成樹 T’’ &#x3D; (V, <strong>(E’ - {e’})</strong> ∪ {e})<ul>
<li>Weight(T’’) ≦ Weight(T’)</li>
</ul>
</li>
<li>重複上述步驟<ul>
<li>$T’ \xrightarrow{用;T;有而;T’;沒有的邊做替換} T’’ \xrightarrow{用;T;有而;T’’;沒有的邊做替換} \dots \rightarrow T$ </li>
<li>其過程中生成樹的權重不會增加<ul>
<li>則可以證明 Weight(T’) &#x3D; Weight(T)</li>
<li>T 為最小生成樹</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Flow-network"><a href="#Flow-network" class="headerlink" title="Flow network"></a>Flow network</h2><p>「流量網路圖論模型」為一<strong>有向圖</strong> G&#x3D;(V,E) 滿足：</p>
<ul>
<li><p>含有唯一「<strong>in-degree &#x3D; 0</strong>」的點 S（Source；源點）</p>
</li>
<li><p>含有唯一「<strong>out-degree &#x3D; 0</strong>」的點 T（Sink；匯點）</p>
</li>
<li><p>對於 (u,v) ∈ E</p>
<ul>
<li>定義<strong>容量 c：</strong>$E→R^+$<ul>
<li>通常其加權有向邊 (u,v) 代表其<strong>容量</strong></li>
</ul>
</li>
<li>定義<strong>流量 f：</strong>$E → R$<ul>
<li><strong>每個點流入水量等於流出水量</strong></li>
</ul>
</li>
<li>容量限制（Capacity constraints）<ul>
<li>$\forall(u,v )\in  E \Rightarrow f(u,v)\leq c(u,v)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>假設一流量網路 G&#x3D;(V,E)，其「殘餘網路」（Residual network）為</p>
<ul>
<li>有向圖 $G_f &#x3D; (V, E_f)$<ul>
<li>$E_f &#x3D; ｛(u,v)︱^{（1）}0&lt;f(u,v)&lt;c(u,v) ;或; ^{（2）}f(u,v)&lt;0｝$</li>
<li>上述意旨 $(u,v)\in E_f$ 代表<strong>其邊「尚有容量可以自 u 至 v」</strong><ul>
<li>假設 $f(u,v)&gt;0$ 代表有流量自 u 至 v，則其邊有容量的可能有二<ul>
<li><strong>（1）其流量尚未達到容量（</strong>$f(u,v) &lt; c(u,v)$<strong>）</strong><ul>
<li>殘餘容量：$c_f(u,v) &#x3D; c(u,v)-f(u,v)$</li>
</ul>
</li>
<li><strong>（2）流量可以使其產生「回推容量」</strong><ul>
<li>因為 $f(u,v)$ 代表<strong>「u 至 v 有流量通過」</strong><ul>
<li>則<strong>「v 至 u」</strong>可將通過的流量<strong>回推</strong>，進而產生<strong>容量</strong></li>
</ul>
</li>
<li>殘餘容量：$c_f(v,u) &#x3D; f(u,v) &#x3D; -f(v,u)$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>「流量網路」的邊在「殘餘網路」中<strong>至多會被拆成兩條邊</strong><ul>
<li>$∣E_f∣ \leq 2∣E∣$</li>
</ul>
</li>
</ul>
</li>
<li>假設在 $G_f$ 中，<strong>從「源點」至「匯點」存在一條路徑</strong><ul>
<li><strong>代表「源點」至「匯點」尚有容量</strong></li>
<li>假設其路徑中可以產生最小流量 $f’$<ul>
<li>原流量網路的流量可增加為 $f+f’$</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>增廣路徑定裡</strong></p>
<ul>
<li><strong>「一個網路達到最大流」</strong>$\Leftrightarrow$ <strong>「其殘餘網路中『源點』至『匯點』沒有路徑」</strong></li>
</ul>
</blockquote>
<h3 id="Max-flow-problem"><a href="#Max-flow-problem" class="headerlink" title="Max flow problem"></a>Max flow problem</h3><ul>
<li>Input<ul>
<li>一個「Flow network」 G &#x3D; (V,E)</li>
</ul>
</li>
<li>Output<ul>
<li>此網路的最大流量（源點最大流至匯點的水量）</li>
</ul>
</li>
</ul>
<!-- ![flownetwork](\willywangkaa\images\flownetwork.png) -->



<h4 id="Ford-Fulkerson-algorithm"><a href="#Ford-Fulkerson-algorithm" class="headerlink" title="Ford-Fulkerson algorithm"></a>Ford-Fulkerson algorithm</h4><p>步驟</p>
<ol>
<li>先將「流量網路」G 轉換為「殘餘網路」$G_f$</li>
<li>在 $G_f$ 中自 s → t 找一條增廣路徑 p（隨便的方法找一條路徑，如：DFS）<ul>
<li>令 f 為 p 上最小的權重<ul>
<li>$\overrightarrow{P}$ 上每一邊的容量減少 f</li>
<li>$\overleftarrow{P}$上的每一邊容量增加 f<strong>（回推容量）</strong></li>
</ul>
</li>
</ul>
</li>
<li>重複第二步直到找不到增廣路徑 p</li>
<li>指向頂點 s 邊，其容量總和即為「最大流量」</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">fordfulkerson</span><span class="params">(Graph G, node s, node t)</span> </span>&#123;</span><br><span class="line">    G_f = <span class="built_in">residualnetwork</span>(G);</span><br><span class="line">    path = <span class="built_in">exist_path</span>(G_f,s,t);</span><br><span class="line">    <span class="keyword">while</span>(path) &#123;</span><br><span class="line">        G_f = <span class="built_in">add_argumenting_path</span>(G_f, path);</span><br><span class="line">        path = <span class="built_in">exist_path</span>(G_f,s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G_f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Time complexity<ul>
<li>$O(∣f^＊∣\cdot E)$<ul>
<li>$∣f^＊∣$ 為最大流量</li>
<li><strong>效能差</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><strong>每次在第二個步找到的最小流量 f 為 1</strong><ul>
<li>每次找增廣路徑的時間複雜度為 O(∣V∣+∣E∣)</li>
<li><strong>必重複</strong> $∣f^＊∣$ <strong>回合找到最後總流量</strong><ul>
<li>$O(∣f^＊∣\cdot(∣V∣+∣E∣)) &#x3D; O(∣f^＊∣\cdot E)$</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<!-- > ![1549795349837](\willywangkaa\images\1549795349837.png) -->





<blockquote>
<p><strong>利用「已經求取完最大流量」的 Residual network 可得到「原本流量網路」的 Minimum cut</strong></p>
<ul>
<li>Minimum cut：有 (S,T) 兩個子圖，滿足<ul>
<li>S $\cup$ T &#x3D; V 且 S $\cap$ T &#x3D; $\phi$</li>
<li>從子圖 S 連至子圖 T 之所有邊的權重和為所有「Cut」中最小</li>
</ul>
</li>
</ul>
<p>在求完最大流量的「Residual network」中，令</p>
<ul>
<li>S：｛自 S 可以到達的節點｝</li>
<li>T：｛自 T 可以到達的節點｝</li>
</ul>
<p>則 (S, T) 是原本「Flow network」的「Minimum cut」</p>
</blockquote>
<h4 id="Edmond-Karp-algorithm"><a href="#Edmond-Karp-algorithm" class="headerlink" title="Edmond-Karp algorithm"></a>Edmond-Karp algorithm</h4><p>步驟</p>
<ol>
<li>先將「流量網路」G 轉換為「殘餘網路」$G_f$</li>
<li>自 s 作「<strong>Breadth first search</strong>」至 t 找到路徑 p<ul>
<li>令 f 為 p 上最小的權重<ul>
<li>$\overrightarrow{P}$ 上每一邊的容量減少 f</li>
<li>$\overleftarrow{P}$上的每一邊容量增加 f<strong>（回推容量）</strong></li>
</ul>
</li>
</ul>
</li>
<li>重複第二步直到找不到增廣路徑 p</li>
<li>指向頂點 s 邊，其容量總和即為「最大流量」</li>
</ol>
<ul>
<li>Time complexity<ul>
<li>以「Breadth first search」找最多 O(∣V∣∣E∣) 條「增廣路徑」<ul>
<li>「鄰接矩陣」：$O(∣V∣^2∣V∣∣E∣) &#x3D; O(∣V∣^3∣E∣)$</li>
<li>「鄰接串列」：$O((∣V∣+∣E∣)(∣V∣∣E∣)) &#x3D; O(∣V∣∣E∣^2)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="時間複雜度證明"><a href="#時間複雜度證明" class="headerlink" title="時間複雜度證明"></a>時間複雜度證明</h5><p><strong>證明最短增廣路徑（Argument path）的長度「非遞減」（反證法）</strong></p>
<blockquote>
<p>$G_f &#x3D; (V, E_f)$：<strong>某次增廣前的「殘餘網路圖」</strong></p>
<p>$G_{f’} &#x3D; (V, E_{f’})$：<strong>某次增廣後的「殘餘網路圖」</strong></p>
<ul>
<li>$\forall x \in V$<ul>
<li>$\delta_f (s, x)$ 為源點 s 到 x 頂點在 $G_f$ <strong>最短路徑</strong></li>
<li>$\delta_{f’} (s, x)$ 為源點 s 到 x 頂點在 $G_f$ <strong>最短路徑</strong></li>
</ul>
</li>
</ul>
</blockquote>
<ol>
<li><p>假設 v 頂點是「在某次增廣後 $\delta_{f} (s, v)$ 長度變小的頂點」</p>
<ul>
<li>$\Rightarrow \delta_f(s,v) &gt; \delta_{f’}(s,v)$</li>
</ul>
</li>
<li><p>假設 u 頂點為最短路徑 $\delta_{f’}(s,v)$ 裡 v 的前一個頂點（<strong>在該次增廣後其最短路徑有可能變長或不變</strong>）</p>
<ul>
<li>$\Rightarrow \delta_{f’}(s,v) &#x3D; \delta_{f’}(s,u)+1$</li>
<li>因為「增廣前 s 至 u 的最短路徑」≦「增廣後 s 至 u 的最短路徑」<ul>
<li>$\Rightarrow \delta_f(s,u) \leq \delta_{f’}(s,u) $<ul>
<li>則 $\Rightarrow \delta_f(s,u)+1 \leq \delta_{f’}(s,u)+1 &#x3D; \delta_{f’}(s,v) &lt; \delta_f(s,v)\ \Rightarrow \delta_f(s,v)&gt; \delta_f(s,u)+1 ;……（1）$</li>
</ul>
</li>
<li>如果 $(u,v) \in E_f$<ul>
<li>由於三角定裡則「s 至 v 的最短路徑」必小於等於「s 至 u 的最短路徑」加上 (u,v) 邊<ul>
<li>$\Rightarrow \delta_f(s,v) \leq \delta(s,u)+1$</li>
</ul>
</li>
</ul>
</li>
<li>因為（1）則 $(u,v)\notin E_f$</li>
</ul>
</li>
</ul>
</li>
<li><p>因為 $(u,v) \in E_{f’}$ 且 $(u,v) \notin E_f$</p>
<ul>
<li>所以可以知道<strong>「此次增廣必經過 (v, u)」</strong><ul>
<li>則「s 至 u 的最短路徑」等於「s 至 v 的最短路徑」+ 1<ul>
<li>$\Rightarrow \delta_f(s,u) &#x3D; \delta_f(s,v)+1 ;…..（2）$</li>
</ul>
</li>
</ul>
</li>
<li>將（2）帶入（1）中<ul>
<li>$\Rightarrow \delta_f(s,v) &gt; (\delta_f(s,v) + 1)+1 $（矛盾）</li>
</ul>
</li>
</ul>
</li>
<li><p>所以 v 頂點不存在，證明<strong>「最短增廣路徑」長度非遞減</strong></p>
</li>
</ol>
<p><strong>證明增廣次數為 O(∣V∣∣E∣)</strong></p>
<blockquote>
<ul>
<li>在一次增廣中<ul>
<li><strong>定義「Critical edge」為該增廣路徑中容量最小的邊（</strong>若有多條取其一即可）</li>
</ul>
</li>
</ul>
</blockquote>
<ol>
<li>假設 (u,v) 為 k-th 增廣中的「Critical edge」<ul>
<li>則 k-th 增廣後 $(u,v) \notin E_{f’}$</li>
<li>若在 k-th 增廣之後的 i-th 增廣後 (u,v) 再度出現（i &gt; k）<ul>
<li>則 i-th 增廣必定沿著 (u,v) 進行增廣</li>
</ul>
</li>
</ul>
</li>
<li>對 k-th 與 i-th 進行討論<ul>
<li>在 k-th 增廣前，存在 $\delta_{f^{作 ;k–th ; 之前}}(s,v)+1 &#x3D; \delta_{f^{作 ;k–th ; 之前}}(s,u)$</li>
<li>在 i-th 增廣前，存在 $\delta_{f^{作 ;i–th ; 之前}}(s,u)+1 &#x3D; \delta_{f^{作 ;i–th ; 之前}}(s,v)$</li>
<li>然而已知「最短增廣路徑長度非遞減」<ul>
<li>故 $\delta_{f^{作 ;k–th ; 之前}}(s,v)+2 \leq \delta_{f^{作 ;i–th ; 之前}}(s,u)$</li>
</ul>
</li>
</ul>
</li>
<li>最短增廣路的長度不超過 ∣V∣-1<ul>
<li>因為一條邊為「Critical edge」時，其增廣路徑會不斷累加 2<ul>
<li>故一條邊成為「Critical edge」的次數不超過 $\frac{∣V∣-1}{2}$</li>
</ul>
</li>
<li>每次增廣最少有一條「Critical edge」<ul>
<li>由定義可以知道 $∣E_f∣ \leq 2∣E∣$</li>
</ul>
</li>
<li>所以最差的情況就是每條邊都被選成為增廣路徑<ul>
<li>$O(\frac{∣V∣-1}{2}\cdot 2∣E∣) &#x3D;O(∣V∣∣E∣) $</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="Dinic-algorithm"><a href="#Dinic-algorithm" class="headerlink" title="Dinic algorithm"></a>Dinic algorithm</h4><p>「Shortest augmenting path algorithm」改良版，作一次可以找到所有「一樣長的最短擴充路徑」</p>
<p>步驟</p>
<ol>
<li>計算「剩餘網路」各點到源點（匯點）的最短距離</li>
<li>建立「容許網路」（Admissible network）<ul>
<li>尋找「阻塞流」（Blocking flow），並擴充其流量</li>
</ul>
</li>
<li>重覆步驟 1、2 最多 V-1 次，直到無法擴充流量</li>
</ol>
<blockquote>
<ul>
<li><p>在「剩餘網路」中</p>
<ul>
<li>以阻塞流擴充流量，就斷絕了所有「一樣長的最短擴充路徑」</li>
</ul>
</li>
<li><p>在「容許網路」中</p>
<ul>
<li>所有「由源點到匯點的最短路徑」都被阻塞<ul>
<li>在「剩餘網路」中，在「Edmond-Karp algorithm」中已證明源點到匯點的最短距離會增加</li>
</ul>
</li>
</ul>
</li>
<li><p>「擴充路徑」的長度範圍是 1 到 V-1 （Simple path）</p>
<ul>
<li>故最多找 V-1 次阻塞流</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>時間複雜度<ul>
<li>O(∣V∣²∣E∣)<ul>
<li>找一個阻塞流：O(∣V∣∣E∣) </li>
<li>最多找：O(∣V∣)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="容許網路"><a href="#容許網路" class="headerlink" title="容許網路"></a>容許網路</h5><p>在「剩餘網路」上以源點（匯點）作為起點，計算源點（匯點）到每一點的<strong>最短距離</strong></p>
<ul>
<li>在剩餘網路中<ul>
<li>一條由<strong>源點往匯點方向</strong>的邊<ul>
<li>若兩其端點最短距離相差一<ul>
<li>稱作「容許邊」（Admissible edge）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所有容許邊，整體視作一張圖<ul>
<li>稱作「容許網路」（Admissible Network）</li>
</ul>
</li>
</ul>
<p>「流量網路」G &#x3D; (V,E)</p>
<!-- ![1549793031130](\willywangkaa\images\1549793031130.png) -->



<p>其「剩餘網路」$G_f &#x3D; (V, E_f)$</p>
<!-- ![1549793298592](\willywangkaa\images\1549793298592.png) -->



<p>一種由源點開始的「容許網路」</p>
<!-- ![1549793355647](\willywangkaa\images\1549793355647.png) -->



<p>一種由匯點開始的「容許網路」</p>
<!-- ![1549793388148](\willywangkaa\images\1549793388148.png) -->



<blockquote>
<ul>
<li>容許網路<ul>
<li>為有向無環圖（DAG）或稱作分層圖（Level graph）<ul>
<li>容許網路可以畫成一層一層的模樣，只有相鄰的層有邊</li>
</ul>
</li>
<li>任意一條由源點到匯點的路徑<ul>
<li>為最短擴充路徑</li>
</ul>
</li>
<li>藉由容許網路，可以迅速找到所有「一樣長的最短擴充路徑」</li>
</ul>
</li>
</ul>
<p>容許網路就是剩餘網路的「最短路徑圖」</p>
</blockquote>
<!-- > ![1549793497499](\willywangkaa\images\1549793497499.png) -->
<blockquote>
</blockquote>
<!-- > （左圖為源點開始的「容許網路」分層圖；右圖為匯點開始的「容許網路」分層圖） -->



<h5 id="阻塞流"><a href="#阻塞流" class="headerlink" title="阻塞流"></a>阻塞流</h5><p>在容許網路中一個源點到匯點的流，無法再擴充流量稱作「阻塞流」（通常會出現許多種選擇，不必選其最大流）</p>
<ol>
<li>逐次建立的「容許網路」中<ul>
<li><strong>會找到所有「一樣長的最短擴充路徑」</strong></li>
</ul>
</li>
<li>在該「容許網路」中<strong>讓擴充的流量到達瓶頸</strong><ul>
<li>整體形成「阻塞流」</li>
</ul>
</li>
</ol>
<!-- ![1549794137394](\willywangkaa\images\1549794137394.png) -->

<blockquote>
<ul>
<li><p>容許網路上尋找最短擴充路徑</p>
<ul>
<li>不必作溯洄沖減（溯洄沖減會增加路徑長度，最後得到的不是最短擴充路徑）</li>
</ul>
</li>
<li><p>源點隨意往匯點走，若遇到死胡同，就重頭開始走，下次避免再走到死胡同</p>
<ul>
<li><strong>改由匯點隨意往源點走，就不會遇到死胡同</strong></li>
</ul>
</li>
<li><p>若順利走到匯點，就形成一條最短擴充路徑，並且擴充流量</p>
<ul>
<li><strong>一條最短擴充路徑</strong><ul>
<li>至少有<strong>一條邊</strong>是瓶頸</li>
</ul>
</li>
</ul>
</li>
<li><p>容許網路最多只有 E 條邊能作為瓶頸</p>
<ul>
<li>所以一個阻塞流最多只有 E 條最短擴充路徑</li>
<li>從源點走到匯點並擴充流量需時 O(∣V∣)<ul>
<li>最多有 O(∣E∣) 條最短擴充路徑，所以找出一個阻塞流的時間複雜度為 O(∣V∣∣E∣)</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="補充例題"><a href="#補充例題" class="headerlink" title="補充例題"></a>補充例題</h4><p><strong>Example</strong>（P.4-80 ex.20；<strong>Escape problem</strong>）</p>
<!-- ![escapeproblem](\willywangkaa\images\escapeproblem.png) -->



<blockquote>
<p>將問題轉換成「邊與點均有 <strong>Capacity</strong> 的最大流量問題」</p>
<p><strong>（將問題「Reduce」至「Flow network」中解決）</strong></p>
</blockquote>
<!-- ![escapeproblem_sol](\willywangkaa\images\escapeproblem_sol.png) -->



<p>給定一個「Escape problem」的格子圖 ( Grid；有 m 個<strong>起點</strong>與 4n-4 個<strong>出口</strong> )</p>
<p>建立「Flow network」G&#x3D;(V,E)：</p>
<ol>
<li>建立一個「Source」節點 S 並與逃生問題中的<strong>起點</strong>（藍色節點）相接</li>
<li>建立一個「Sink」節點 T 並與逃生問題中的<strong>邊界點</strong>（黃色區塊）的點相接</li>
<li>「Grid」上的每一條無向邊 (u,v) ，在 G 中建立相對應的有向邊 (u,v) 與 (v,u)</li>
<li>將每一個節點與邊的流量接設定為 1</li>
</ol>
<p>若在 G 中能找到最大流量為 m，則亦可以在「Grid」中找到一個逃生的方法。</p>
<blockquote>
<p><strong>點與邊均有「Capacity」 的流量網路可以用傳統的流量網路實現</strong></p>
</blockquote>
<!-- ![escapeproblem_solconti](\willywangkaa\images\escapeproblem_solconti.png) -->





<!-- **Example（2）（101交通大學資料結構與演算法）** -->

<p>This question is about the max flow problem</p>
<ul>
<li><strong>Which of the following statements is wrong?</strong><ul>
<li>（A）By the Ford-Fulkerson algorithm we can find the maximum flow.</li>
<li>（B）Given a flow network G&#x3D;(V,E), Edmond-Karp algorithm has time complexity $O(∣V∣∣E∣^2)$.</li>
<li>（C）The time complexity of Ford-Fulkerson algorithm depend on the capacity.</li>
<li><strong>（D）If each edge has a different capacity, then there exists a unique minimum cut.</strong></li>
<li>（E）The maximum flow is equal to the capacity of a minimum cut.</li>
</ul>
</li>
</ul>
<!-- ![1549709412486](\willywangkaa\images\1549709412486.png) -->

<ul>
<li><strong>Which statement is wrong for a flow network G&#x3D;(V,E)?</strong><ul>
<li>（A）If f is a maximum flow in G, <strong>then the corresponding residual network contains no augmenting path.</strong></li>
<li>（B）For any cut (S,T), the capacity of the cut is not smaller than the value of the flow crossing this cut.</li>
<li>（C）The value of any flow f in G is bounded above by the capacity of any cut of G.</li>
<li><strong>（D）If all edges of G have different capacities, then there exists a unique flow f that gives the maximum flow.</strong></li>
<li>（E）The capacity of each edge of G can be any non-negative number.</li>
</ul>
</li>
</ul>
<!-- ![1549708938056](\willywangkaa\images\1549708938056.png) -->



<ul>
<li><strong>Let G&#x3D;(V,E) be a bipartite graph, where V &#x3D; L ∪ R. Which statement is wrong about finding a maximum  bipartite matching?</strong><ul>
<li>（A）It can be solved by constructing a corresponding flow network and finding the maximum flow.</li>
<li>（B）The corresponding flow network can be obtained by adding two vertices s, t and edges from s to vertices in L, and edges from vertices in R to t.</li>
<li>（C）The capacity of each edge in the corresponding flow network is set to 1.</li>
<li><strong>（D）The maximum flow of the corresponding flow network is always integral and the flow value of each edge is integral as well.</strong></li>
<li>（E）The cardinality of a maximum matching of G is equal to the maximum flow of the corresponding flow network.</li>
</ul>
</li>
</ul>
<p><strong>「Maximum flow」必為整數，但是 Edge 上的「Flow」未必</strong></p>
<!-- ![1549709744238](\willywangkaa\images\1549709744238.png) -->





<h2 id="其它問題"><a href="#其它問題" class="headerlink" title="其它問題"></a>其它問題</h2><ul>
<li><strong>問題的要求即使有小變化，可能使其難度改變很大</strong><ul>
<li>Shortest path problem（Polynomial）與 <strong>Longest path problem（Non-deterministic polynomial）</strong></li>
<li>Minimum cut（Polynomial）與 <strong>Maximum cut（Non-deterministic polynomial）</strong></li>
<li><strong>Euler circuit（Polynomial）</strong>與 Hamilton cycle（NP-Complete）</li>
</ul>
</li>
<li><strong>同一個問題，若給的環境不同，難度亦可能相差很多</strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Graph</th>
<th>Tree</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Longest path problem</strong></td>
<td>NPC</td>
<td>Linear time（4-66 ex.6）</td>
</tr>
<tr>
<td><strong>Minimum vertex cover</strong></td>
<td>NPC</td>
<td>Linear time（Polynomial）</td>
</tr>
</tbody></table>
<blockquote>
<p>Vertex cover：會和圖上所有邊相連的一個<strong>點集合</strong></p>
<p>下圖的「Vertex cover」為｛b, d, f｝</p>
</blockquote>
<!-- ![vertexcover](\willywangkaa\images\vertexcover.png) -->



<h1 id="補充例題-1"><a href="#補充例題-1" class="headerlink" title="補充例題"></a>補充例題</h1><!-- Example（100 交通大學資料結構與演算法） -->

<ul>
<li>Suppose there are several cities along a highway (from the left to the right on the map), which has no forks</li>
<li>Given the distances between the neighboring cities, we can compute the distance between any two cities<ul>
<li>For example, given 4 cities, in order, (A,B,C,D) and the distances between neighboring cities are: distance(A,B)&#x3D;1, distance(B, C)&#x3D;2, distance(C,D)&#x3D;4</li>
<li>Then we can compute the distance matrix</li>
</ul>
</li>
<li>In this problem, we consider the reverse problem<ul>
<li>Given the distance between all pair of the cities, we want to recover the order of the cities along the highway</li>
<li>Suppose there are N cities and we only know the distances between all pairs of cities, that is, there are $\frac{N(N-1)}{2}$ number in arbitrary order</li>
<li>For convenience, let the leftmost city be the first city and the rightmost city be the last one and order cities accordingly</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1</td>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>B</td>
<td></td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>C</td>
<td></td>
<td></td>
<td>4</td>
</tr>
</tbody></table>
<blockquote>
<p>（中譯）</p>
<ul>
<li>假設有數個在「無岔路高速公路」旁的城市（在地圖上為由左至右）</li>
<li>當每個相鄰城市的距離得知時，我們可以計算出任兩個城市之間的距離<ul>
<li>舉例來說，依序給定四個城市（A、B、C、D）與每個相鄰城市的距離：<ul>
<li>A 與 B 距離 &#x3D; 1</li>
<li>B 與 C 距離 &#x3D; 2</li>
<li>C 與 D 距離 &#x3D; 4</li>
</ul>
</li>
<li>則我們可以計算出其距離矩陣</li>
</ul>
</li>
<li>在此問題中要考慮的是「逆向工程問題」<ul>
<li>給定任兩個城市之間的距離（未給出是哪兩個城市，只知道距離資訊），欲將原始相鄰城市的距離求出</li>
<li>假設知道 N 個城市與城市的距離，也就是說會給定一串大小為 $\frac{N(N-1)}{2}$ 且無序的數字數列</li>
<li>為了方便計算，讓最左邊的城市當作第一個城市最右邊的城市為最後一個城市</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>Which of the following is false?</strong></p>
<ol>
<li>The largest value must be the distance of <strong>the first city and last city along the highway</strong></li>
<li>It can be solved by <strong>searching</strong></li>
<li>If the input has an answer, <strong>then it is unique</strong></li>
<li>The second largest value can be the distance of the first city and second to the last city along the highway</li>
<li>The second largest value can be the distance of <strong>the second city and the last city along the highway</strong></li>
</ol>
<p><strong>Ans: (3)</strong></p>
<p><strong>Suppose there are 6 cities and the distance between each pair of the cities are: 9, 8, 8, 7, 6, 6, 5, 5, 3, 3, 3, 2, 2, 1, 1. Which of the following is correct ?</strong></p>
<ol>
<li>There is no solution for this input</li>
<li>The distance of the second city and the third city is 3</li>
<li>The distance of the fourth city and the fifth city is 1</li>
<li>The distance of the third city and the fourth city is 3</li>
<li>The distance of the second city and the third city is 8</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>2</td>
<td>5</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>Ans: (4)</strong></p>
<!-- Example（105 成功大學資料結構與演算法） -->

<p>（參考：<a target="_blank" rel="noopener" href="http://cs.jhu.edu/~cs363/fall2013/assign8_sln.pdf">600.363&#x2F;463 Algorithms - Fall 2013 Solution to Assignment 8 - JHU CS</a>、<a target="_blank" rel="noopener" href="https://www.ptt.cc/bbs/Grad-ProbAsk/M.1550727264.A.BB0.html">105成大資演第7題</a>）</p>
<ul>
<li>We are given a direct graph G&#x3D;(V,E) on which each edge (u,v)∈E has an associated value <strong>r(u,v), which is a read number in the range 0≦r(u,v)≦1 that represents the reliability of a communication channel from u to v</strong></li>
<li>We interpret r(u,v) as <strong>the probabilities that the channel from u to v will not fail</strong>, and we assume that these probabilities are independent</li>
<li>Given an efficient algorithm to find the most reliability path between two given vertices</li>
</ul>
<blockquote>
<p>欲找到自 u 至 v 最可靠的路徑，最大化其路徑上的成功傳送機率乘積</p>
<ul>
<li>令 s 為起點、 t 為終點<ul>
<li>p&#x3D;($v_0, v_1, \ldots, v_k$)<ul>
<li>$v_0 &#x3D; s, v_k &#x3D; t$</li>
</ul>
</li>
<li>p&#x3D;argument path, $max(\prod_{i &#x3D; 0}^k r(v_{i-1},v_i))$</li>
</ul>
</li>
<li>將其問題轉換成「Single source shortest path problem」<ul>
<li><strong>轉換權重</strong><ul>
<li>用對數含函數轉換<ul>
<li>$\Rightarrow \log r(u,v)$</li>
<li>連乘轉換為連加<ul>
<li>$max(\sum_{i &#x3D; 0}^k r(v_{i-1},v_i))​$</li>
</ul>
</li>
<li><strong>對數函數不改變權重單調性</strong><ul>
<li><a href="%5Cwillywangkaa%5C2018%5C12%5C02%5CData-structure-graph#johnsons-algorithm">單調性改變範例 - Johnson’s algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li>轉換為「最短路徑問題」<ul>
<li><strong>取其負值將最大路徑問題轉換為最小路徑問題</strong></li>
<li>$\Rightarrow w(u,v) &#x3D; -\log r(u,v)$<ul>
<li>$min(\sum_{i &#x3D; 0}^k w(v_{i-1},v_i))$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>以「Dijkstra’s algorithm」解決轉換後的問題</strong><ul>
<li>p&#x3D;argument path, $min(\sum_{i &#x3D; 0}^k w(v_{i-1},v_i))$</li>
<li>時間複雜度：O(∣V∣log∣V∣+∣E∣)</li>
</ul>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-Z/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/Algorithm-Z/" class="post-title-link" itemprop="url">Algorithm - Z 演算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:38:51 / Modified: 04:40:41" itemprop="dateCreated datePublished" datetime="2023-02-17T04:38:51+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- title: Algorithm - Z 演算法
author: Willy Wang

date: 2018-03-19 13:27:00
--- -->
<h1 id="Z-演算法"><a href="#Z-演算法" class="headerlink" title="Z 演算法"></a>Z 演算法</h1><p>可以線性時間在一段<strong>文本（Text）</strong> 裡面找到所有我們欲求的<strong>段落（Pattern）</strong></p>
<ul>
<li>文本（Text）的長度為 $n$ </li>
<li>段落（Pattern）為 $m$</li>
</ul>
<p>搜尋過程需要線性等級的時間複雜度：$O(m+n)$</p>
<blockquote>
<p>雖然這個演算法需要的空間（Space complexity）與時間複雜度（Time complexity）都與<strong>KMP algorithm</strong>一致，但是這個演算法比起「KMP algorithm」還要容易了解</p>
<p>KMP algorithm：每個前綴與其後綴的次長共同前綴（最長的後綴）<br>Z algorithm：每個後綴與母字串的最長共同前綴（單純的長度）</p>
<p>首先，我們需要一個 $Z$陣列（$Z$ array）</p>
</blockquote>
<h2 id="Z-陣列"><a href="#Z-陣列" class="headerlink" title="$Z$ 陣列"></a>$Z$ 陣列</h2><p>當我們將欲檢索的文本存為一個字串 $ str[0 \ldots n-1] $ 時，同時也建立一個與字串一樣長的$Z$陣列。<br>在$Z$陣列中，第 $i$ 元素紀錄「**最長共同前總和 (Longest Common Prefix)**的長度」，而 <em>LCP 的長度</em> 是由「從 $i$ 開始的後總和 (Postfix)」與「該文本」共同決定。<br>( **注意： ** $Z[0]$ <strong>毫無意義可言，因為從第0個開始的後總和(Postfix) 必與原本的文本字串相同。</strong> )</p>
<!-- 大致上我們可以看成如下的函式： -->

<!-- ![Z演算法的表示法](\willywangkaa\images\Z演算法的表示法.png) -->

<p>$Ex.$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Index            0   1   2   3   4   5   6   7   8   9  10  11 </span><br><span class="line">Text             a   a   b   c   a   a   b   x   a   a   a   z</span><br><span class="line">Z values             1   0   0   3   1   0   0   2   2   1   0 </span><br></pre></td></tr></table></figure>
<p>$More$ $ex.$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str  = &quot;aaaaaa&quot;</span><br><span class="line">Z[]  = &#123;x, 5, 4, 3, 2, 1&#125;</span><br><span class="line"></span><br><span class="line">str = &quot;aabaacd&quot;</span><br><span class="line">Z[] = &#123;x, 1, 0, 2, 1, 0, 0&#125;</span><br><span class="line"></span><br><span class="line">str = &quot;abababab&quot;</span><br><span class="line">Z[] = &#123;x, 0, 6, 0, 4, 0, 2, 0&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Z-陣列如何幫助演算法加速"><a href="#Z-陣列如何幫助演算法加速" class="headerlink" title="$Z$ 陣列如何幫助演算法加速?"></a>$Z$ 陣列如何幫助演算法加速?</h2><p>這個演算法的想法是將段落(pattern)與文本字串(text string)連接起來，若視段落(pattern)為「P」，視文本字串(text string)為「T」，並加上一個從未在段落與文本中出現過的<em>字元</em>「\$」再產生出如「P$T」的字串。</p>
<p>最後，我們再產生一個屬於「P$T」的 Z陣列，在 Z陣列之中，若該 Z值等於段落(pattern)的長度，段落出現在該處。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Pattern P = &quot;aab&quot;,  Text T = &quot;baabaa&quot;</span><br><span class="line"></span><br><span class="line">The concatenated string is</span><br><span class="line">&quot;a, a, b, $, b, a, a ,b ,a, a&quot;.</span><br><span class="line">Z array for above concatenated string is </span><br><span class="line">&#123;x, 1, 0, 0, 0, 3, 1, 0, 2, 1&#125;.</span><br><span class="line">                ^</span><br><span class="line">Since length of pattern is 3, the value 3 in Z array </span><br><span class="line">indicates presence of pattern.</span><br></pre></td></tr></table></figure>



<h2 id="如何建立-Z-陣列"><a href="#如何建立-Z-陣列" class="headerlink" title="如何建立 $Z$陣列"></a>如何建立 $Z$陣列</h2><p>最簡單的就是使用兩個迴圈，外層迴圈將整個「P$T」跑過一遍，內層迴圈則是看看到底 i 位置的<strong>後總和</strong>與「P$T」的LCP長度為何。<br>$Time$ $complexity:$<br>$$O(n^2)$$</p>
<p>我們當然可以使用另一種方法讓建立陣列的時間複雜度降低。<br>此演算法的關鍵在於要維護一個區間$[L \ldots R]$，$R$ 的位置代表由 $L$ 處之後可以和整個字串最長的<strong>前總和</strong>重疊到的最後一個位置( 換句話說：$[L \ldots R]$是整個字串的<strong>前綴子字串</strong> )，若完全不重疊，則 $L$ 與 $R$相等。</p>
<ul>
<li>步驟 ($i$ 為當前位置)</li>
</ul>
<ol>
<li>若 $i &gt; R$ ，就代表當前 $i$ 沒有經過任何<strong>「P$S」的前綴子字串</strong>，所以重置 $L$ 與 $R$ 的位置($L &#x3D; i, R &#x3D; i$)，經由比對<strong>「P$S」的前綴</strong>與 <strong>$i$ 之後的前綴</strong>，並找出最長的子字串($R$ 的位置)，計算新的 $L$ 與 $R$ 的位置，也一併將 $Z[i]$值算出來($&#x3D; R - L + 1$)。</li>
<li>若 $i \leq R$ ，令 $K &#x3D; i - L$ ，再來我們知道 $Z[i] \geq  min(Z[K], R-i+1)$ 因為$String[i \ldots]$與$String[K\ldots]$共同前$R-i+1$個字元必然為[P$T]的<strong>前綴子字串</strong>。現在有兩種情形會發生：</li>
</ol>
<ul>
<li>case1：<br>若$Z[K] &lt; R-i+1$ ，代表沒有任何<strong>「P$S」的前綴子字串</strong> 從 $i$ 位置開始(否則 $Z[K]$ 的值會更大)，所以也意味著$Z[i] &#x3D; Z[K]$，還有區間$[L\ldots R]$不變。</li>
<li>case2：<br>若$Z[K] \geq R-i+1$，代表$String[i \ldots]$可以和$String[0\ldots]$ 繼續比對相同的字元，也就意味有可能拓展$[L \ldots R]$ 區間，因此，我們會設 $L &#x3D; i$ ，接著從 $R$ 之後開始繼續比對<strong>「P$S」的前綴子字串</strong>，最後我們會得到新的$R$，並更新$[L \ldots R]$ 區間與計算 $Z[i]$ $( &#x3D; R - L + 1)$。</li>
</ul>
<p>想要了解上述的演算法可以經由這個連結觀看<a target="_blank" rel="noopener" href="http://www.utdallas.edu/~besp/demo/John2010/z-algorithm.htm">動畫</a>。</p>
<p><strong>小視窗</strong></p>
<!-- ![Z演算法的子問題](\willywangkaa\images\Z演算法的子問題.png) -->

<p>如果一個位置 $i$ 位於之前比過的那段 $[L, R]$ 當中，他是否跟 $Z[i − L]$ 相同呢？我們可以分成三種情形：</p>
<ol>
<li>要比的後綴根本不在以前比過的範圍$[L, R]$內     → 就去比吧！</li>
<li>要比的後綴在以前比過的範圍$[L, R]$但長度未知 → 還是去比吧！</li>
<li>要比的後綴在以前比過的範圍$[L, R]$但長度已知 → 直接記錄囉！</li>
</ol>
<h1 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h1><hr>
<h2 id="台大資工PPT-by-nkng"><a href="#台大資工PPT-by-nkng" class="headerlink" title="台大資工PPT by nkng"></a><a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~sprout/algo2016/ppt_pdf/Z_value.pdf">台大資工PPT by nkng</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">z_build</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">int</span> *Z)</span> </span>&#123;</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; S[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[bst] + bst &lt; i) Z[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> Z[i] = <span class="built_in">min</span>(Z[bst]+bst-i, Z[i-bst]);</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]] == S[i+Z[i]]) Z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] + i &gt; Z[bst] + bst) bst = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z-algorithm-GeeksforGeeks"><a href="#Z-algorithm-GeeksforGeeks" class="headerlink" title="Z algorithm - GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/">Z algorithm - GeeksforGeeks</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C++ program that implements Z algorithm for pattern searching</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getZarr</span><span class="params">(string str, <span class="type">int</span> Z[])</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  prints all occurrences of pattern in text using Z algo</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create concatenated string &quot;P$T&quot;</span></span><br><span class="line">    string concat = pattern + <span class="string">&quot;$&quot;</span> + text;</span><br><span class="line">    <span class="type">int</span> l = concat.<span class="built_in">length</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Construct Z array</span></span><br><span class="line">    <span class="type">int</span> Z[l];</span><br><span class="line">    <span class="built_in">getZarr</span>(concat, Z);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//  now looping through Z array for matching condition</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if Z[i] (matched region) is equal to pattern</span></span><br><span class="line">        <span class="comment">// length  we got the pattern</span></span><br><span class="line">        <span class="keyword">if</span> (Z[i] == pattern.<span class="built_in">length</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span></span><br><span class="line">                 &lt;&lt;  i - pattern.<span class="built_in">length</span>() <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  Fills Z array for given string str[]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getZarr</span><span class="params">(string str, <span class="type">int</span> Z[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> L, R, k;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// [L,R] make a window which matches with prefix of s</span></span><br><span class="line">    L = R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if i&gt;R nothing matches so we will calculate.</span></span><br><span class="line">        <span class="comment">// Z[i] using naive way.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            L = R = i;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// R-L = 0 in starting, so it will start</span></span><br><span class="line">            <span class="comment">// checking from 0&#x27;th index. For example,</span></span><br><span class="line">            <span class="comment">// for &quot;ababab&quot; and i = 1, the value of R</span></span><br><span class="line">            <span class="comment">// remains 0 and Z[i] becomes 0. For string</span></span><br><span class="line">            <span class="comment">// &quot;aaaaaa&quot; and i = 1, Z[i] and R become 5</span></span><br><span class="line">            <span class="keyword">while</span> (R&lt;n &amp;&amp; str[R-L] == str[R])</span><br><span class="line">                R++;</span><br><span class="line">            Z[i] = R-L;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// k = i-L so k corresponds to number which</span></span><br><span class="line">            <span class="comment">// matches in [L,R] interval.</span></span><br><span class="line">            k = i-L;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// if Z[k] is less than remaining interval</span></span><br><span class="line">            <span class="comment">// then Z[i] will be equal to Z[k].</span></span><br><span class="line">            <span class="comment">// For example, str = &quot;ababab&quot;, i = 3, R = 5</span></span><br><span class="line">            <span class="comment">// and L = 2</span></span><br><span class="line">            <span class="keyword">if</span> (Z[k] &lt; R-i+<span class="number">1</span>)</span><br><span class="line">                 Z[i] = Z[k];</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// For example str = &quot;aaaaaa&quot; and i = 2, R is 5,</span></span><br><span class="line">            <span class="comment">// L is 0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  else start from R  and check manually</span></span><br><span class="line">                L = i;</span><br><span class="line">                <span class="keyword">while</span> (R&lt;n &amp;&amp; str[R-L] == str[R])</span><br><span class="line">                    R++;</span><br><span class="line">                Z[i] = R-L;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;GEEKS FOR GEEKS&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;GEEK&quot;</span>;</span><br><span class="line">    <span class="built_in">search</span>(text, pattern);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建國中學-2012-年資訊能力競賽培訓講義-08"><a href="#建國中學-2012-年資訊能力競賽培訓講義-08" class="headerlink" title="建國中學 2012 年資訊能力競賽培訓講義 - 08"></a><a target="_blank" rel="noopener" href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=fab7c1879e544bcefffb4b8717f2747436e1c425c">建國中學 2012 年資訊能力競賽培訓講義 - 08</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z_maker</span><span class="params">( <span class="type">int</span> z[], <span class="type">char</span> s[], <span class="type">int</span> n )</span></span>&#123;</span><br><span class="line">    z[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="type">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, i, x;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( R &lt; i || z[i-L] &gt;= R-i+<span class="number">1</span> )&#123;</span><br><span class="line">            R &lt; i ? x = i : x = R+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( x &lt; n &amp;&amp; s[x] == s[x-i] ) x++;</span><br><span class="line">            z[i] = x-i; <span class="keyword">if</span>( i &lt; x )&#123; L = i; R = x<span class="number">-1</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> z[i] = z[i-L];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z-algorithm-codeforces"><a href="#Z-algorithm-codeforces" class="headerlink" title="Z algorithm - codeforces"></a><a target="_blank" rel="noopener" href="http://codeforces.com/willywangkaa/entry/3107">Z algorithm - codeforces</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; R) &#123;</span><br><span class="line">    L = R = i;</span><br><span class="line">    <span class="keyword">while</span> (R &lt; n &amp;&amp; s[R-L] == s[R]) R++;</span><br><span class="line">    z[i] = R-L; R--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = i-L;</span><br><span class="line">    <span class="keyword">if</span> (z[k] &lt; R-i+<span class="number">1</span>) z[i] = z[k];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      L = i;</span><br><span class="line">      <span class="keyword">while</span> (R &lt; n &amp;&amp; s[R-L] == s[R]) R++;</span><br><span class="line">      z[i] = R-L; R--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z-algorithm1-日月卦長的模板庫"><a href="#Z-algorithm1-日月卦長的模板庫" class="headerlink" title="Z algorithm1 - 日月卦長的模板庫"></a><a target="_blank" rel="noopener" href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm1 - 日月卦長的模板庫</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">z_alg1</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len,<span class="type">int</span> *z)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	z[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">		z[i]=r&gt;i?<span class="built_in">min</span>(r-i+<span class="number">1</span>,z[z[l]-(r-i+<span class="number">1</span>)]):<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i+z[i]&lt;len&amp;&amp;s[z[i]]==s[i+z[i]])++z[i];</span><br><span class="line">		<span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)r=i+z[i]<span class="number">-1</span>,l=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z-algorithm2-日月卦長的模板庫"><a href="#Z-algorithm2-日月卦長的模板庫" class="headerlink" title="Z algorithm2 - 日月卦長的模板庫"></a><a target="_blank" rel="noopener" href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm2 - 日月卦長的模板庫</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">z_alg2</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len,<span class="type">int</span> *z)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	z[<span class="number">0</span>]=len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">		z[i]=i&gt;r?<span class="number">0</span>:(i-l+z[i-l]&lt;z[l]?z[i-l]:r-i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(i+z[i]&lt;len&amp;&amp;s[i+z[i]]==s[z[i]])++z[i];</span><br><span class="line">		<span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)r=i+z[i]<span class="number">-1</span>,l=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="培訓-4-字串-tioj"><a href="#培訓-4-字串-tioj" class="headerlink" title="培訓-4 字串- tioj"></a><a target="_blank" rel="noopener" href="https://tioj.infor.org/uploads/attachment/11/43/4.pdf">培訓-4 字串- tioj</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">z_build</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* S,<span class="type">int</span> *z)</span></span>&#123;</span><br><span class="line">    z[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(z[bst]+bst&lt;i) z[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> z[i]=std::<span class="built_in">min</span>(z[bst]+bst−i,z[i−bst]);</span><br><span class="line">        <span class="keyword">while</span>(S[z[i]]==S[i+z[i]]) z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(z[i]+i&gt;z[bst]+bst) bst=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h1><hr>
<p><a target="_blank" rel="noopener" href="http://codingbeans.blogspot.tw/2016/03/tioj-1725z-algorithm-massacre-at-camp.html">TIOJ 1725_Z algorithm_Massacre at Camp Happy</a></p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><hr>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/">Z algorithm - GeeksforGeeks</a></p>
<p><a target="_blank" rel="noopener" href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=fab7c1879e544bcefffb4b8717f2747436e1c425c">建國中學 2012 年資訊能力競賽培訓講義 - 08</a></p>
<p><a target="_blank" rel="noopener" href="https://tioj.infor.org/uploads/attachment/11/43/4.pdf">培訓-4 字串- tioj</a></p>
<p><a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~sprout/algo2016/ppt_pdf/Z_value.pdf">台大資工講義 by nkng</a></p>
<p><a target="_blank" rel="noopener" href="http://codeforces.com/willywangkaa/entry/3107">Z algorithm - codeforces</a></p>
<p><a target="_blank" rel="noopener" href="http://momo-funnycodes.blogspot.tw/2012/07/gusfield-algorithm.html">Gusfield algorithm - momo funny codes</a></p>
<p><a target="_blank" rel="noopener" href="http://sunmoon-template.blogspot.tw/2015/05/z-algorithm-linear-time-pattern.html">Z algorithm - 日月卦長的模板庫</a></p>
<h1 id="待補充"><a href="#待補充" class="headerlink" title="待補充"></a>待補充</h1><!-- --- -->
<!-- 
## KMP 字串比對演算法

http://mropengate.blogspot.tw/2016/01/leetcode-kmpimplement-strstr.html -->


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-DynamicProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/Algorithm-DynamicProgramming/" class="post-title-link" itemprop="url">Algorithm - DynamicProgramming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:30:45 / Modified: 04:54:07" itemprop="dateCreated datePublished" datetime="2023-02-17T04:30:45+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- title: Algorithm - Dynamic programming -->
<!-- author: Willy Wang (willywangkaa) -->
<!-- date: 2018-09-23 10:46:21
tags: -->

<h1 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h1><p>將已<strong>計算的結果</strong>記錄在<strong>表格中</strong>的技巧，目的是為了要避免<strong>重複計算相同子問題</strong>，以<strong>「Button up」</strong>的方式實踐。</p>
<ul>
<li>為何要使用這種方法，以<strong>費氏數列程式</strong>開始討論。</li>
</ul>
<p>$$<br>F_n &#x3D; \left{\begin{matrix}<br>0 &amp; , if ; n &#x3D; 0\<br>1 &amp; , if ; n &#x3D; 1\<br>F_{n-1} + F_{n-2} &amp; , if ; n \geq 2<br>\end{matrix}\right.<br>$$</p>
<p>欲求出 $F_5$ ，以遞迴程式執行，會造成「Overlapping subproblem」，如下圖 $F_2$ 重複計算了 3 次，$F_3$ 重複計算 2 次。</p>
<!-- ![overlappingsubproblem](\willywangkaa\images\overlappingsubproblem.png) -->



<!-- 使用動態表格執行之，可以省去很多不必要的重複計算，如下圖。



![fibonassidp](\willywangkaa\images\fibonassidp.png) -->


<!-- 
- 構思動態規劃題目的流程
  - Optimal substructure：一個**母問題的最佳解**如何由**其子問題的最佳**解構成。



![observedp](\willywangkaa\images\observedp.png) -->



<h2 id="Shortest-path-problem"><a href="#Shortest-path-problem" class="headerlink" title="Shortest path problem"></a>Shortest path problem</h2><ul>
<li><strong>Optimal substructure</strong></li>
</ul>
<!-- ![shortestpathproblem_subproblem](\willywangkaa\images\shortestpathproblem_subproblem.png) -->



<!-- > 問 longest path problem 有無 optimal substructure。
>
>  無，所以不可以使用動態規劃解此問題。 -->
<blockquote>
</blockquote>
<!-- ![longestpathproblem](\willywangkaa\images\longestpathproblem.png) -->
<blockquote>
</blockquote>
<!-- > **但是**如果此圖加上「Acyclic」、「Direct」等條件限制之後，可以用動態規劃解「longest path problem」。 -->



<blockquote>
<p>通常要在各種條件之下都可以使用<strong>動態規劃解此問題</strong>，才可以<strong>宣稱此問題可以使用動態規劃解</strong>。</p>
</blockquote>
<!-- - Ex (99 交大) -->
<ul>
<li>下列何者<strong>正確</strong>？<ul>
<li>（a）Dynamic programming always provides polynominal time algorithm.</li>
<li>（b）Huffman coding for compresion is a typical dynamic programming algorithm.</li>
<li>（c）Dynamic programming use the table to design the algorithm.</li>
<li>（d）Optimal is a important element in the dynamic programming.</li>
<li>（e）<strong>Single source all shortest path problem</strong> has optimal substructure.</li>
</ul>
</li>
<li>Ans<ul>
<li>（a）：false。反例為 Subset-sum problem (暴力法：$O(2^n)、動態規劃法：$$O(n2^{\frac n2})$)</li>
<li>（b）：false。為典型的 Greedy algorithm。</li>
<li><strong>（c）</strong></li>
<li><strong>（d）</strong></li>
<li><strong>（e）</strong></li>
</ul>
</li>
</ul>
<h2 id="Knapsack-problem"><a href="#Knapsack-problem" class="headerlink" title="Knapsack problem"></a>Knapsack problem</h2><h3 id="Fractional-knapsack-problem"><a href="#Fractional-knapsack-problem" class="headerlink" title="Fractional knapsack problem"></a>Fractional knapsack problem</h3><blockquote>
<ol>
<li>此方法僅限於物品重量為正整數時</li>
<li>0&#x2F;1 KP 為 NP - Completed 問題</li>
</ol>
</blockquote>
<ul>
<li><p>Input：</p>
<ul>
<li>n 個物件<ul>
<li>第 i 個重量為 $w_i$ ，價值為 $v_i$。</li>
</ul>
</li>
<li>背包最大負重<ul>
<li>$W$</li>
</ul>
</li>
</ul>
</li>
<li><p>Output：</p>
<ul>
<li>最大的獲利值</li>
</ul>
</li>
<li><p>限制條件：</p>
<ul>
<li>取得物品的總重量 $\leq$ W</li>
<li>可取物品的<strong>部分</strong></li>
</ul>
</li>
<li><p>想法</p>
<ul>
<li><strong>Greedy</strong>：從目前 $\frac{v_i}{w_i}$ 最高的物品開始拿取，直到物品取完，或是取得物品負重已達 W。</li>
</ul>
</li>
<li><p>Time Complexity</p>
<ul>
<li>$\Theta(n\log n)$</li>
</ul>
</li>
<li><p>Ex ( W &#x3D; 5 )</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Item</th>
<th>$v_i$</th>
<th>$w_i$</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>12</td>
<td>3</td>
</tr>
</tbody></table>
<p>$$<br>\frac{v_2}{w_2} &#x3D; 6 \geq \frac{v_1}{w_1} &#x3D; 5 \geq \frac{v_3}{w_3} &#x3D; 4<br>$$</p>
<ol>
<li>取物品 2，取該物品之 1 單位重量，背包剩餘空間 4 單位重量，獲利 6 單位價值。</li>
<li>取物品 1，取物品之 2 單位重量，背包剩餘空間 2 單位重量，獲利 16 單位價值。</li>
<li>取物品 3，取物品之 2 單位重量，背包剩餘空間 0 單位重量，<strong>獲利 24 單位價值</strong>。</li>
</ol>
<!-- ![kpdp](\willywangkaa\images\kpdp.png) -->



<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>18</td>
<td><strong>22</strong></td>
</tr>
</tbody></table>
<!-- - Ex ( 98 交大 ) P.3-66 ex10 -->
<ul>
<li>Maximize $\sum_{i &#x3D; 1}^n v_ix_i ;  subject; to \sum_{i &#x3D; 1}^n w_ix_i \leq W, 0 \leq x_i \leq 1$ </li>
<li>Greedy choise property ( $\frac{v_1}{w_1} \geq \frac{v_2}{w_2} \geq\ldots$ )</li>
<li>最佳解的 $x_1$ 需取多少。</li>
</ul>
<p>$$<br>x_n &#x3D; \left{\begin{matrix}<br>1 &amp; , if ; w_1 \leq W \<br>\frac{W}{w_1} &amp; , if ; w1 &gt; W \<br>\end{matrix}\right.<br>$$</p>
<h3 id="0-1-Knapsack-problem"><a href="#0-1-Knapsack-problem" class="headerlink" title="0-1 Knapsack problem"></a>0-1 Knapsack problem</h3><ul>
<li><p>Input：</p>
<ul>
<li>n 個物件<ul>
<li>第 i 個重量為 $w_i$ ，價值為 $v_i$。</li>
</ul>
</li>
<li>背包最大負重<ul>
<li>$W$</li>
</ul>
</li>
</ul>
</li>
<li><p>Output：</p>
<ul>
<li>最大的獲利值</li>
</ul>
</li>
<li><p>限制條件：</p>
<ul>
<li>取得物品的總重量 $\leq$ W</li>
<li>只能取物品的<strong>整體</strong></li>
</ul>
</li>
<li><p>想法</p>
<ul>
<li><p>無法使用 Greedy method 解決</p>
</li>
<li><p><strong>使用動態規劃解決，物品的重量必為正整數</strong></p>
<ul>
<li>遞迴結構：(令 $C[i][k]$ 在負重 k 之下考慮物品 1 … i 之最大獲利</li>
</ul>
<p>$$<br>C[i][k] &#x3D; \left{\begin{matrix}<br>0 &amp; , if ;i &#x3D; 0;OR; k &#x3D; 0 \<br>max(C[i-1][k-w_i]+v_i, C[i-1][k] )&amp; , if ; w_i \leq k \<br>C[i-1][k] &amp; , if ; w_i &gt; k \<br>\end{matrix}\right.<br>$$</p>
</li>
</ul>
</li>
<li><p>Algorithm ( Bottom up )</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for k &lt;- 0 to w</span><br><span class="line">	c[0, k] &lt;- 0</span><br><span class="line">for i &lt;- 1 to n</span><br><span class="line">&#123;</span><br><span class="line">    c[i, 0] &lt;- 0</span><br><span class="line">    for k &lt;- 1 to w</span><br><span class="line">    &#123;</span><br><span class="line">        if k &lt; w_i</span><br><span class="line">        	c[i, k] &lt;- c[i-1, k]</span><br><span class="line">        else</span><br><span class="line">        	c[i, k] &lt;- max(c[i-1, k], c[i-1, k-w_i]+v_i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Time complexity<ul>
<li>$\Theta( nW )$  <strong>Pseudo-polynominal</strong></li>
</ul>
</li>
<li>Space complexity<ul>
<li>$\Theta( nW )$</li>
</ul>
</li>
</ul>
<h3 id="Branch-and-bound-解-0-1-Knapsack-problem"><a href="#Branch-and-bound-解-0-1-Knapsack-problem" class="headerlink" title="Branch and bound 解 0-1 Knapsack problem"></a>Branch and bound 解 0-1 Knapsack problem</h3><blockquote>
<ul>
<li>對於一個 NP-Completed 問題來說，可以使用「Branch and bound」來解決</li>
<li>「Branch and bound」演算法中，<strong>「Bounding function」</strong>的設計會是影響整體效能最大的關鍵 ( 收斂快慢 )。</li>
<li>Time complexity：O( 葉節點個數 )<ul>
<li>葉節點個數取決問題本身。<ul>
<li>組合性問題：$2^n$ </li>
<li>排列性問題：$n!$</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>將球最佳解的過程視為在一個「State space tree」中尋找最好的節點。</p>
</li>
<li><p>實務上，通常是設計一 個<strong>「Bounding function」</strong>以估計目前狀態可到最佳解的可能性。</p>
<ul>
<li>建構「State space tree」時，每次都先<strong>展開「Bounding function」的節點。( Branch )</strong></li>
<li>在每次展開的過程中，都可以得到一個<strong>目前最佳解 (葉節點)，接著，之後不展開「Bounding function 值</strong> $\leq$ <strong>目前最佳解」</strong>的內部節點。**( Bound )**</li>
</ul>
</li>
<li><p>以 Branch and bound 解 0-1 Knapsack problem</p>
<ul>
<li>每個節點須紀錄<ul>
<li><strong>目前的獲利</strong></li>
<li><strong>目前的負重</strong></li>
<li><strong>「Bounding function」算出的值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>為了計算「Bounding funciton」括號中要估計「Fractional knapsack」的未來最大值，需要將物品依照 $\frac{v_i}{w_i}$ 排序。</li>
</ol>
<p>$w  &#x3D; 4$ </p>
<table>
<thead>
<tr>
<th>Item</th>
<th>$v_i$</th>
<th>$w_i$</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>12</td>
<td>3</td>
</tr>
</tbody></table>
<p>$$<br>\frac{v_2}{w_2} &#x3D; 6 \geq \frac{v_1}{w_1} &#x3D; 5 \geq \frac{v_3}{w_3} &#x3D; 4<br>$$</p>
<ol start="2">
<li><strong>設計「Bounding function」。(括號部分就是用來估計以目前節點拓展，獲利的上限)</strong></li>
</ol>
<p>$$<br>Bounding ;funciotn(目前的節點)\<br>&#x3D; 在「目前的節點」上可得的獲利 + \<br>(將背包剩餘的重量以「Fractional ;knapsack ;problem」拿取剩下的物品的獲利)<br>$$</p>
<!-- ![KPstatesearchtree](\willywangkaa\images\KPstatesearchtree.png) -->



<ol start="3">
<li>拓展節點<ol>
<li>展開 <strong>Root</strong></li>
<li>因為該節點「Bounding function」最大，所以展開 <strong>A</strong></li>
<li>展開節點 <strong>C</strong></li>
<li><strong>E</strong> 節點因為超重所以為「Infeasiable solution」</li>
<li><strong>F</strong> 為一可能解，使 $Max &#x3D; 16$</li>
<li>因為節點 <strong>D</strong> 在樹中較深處，先展開之</li>
<li><strong>G</strong> 與 <strong>H</strong> 均為一解，設 $Max &#x3D; 18$ </li>
<li>因為節點 <strong>B</strong> 的「Bounding function」$\leq$ <strong>Max</strong>，不展開該節點</li>
</ol>
</li>
<li>Ans：18 ( 取<strong>物品一</strong>與<strong>物品三</strong> )</li>
</ol>
<h2 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h2><ul>
<li>Sequence<ul>
<li>X &#x3D; ＜a, b, c, a＞</li>
</ul>
</li>
<li>Subsequence<ul>
<li>＜a, c＞ 為 X 的「Subsequence」</li>
</ul>
</li>
<li>Prefix ( 前綴 )<ul>
<li>$X_3 &#x3D; ＜a, b, c＞$</li>
</ul>
</li>
<li>Common subsequence<ul>
<li>Y &#x3D; ＜a, c, b, c＞</li>
<li>則＜a, c＞為 X 與 Y 的「Common subsequence」</li>
</ul>
</li>
<li>Longest common subsequence<ul>
<li>＜a, b, c＞ 為 X 與 Y 的「LCS」</li>
</ul>
</li>
</ul>
<blockquote>
<p>「LCS」不一定唯一</p>
</blockquote>
<ul>
<li>遞迴結構<ul>
<li>令 $c[i , j]$ 為 $LCS(X_i, Y_j)$ 的長，則：</li>
</ul>
</li>
</ul>
<p>$$<br>c[i, j] &#x3D; \left{\begin{matrix}<br>0 &amp; , if ;i &#x3D; 0;OR; j &#x3D; 0 &amp; \<br>c[i-1, j-1] + 1 &amp; , if ; X[i] &#x3D; Y[j] &amp; \<br>max(c[i-1, j], c[i, j-1])&amp; , if ; X[i] \ne Y[j] ; &amp; （該兩個字絕對不會同時出現在LCS）<br>\end{matrix}\right.<br>$$</p>
<ul>
<li>演算法 ( Bottom-up )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for j &lt;- 0 to n</span><br><span class="line">	c[0, j] &lt;- 0</span><br><span class="line">for i &lt;- 0 to m</span><br><span class="line">	c[i, 0] &lt;- 0</span><br><span class="line">for i &lt;- 1 to m</span><br><span class="line">	for j &lt;- 1 to n</span><br><span class="line">	&#123;</span><br><span class="line">        if(X[i] = Y[i])</span><br><span class="line">        	c[i, j] = c[i-1, j-1] + 1</span><br><span class="line">        else</span><br><span class="line">        	c[i, j] = max(c[i-1, j], c[i, j-1])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>Time complexity</p>
<ul>
<li>$\Theta(mn)$</li>
</ul>
</li>
<li><p>Space complexity</p>
<ul>
<li>$\Theta(mn)$</li>
</ul>
</li>
<li><p>Ex</p>
<ul>
<li>X &#x3D; ＜a, b, a, c＞</li>
<li>Y &#x3D; ＜a, b, c, a＞</li>
<li>求「LCS」</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">“a”</th>
<th align="center">“b”</th>
<th align="center">“a”</th>
<th align="center">“c”</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-</strong></td>
<td align="center"><strong>-</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center"><strong>-</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>“a”</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center">0</td>
<td align="center">1（↖）</td>
<td align="center">1（←）</td>
<td align="center">1（↖）</td>
<td align="center">1（←）</td>
</tr>
<tr>
<td align="center"><strong>“b”</strong></td>
<td align="center"><strong>2</strong></td>
<td align="center">0</td>
<td align="center">1（↑）</td>
<td align="center">2（↖）</td>
<td align="center">2（←）</td>
<td align="center">2（←）</td>
</tr>
<tr>
<td align="center"><strong>“c”</strong></td>
<td align="center"><strong>3</strong></td>
<td align="center">0</td>
<td align="center">1（↑）</td>
<td align="center">2（↑）</td>
<td align="center">2（←）</td>
<td align="center">3（↖）</td>
</tr>
<tr>
<td align="center"><strong>“a”</strong></td>
<td align="center"><strong>4</strong></td>
<td align="center">0</td>
<td align="center">1（↖）</td>
<td align="center">2（↑）</td>
<td align="center">3（↖）</td>
<td align="center">3（←）</td>
</tr>
</tbody></table>
<h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><ul>
<li><p>Ex</p>
<ul>
<li>X &#x3D; ＜5, 1, 3, 2, 4＞</li>
<li>LIS(X) &#x3D; ＜1, 2, 4＞</li>
</ul>
</li>
<li><p>演算法</p>
<ol>
<li>Y &lt;- sort(X)</li>
<li>LCS(X, Y)</li>
</ol>
</li>
<li><p>Time complexity</p>
<ul>
<li>$\Theta(n^2)$<ul>
<li>排序：$\Theta(n\lg n)$</li>
<li>LCS：$\Theta(n^2)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Longest-Common-Substring"><a href="#Longest-Common-Substring" class="headerlink" title="Longest Common Substring"></a>Longest Common Substring</h3><ul>
<li>Ex<ul>
<li>X &#x3D; ＜a, b, a, c＞</li>
<li>Y &#x3D; ＜a, b, c, a＞</li>
<li><strong>Output：＜a, b＞</strong></li>
</ul>
</li>
</ul>
<p>$$<br>c[i, j] &#x3D; \left{\begin{matrix}<br>0 &amp; , if ;i &#x3D; 0;OR; j &#x3D; 0 &amp; \<br>c[i-1, j-1] + 1 &amp; , if ; X[i] &#x3D; Y[j] &amp; \<br>0&amp; , if ; X[i] \ne Y[j] ; &amp; （該兩個字絕對不會同時出現在LCS）<br>\end{matrix}\right.<br>$$</p>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// X[1...n]</span><br><span class="line">// Y[1...m]</span><br><span class="line">lcstring = &#123;&#125;</span><br><span class="line">length = 0</span><br><span class="line">// initialize</span><br><span class="line">for i &lt;- 0 to n</span><br><span class="line">    c[0, i] &lt;- 0</span><br><span class="line">for i &lt;- 0 to m</span><br><span class="line">    c[i, 0] &lt;- 0</span><br><span class="line"></span><br><span class="line">for i &lt;- 1 to m</span><br><span class="line">    for j &lt;- 1 to n &#123;</span><br><span class="line">        if(X[i] != Y[i])</span><br><span class="line">            c[i, j] = 0</span><br><span class="line">        else &#123;</span><br><span class="line">            c[i, j] = c[i-1, j-1] + 1</span><br><span class="line">            if(length &lt; c[i, j]) &#123;</span><br><span class="line">                length = c[i, j]</span><br><span class="line">                lcstring = X[(i-length+1)...i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="Matrix-Chain-Multiplication"><a href="#Matrix-Chain-Multiplication" class="headerlink" title="Matrix Chain Multiplication"></a>Matrix Chain Multiplication</h2><ul>
<li>Input：<ul>
<li><strong>n</strong> 個矩陣的<strong>大小 P[0 … n]</strong> ( 其中$A_i$ 的大小為 $P_{i-1}\times P_i$ )</li>
</ul>
</li>
<li>Output：<ul>
<li>算出 $A_1 \times A_2 \times \ldots \times A_n$ 所需最少的<strong>純量乘法數</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>n 個矩陣的「Matrix chain」有 $C_{n-1} &#x3D; \frac{1}{(n-1)+1}\binom{2(n-1)}{(n-1)}$ 相異種乘法可能，所以列出所有乘法順序需要<strong>指數時間</strong>。 </p>
</blockquote>
<ul>
<li>Ex. 給定三個矩陣的大小如下<ul>
<li>$A_1：10 \times 100$</li>
<li>$A_2：100 \times 5$</li>
<li>$A_3：5 \times 50$</li>
<li>求算出 $A_1 \times A_2 \times A_3$ 所需最少的純量乘法數。</li>
</ul>
</li>
</ul>
<blockquote>
<p>若每一個矩陣均為相同大小的「方陣」，改變乘法的順序無法影響所需的純量乘法數，只能使用<strong>「Strassen’s algorithm」以加速。</strong></p>
</blockquote>
<ul>
<li>遞迴結構<ul>
<li>令 m[i, j] 為算出 $A_i \times \ldots \times A_j$ 所需最少乘法數</li>
</ul>
</li>
</ul>
<p>$$<br>m[i, j] &#x3D; \left{\begin{matrix}<br>0 &amp; , if ;i \geq j\<br>MIN_{i\leq k \leq j-1}(m[i, k] + m[k+1, j] + P_i\times P_k \times P_j) &amp; , if ; i &lt; j<br>\end{matrix}\right.<br>$$</p>
<ul>
<li>演算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for i &lt;- 1 to n (「Matrix chain」長度為一)</span><br><span class="line">	m[i, i] &lt;- 0</span><br><span class="line">for l &lt;- 2 to n (「Matrix chain」長度為二以上)</span><br><span class="line">	for i &lt;- 1 to n-l+1 (起點)</span><br><span class="line">		&#123;</span><br><span class="line">            j &lt;- i+l-1 (終點)</span><br><span class="line">            m[i, j] &lt;- infinity</span><br><span class="line">            for k &lt;- i to j-1</span><br><span class="line">            &#123;</span><br><span class="line">            	tmp &lt;- m[i, k] + m[k+1, j] + P_i-1 * P_k * P_j</span><br><span class="line">                if tmp &lt; m[i, j]</span><br><span class="line">                	m[i, j] &lt;- tmp  (純量乘法數)</span><br><span class="line">                	s[i, j] &lt;- k    (切點)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>Time complexity</p>
<ul>
<li>$\Theta(n^3)$：$\sum_{l&#x3D;2}^n \sum_{i &#x3D; 1}^{n-l+1}\sum_{k &#x3D; i}^{i+l-2} 1$</li>
</ul>
</li>
<li><p>Space complexity</p>
<ul>
<li>$\Theta(n^2)$</li>
</ul>
</li>
<li><p>Ex</p>
<ul>
<li>$A_1：3 \times 3$</li>
<li>$A_2：3 \times 7$ </li>
<li>$A_3：7 \times 2$</li>
<li>$A_4：2 \times 9$</li>
<li>$A_5：9 \times 4$</li>
<li>算出 $A_1 \times A_2 \times \ldots \times A_5$ 最少的乘法數。</li>
</ul>
</li>
</ul>
<!-- ![matrixchaindp](\willywangkaa\images\matrixchaindp.png)





![martixchainproblem_2](\willywangkaa\images\martixchainproblem_2.png) -->





<table>
<thead>
<tr>
<th>m (乘法數)</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>63（←）</td>
<td>60（←）</td>
<td>114（↓）</td>
<td><strong>156</strong>（↓）</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>42（←）</td>
<td>96（↓）</td>
<td>138（↓）</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>126（←）</td>
<td>128（←）</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>72（←）</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>s (切點)</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
</tr>
</tbody></table>
<p>最少乘法數：156</p>
<p>最佳乘法順序：$(A_1\times (A_2 \times A_3)) \times (A_4 \times A_5)$</p>
<h1 id="補充例題"><a href="#補充例題" class="headerlink" title="補充例題"></a>補充例題</h1><!-- Example（107交通大學資料結構與演算法） -->

<ul>
<li>We define the maximum subarray of an array A to be the nonempty, contiguous subarray of A whose value have the largest sum</li>
<li>Fill in the blank (a), (b) in the following c++ function so that it returns value are placed in A[1], A[2], …, A[n-1]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        A[i] += A[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = A[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,  (a)  );</span><br><span class="line">        k = <span class="built_in">min</span>(k,      (b)  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考慮一個「Maximum subarray」為 A[x…y]</p>
<ul>
<li>A[x…y] &#x3D; A[1…y] - A[1…x]</li>
<li>若欲使 A[x…y] 最大化<ul>
<li>A[1…y] 必為最大</li>
<li>A[1…x] 必為最小</li>
</ul>
</li>
</ul>
<p>(a)：<code>A[i]-k</code></p>
<p>(b)：<code>A[i]</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/Algorithm-StringMatching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/Algorithm-StringMatching/" class="post-title-link" itemprop="url">Algorithm - StringMatching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 04:18:08 / Modified: 04:27:02" itemprop="dateCreated datePublished" datetime="2023-02-17T04:18:08+08:00">2023-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Algorithm-String-matching"><a href="#Algorithm-String-matching" class="headerlink" title="Algorithm - String matching"></a>Algorithm - String matching</h1><p>給兩個字串 T 和 P，找出 T 當中是否有一段字串正好是 P，並且找出其位置</p>
<blockquote>
<p>字串搜尋當中，通常將兩字串的象徵符號取做 T 和 P</p>
<ul>
<li>T 意指 Text</li>
<li>P 意指 Pattern</li>
</ul>
<p>可以想作是從長篇文字 T 之中搜索小段文字 P</p>
</blockquote>
<ul>
<li>若 P 在平移 s 個單位後（**T [s+1 … s+m] &#x3D; P [1 … m]**，0 ≦ s ≦ n-m）<ul>
<li>可以在 T 中該片段被找到<ul>
<li>稱為「合法平移」（Valid shift）</li>
</ul>
</li>
<li>無法在 T 中該片段被找到<ul>
<li>稱為「非法平移」（Invalid shift）</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- ![1549517694185](\willywangkaa\images\1549517694185.png) -->



<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Preprocessing time</th>
<th>Matching time</th>
</tr>
</thead>
<tbody><tr>
<td>Native</td>
<td>0</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr>
<td>Rabin-Karp</td>
<td>θ(∣P∣)</td>
<td>O( (∣T∣-∣P∣+1) ×∣P∣)</td>
</tr>
<tr>
<td>Morris-Pratt Automaton</td>
<td>O(∣P∣×∣Σ∣)</td>
<td>θ(∣T∣)</td>
</tr>
<tr>
<td>Knuth-Morris-Pratt</td>
<td>θ(∣P∣)</td>
<td>θ(∣T∣)</td>
</tr>
</tbody></table>
<h2 id="Naive-string-matching（窮舉法）"><a href="#Naive-string-matching（窮舉法）" class="headerlink" title="Naive string matching（窮舉法）"></a>Naive string matching（窮舉法）</h2><p>最直覺的算法</p>
<ol>
<li>挪動 P 以對準 T 的各個位置</li>
<li>逐一比對字元、判斷是否相等</li>
</ol>
<!-- Example

![1549518031466](\willywangkaa\images\1549518031466.png)

![1549518053082](\willywangkaa\images\1549518053082.png)

![1549518063746](\willywangkaa\images\1549518063746.png)
 -->
<!-- ![1549518076863](\willywangkaa\images\1549518076863.png) -->



<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nativestrinmatcher</span><span class="params">(string T,string P)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = P.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>時間複雜度</p>
<ul>
<li>O( (|T|-|P|+1)×|P| )<ul>
<li><strong>O( |T||P| )</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>空間複雜度</p>
<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h2 id="Rabin-Karp-演算法"><a href="#Rabin-Karp-演算法" class="headerlink" title="Rabin-Karp 演算法"></a>Rabin-Karp 演算法</h2><p>由 Michael O. Rabin 及 Richard M. Karp 在 1987 年發展利用<strong>雜湊作字串判斷</strong>，帶有數學味道的演算法</p>
<ul>
<li>一個長度為 m 的模板字串 P<ul>
<li>視為一個 d 進制（d &#x3D; ∣Σ∣）的數字 p</li>
<li>令 $t_s$ 為 T[s+1…s+m] 轉換後的結果</li>
</ul>
</li>
<li>問題轉換成「是否存在一個 k(0 ≤ k ≤ n − m)，使得 $p &#x3D; t_k$」</li>
</ul>
<blockquote>
<p>p &#x3D;  ∣Σ∣(P[m-1]+(∣Σ∣(P[m-2]+… (∣Σ∣(P[2]+∣Σ∣P[1]) …))) + P[m]</p>
<p>$\Rightarrow p &#x3D; ｜Σ｜^{m-1}P[1]+｜Σ｜^{m-2}P[2]+\ldots+｜Σ｜^{0}P[m]$</p>
<p>$t_{s+1} &#x3D; ｜Σ｜(t_s - ｜Σ｜^{m-1}T[s+1])+T[s+m+1]$</p>
</blockquote>
<p>Example</p>
<p>Σ &#x3D; ｛0, 1, …, 9｝，d &#x3D; ∣Σ∣ &#x3D; 10</p>
<ul>
<li>Pattern P[1…m]<ul>
<li>p 為對應的十進位數字</li>
</ul>
</li>
<li>Text T[1…n]<ul>
<li>$t_s$ 為<strong>長度為 m 子字串</strong>（T[s+1…s+m]，s &#x3D; 0, 1, …, n-m）中對應的十進位數字</li>
</ul>
</li>
<li>字串 ［3 1 4 1 5 2］<ul>
<li>轉換後為 314,152</li>
</ul>
</li>
</ul>
<blockquote>
<p>$t_{s+1}$ 與 $t_s$ 的關係</p>
<p>$t_{s+1} &#x3D; 10(t_s - 10^{m-1}T[s+1])+T[s+m+1]$</p>
<p>所以，上述表示為</p>
<p>T &#x3D; ［3 1 4 1 5 2］、m &#x3D; 5、d &#x3D; 10</p>
<p>$t_s &#x3D; t_0 &#x3D; 31,415$</p>
<p>$\Rightarrow t_{s+1} &#x3D; t_1 &#x3D; 10(31,415-10^{5-1}\cdot3)+2 &#x3D; 14,152$</p>
</blockquote>
<blockquote>
<ul>
<li>因為 p 以及 $t_k$ <strong>可能非常大</strong><ul>
<li>因此比較時間不能視為常數</li>
</ul>
</li>
<li>通常將其 mod 一個大質數 q<ul>
<li>因為如此當 $p &#x3D; t_k$ 時，不一定匹配成功，須再作進一步驗證<ul>
<li>Spurious hit（假性命中）<ul>
<li>$p &#x3D; t_k$ 但 P[1…m] <strong>≠</strong> T[s+1…s+m]</li>
</ul>
</li>
<li>Valid hit（完全命中）<ul>
<li>$p &#x3D; t_k$ 與 P[1…m] <strong>&#x3D;</strong> T[s+1…s+m]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>Example</p>
<ul>
<li>P[1…5] &#x3D; 31,415<ul>
<li>p &#x3D; <strong>31,415 mod 13</strong> &#x3D; 7</li>
</ul>
</li>
</ul>
<!-- ![1549521217587](\willywangkaa\images\1549521217587.png) -->

<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rabinkarpmatcher</span> <span class="params">(T,P,d,q)</span> </span>&#123;</span><br><span class="line">    n = T.<span class="built_in">length</span>();</span><br><span class="line">    m = T.<span class="built_in">length</span>();</span><br><span class="line">    h = <span class="built_in">pow</span>(d,m<span class="number">-1</span>) % q;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Preprocessing</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to m &#123;</span><br><span class="line">        p = (d*p + P[i]) % q;</span><br><span class="line">        t[<span class="number">0</span>] = (d*t_0 + T[i]) % q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Matching</span></span><br><span class="line">    <span class="keyword">for</span> s = <span class="number">0</span> to n-m &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == t[s])&#123;</span><br><span class="line">            <span class="keyword">if</span>(P[<span class="number">1.</span>.m] == T[s+<span class="number">1.</span>.s+m])&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Pattern occurs with shift&quot;</span>+ s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next substring</span></span><br><span class="line">        <span class="keyword">if</span>(s &lt; n-m)&#123;</span><br><span class="line">            t[s+<span class="number">1</span>] = (d*(t[s]-T[s+<span class="number">1</span>]*h)+T[s+m+<span class="number">1</span>]) % q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>時間複雜度</p>
<ul>
<li>預處理<ul>
<li>θ (∣P∣)</li>
</ul>
</li>
<li>比對程序<ul>
<li><strong>O( (∣T∣-∣P∣+1)×∣P∣ )</strong></li>
<li>發生在「Worst case」情況</li>
<li>在多數比對次數少、q 大於 m 的情況為線性複雜度</li>
</ul>
</li>
</ul>
</li>
<li><p>空間複雜度</p>
<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h2 id="Knuth-Morris-Pratt-演算法"><a href="#Knuth-Morris-Pratt-演算法" class="headerlink" title="Knuth-Morris-Pratt 演算法"></a>Knuth-Morris-Pratt 演算法</h2><p>由 Donald Knuth、Vaughan Pratt、J. H. Morris 三人於西元 1977 年共同聯合發表，<strong>最差情況為 O(n) 的字串匹配演算法</strong></p>
<blockquote>
<p><strong>觀察暴力演算法</strong></p>
<ul>
<li>存在不必要的工作<ul>
<li>從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位</li>
<li>往右挪動 P 之前，當下比對成功的字串片段，可以不必花時間在上面</li>
</ul>
</li>
</ul>
<p>Example</p>
<ul>
<li>T &#x3D; [aabzabzabcz]</li>
<li>P &#x3D; [abzabc]</li>
</ul>
<p>（從左往右一一比對字元，一旦發現字元不同，將 P 往右挪動一位）</p>
</blockquote>
<!-- > ![1549522985570](\willywangkaa\images\1549522985570.png) -->
<blockquote>
<p>（在往右挪動 P 之前，當下比對成功的字串片段「abzab」可以加以利用）</p>
</blockquote>
<!-- > ![1549523718157](\willywangkaa\images\1549523718157.png) -->
<blockquote>
<p>（繼續往右挪動 P，挪動一個位置、挪動兩個位置、…）</p>
</blockquote>
<!-- > ![1549523787809](\willywangkaa\images\1549523787809.png) -->
<blockquote>
<p>觀察上述行為</p>
<ul>
<li><p>挪動一個位置</p>
<ul>
<li>比較『abzab 的<strong>後四個字元</strong>』與『abzab 的<strong>前四個字元</strong>』</li>
</ul>
</li>
<li><p>挪動兩個位置</p>
<ul>
<li>比較『abzab 的<strong>後三個字元</strong>』與『abzab 的<strong>前三個字元</strong>』</li>
</ul>
</li>
<li><p>因此若預先知道『 abzab 之「次長相同前綴後綴」是 ab』</p>
<ul>
<li><strong>可大幅挪動 P</strong><ul>
<li>從「V」處繼續向右一一比對字元</li>
<li>每當比對失敗，就從當前比對成功的字串片段，取其「次長的相同前綴後綴」大幅挪動 P</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<!-- > ![1549524105095](\willywangkaa\images\1549524105095.png) -->
<blockquote>
<p><strong>「相同前綴後綴」</strong>（Prefix-suffix）</p>
</blockquote>
<!-- > ![1549524327132](\willywangkaa\images\1549524327132.png) -->
<blockquote>
<p><strong>「次長相同前綴後綴」</strong></p>
<ul>
<li>一個字串的「最長相同前綴後綴」為<strong>原字串</strong></li>
<li>「最短相同前綴後綴」為<strong>空字串</strong></li>
<li>「次長相同前綴後綴」就是第二長的「相同前綴後綴」</li>
</ul>
</blockquote>
<!-- > ![1549524493648](\willywangkaa\images\1549524493648.png) -->
<blockquote>
<p>窮舉法的過程當中，<strong>當前比對成功的字串片段是 P 的前綴</strong></p>
<ul>
<li>因為無法預測是 P 的哪個前綴<ul>
<li>所以<strong>預先計算 P 每個前綴的「次長的相同前綴後綴」</strong></li>
<li>衍生出了「Failure function」</li>
</ul>
</li>
</ul>
</blockquote>
<p>步驟</p>
<ol>
<li>預先計算 P 的每種前綴的「次長相同前綴後綴」<ul>
<li>意旨算出 P 的「Failure function」</li>
</ul>
</li>
<li>從左往右依序比對字元<ul>
<li>比對成功時<ul>
<li>繼續比對下個字元</li>
</ul>
</li>
<li>比對失敗時<ul>
<li>從比對成功的<strong>字串片段取其「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul>
</li>
<li>當全部比對成功搜尋到 P 時<ul>
<li><strong>取 P「次長的相同前綴後綴」以大幅挪動 P</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Algorithm</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( pattern[k] != pattern[i+<span class="number">1</span>]   <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; i&gt;=<span class="number">0</span> )&#123;                    <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Morris_Pratt</span><span class="params">(string T, string P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> P.size &gt; T.size</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">GetFailureFunction</span>(P);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 進行字串搜尋，時間複雜度：O(T)</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to T.size &#123;</span><br><span class="line">        s = <span class="number">-1</span>;                                      <span class="comment">// 目前 P 字元比對已成功的位置</span></span><br><span class="line">        <span class="comment">// 比對 P 的下一個尚未比對位置（s+1）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若 T[k] != P[s+1]，尋找大幅挪動的步伐數</span></span><br><span class="line">        <span class="comment">// 在 P 中找出 P[1..s] == T[k-s..k] 以大幅挪動 P</span></span><br><span class="line">        <span class="keyword">while</span> ( P[s+<span class="number">1</span>] != T[k]                       <span class="comment">// T[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              &amp;&amp; s &gt;= <span class="number">0</span> ) &#123;                          <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            s = failure[s];                          <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// T[k] 與 P[s+1] 比對成功</span></span><br><span class="line">        <span class="keyword">if</span> (P[s+<span class="number">1</span>] == T[k]) &#123;                         </span><br><span class="line">            s++;                                     <span class="comment">// P 字元比對已成功的位置後移一位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s == P.size<span class="number">-1</span>) &#123;                        <span class="comment">// P 字元比對已成功的位置已移完</span></span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&quot; P出現的位置&quot;</span> + (s-P.size+<span class="number">1</span>) );</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            s = failure[s];                         <span class="comment">// 如果字串結尾不是&#x27;\0&#x27;的時候，就必須挪動 P</span></span><br><span class="line">                                                    <span class="comment">// 如果字串結尾是&#x27;\0&#x27;的時候，就能省略這一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="時間複雜度分析（均攤分析）"><a href="#時間複雜度分析（均攤分析）" class="headerlink" title="時間複雜度分析（均攤分析）"></a>時間複雜度分析（均攤分析）</h3><p>以「Multipop stack」概念作均攤分析，以<strong>字元兩兩比對總次數</strong>作為時間複雜度</p>
<p>（1）進行字串搜尋的過程中</p>
<ul>
<li>「Stack」S 的元素<ul>
<li>當下比對成功的字串片段 S<ul>
<li><strong>一開始 S 長度是零</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>若字元比對成功</strong><ul>
<li>S 增加一字元，<strong>視為「Push stack」</strong></li>
</ul>
</li>
<li><strong>若字元比對失敗</strong><ul>
<li>大幅挪動 P，S 只剩下「次長的相同前綴後綴」，<strong>視為「Multipop」</strong></li>
<li>實際上 S 瞬間大幅變短只需要 O(1) ，時間複雜度遠比「Multipop」小</li>
</ul>
</li>
</ul>
<ol>
<li><p>最多有 T 個字元放入 S（S 增加一字元）</p>
</li>
<li><p>最多有 T 個字元彈出 S（大幅挪動 P，S 只剩下「次長的相同前綴後綴」）</p>
</li>
</ol>
<p>$\Rightarrow$<strong>字元兩兩比對的總次數不超過 2T 次</strong></p>
<p>（2）計算 P 的「Failure function」過程中</p>
<p>原理相同，字元兩兩比對的總次數不超過 2P 次</p>
<ul>
<li><strong>總時間複雜度</strong><ul>
<li>O(∣T∣+∣P∣)</li>
</ul>
</li>
</ul>
<h3 id="Failure-function"><a href="#Failure-function" class="headerlink" title="Failure function"></a>Failure function</h3><p>在比對失敗時會使用之</p>
<p>因為函數的<strong>定義域</strong>是 Prefix，又稱作 Prefix function </p>
<p>因為此函數的<strong>值域</strong>是 Border，又稱作 Border function</p>
<ul>
<li><strong>字串函數</strong><ul>
<li>輸入字串的其中一個前綴，<strong>輸出該前綴的「次長的相同前綴後綴」</strong></li>
</ul>
</li>
</ul>
<!-- ![1549524903137](\willywangkaa\images\1549524903137.png)

![1549529928795](\willywangkaa\images\1549529928795.png) -->

<ul>
<li>計算「Failure function」 <ul>
<li>Dynamic Programming</li>
<li>分割問題<ul>
<li>P[0…i] 除去尾端字元 P[i] </li>
<li>利用已知 P[0…i-1] 的「次長相同前綴後綴」</li>
<li>得到 P[0…i] 的「次長相同前綴後綴」</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>F[k]：P[0…k] 之「次長的相同前綴後綴」<strong>長度</strong></p>
<p>（1）將 F[0] 初始化為 -1</p>
<ul>
<li>長度為 1 的子字串，不存在「次長相同前綴後綴」</li>
</ul>
<p>（2）F[k]：<strong>探討 P[1…k-1] 與 P[k] 之間的關係</strong></p>
<!-- ![1549530552160](\willywangkaa\images\1549530552160.png) -->

<ul>
<li><strong>P[ F[k-1]+1 ] &#x3D;&#x3D; P[k]</strong><ul>
<li>意旨「<strong>第 k 個字元</strong>」與「<strong>P[1…k-1] 之『次長的相同前綴後綴』下一個字元</strong>」相等</li>
<li>$\Rightarrow$ <strong>F[k] &#x3D; F[k-1]+1</strong></li>
</ul>
</li>
</ul>
<!-- ![1549530722575](\willywangkaa\images\1549530722575.png) -->



<blockquote>
<p><strong>對「P[1…k-1] 之『次長的相同前綴後綴』」作探討</strong></p>
</blockquote>
<!-- > ![1549534207507](\willywangkaa\images\1549534207507.png) -->



<ul>
<li>P[ F[k-1]+1 ] ≠ P[k]<ul>
<li>「<strong>第 k 個字元</strong>」與「P[1…k-1] 之『次長的相同前綴後綴』下一個字元」相異</li>
</ul>
</li>
</ul>
<p><strong>若存在 P[ F…[F[k-1]]+1 ] &#x3D;&#x3D; P[k]，則 F[k] &#x3D; F…[F[k-1]]+1</strong></p>
<!-- ![1549535284950](\willywangkaa\images\1549535284950.png) -->



<p><strong>若不存在 P[ F…[F[k-1]]+1 ] &#x3D;&#x3D; P[k]，則 F[k] &#x3D; -1</strong></p>
<!-- ![1549535607960](\willywangkaa\images\1549535607960.png) -->



<p>上述可以表達為：</p>
<ul>
<li><p>$f[k]\left{\begin{matrix}<br>-1 &amp; if ;k &#x3D; 0\ f^m[k-1] +1 &amp; 最小的整數; m;使得; P[f^m[k-1]+1] &#x3D;&#x3D; P[k]<br>\ -1 &amp; 不存在整數; m ;可以使得 P[f^m[k-1]+1] &#x3D;&#x3D; P[k]\end{matrix}\right.$</p>
</li>
<li><p>Algorithm</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern[0..m]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetFailureFunction</span><span class="params">(string pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to pattern.size &#123;</span><br><span class="line">        i = failure[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((pattern[k]!=pattern[i+<span class="number">1</span>]) &amp;&amp; <span class="comment">// P[k] != P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">              i&gt;=<span class="number">0</span>)&#123;                        <span class="comment">// P[ F[...F[k-1]] ] 仍存在『次長的相同前綴後綴』</span></span><br><span class="line">            i = failure[i];                 <span class="comment">// 以 F[...F[k-1]] 繼續尋找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i+<span class="number">1</span>])&#123;     <span class="comment">// P[k] == P[ F[...F[k-1]]+1 ]</span></span><br><span class="line">            failure[k] = i+<span class="number">1</span>;               <span class="comment">// F[k] = F[...F[k-1]]+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Morris-Pratt-Automaton"><a href="#Morris-Pratt-Automaton" class="headerlink" title="Morris-Pratt Automaton"></a>Morris-Pratt Automaton</h3><p>此演算法可以化作自動機，轉化的時間複雜度為 O( ∣P∣×∣Σ∣ ) </p>
<ul>
<li>Σ 為字元集合</li>
</ul>
<blockquote>
<p>化作自動機之後，字串搜尋的過程就變得更簡單了，甚至可以設計成電子迴路</p>
<p>轉化的原理，是針對每個狀態，都找出經由「Failure function」能到達的狀態們，然後建立轉移邊，連到那些狀態們的下一個狀態</p>
</blockquote>
<!-- ![1549541112414](\willywangkaa\images\1549541112414.png) -->

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/TheDeep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/TheDeep/" class="post-title-link" itemprop="url">TheDeep</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 03:09:21 / Modified: 03:09:34" itemprop="dateCreated datePublished" datetime="2023-02-17T03:09:21+08:00">2023-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/description/">Add Two Numbers</a></h1><h2 id="Method1：just-add-them-best-solution"><a href="#Method1：just-add-them-best-solution" class="headerlink" title="Method1：just add them(best solution)"></a>Method1：just add them(best solution)</h2><p>time：O(max(n, m)), given n, m represent the length of two lists</p>
<p>space：O(max(n, m)), given n, m represent the length of two lists</p>
<p>觀念：</p>
<ol>
<li>利用一個變數carry來處理進位的問題，每一個iteration的addition為：list1.val + list2.val + carry，而由於是十進位的加法，所以作完加法的每一個digit &#x3D; addition % 10<ol>
<li>若addition ≥ 10：需要進位 → carry &#x3D; True</li>
<li>若addition &lt; 10：carry &#x3D; False</li>
</ol>
</li>
<li>Edge case：當the most significant digit(最大的位數)要進位時，此時需要增加list的長度，故若iteration結束而carry &#x3D; True，就在最後增加一個ListNode(val&#x3D;1)</li>
</ol>
<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></strong></h1><h2 id="Method1：two-pointers-sliding-window-best-solution"><a href="#Method1：two-pointers-sliding-window-best-solution" class="headerlink" title="Method1：two pointers - sliding window(best solution)"></a>Method1：two pointers - sliding window(best solution)</h2><p>time：O(n)</p>
<p>space：O(n)</p>
<p>觀念：</p>
<ol>
<li>利用hashmap去紀錄每一個char的idx</li>
<li>利用兩個變數left, right，left一開始為零、right則是一直往前跑，當出現repeating char時可分為兩種情況：<ol>
<li>repeating char在[left, right]區間裡：將left往前拉到repeating char的next position，因為對於現在區間而言若left還停留在repeating char之前，則[left, right]無論如何都不會是longest panlindrome，且更新hashmap的idx為right的位置</li>
<li>repeating char不在[left, right]區間裡：考慮case “tmmzuxt”，t為duplicates，只是當第二個t被traverse到的時候，第一個t已不在[left, right]區間內，所以可以照常計算max_len</li>
</ol>
</li>
<li>若沒有出現2-(a)的情況則計算當前長度以持續維護max_len</li>
</ol>
<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></strong></h1><h2 id="Method1：Expand-from-every-center"><a href="#Method1：Expand-from-every-center" class="headerlink" title="Method1：Expand from every center"></a>Method1：Expand from every center</h2><p>time：O(n^2)</p>
<p>space：O(1)</p>
<p>觀念：</p>
<ol>
<li>新增一個函式，利用兩個變數(left_pos、right_pos)將每個character視為center，同步往左右兩邊擴展，一一比對左右兩個char是否相同，若相同就繼續擴展，直到左右不一樣或是左右某一個char超出string的範圍時，就回傳左右的位置（Note：迴圈中斷時，要馬是(1)左右兩個char不相同，或是(2)左右之中至少一個超出string的範圍，所以在回傳left_pos、right_pos之前需要將left +&#x3D; 1、right -&#x3D;1）</li>
<li>palindrome有兩種：(1)長度為奇數，e.g “aba”  (2)長度為偶數，e.g. “abba”，所以這兩種情形都要考慮到，即對於string的每個char，都要進行兩次expand，一次為current char當作center、一次為current char和其next char當作center</li>
<li>注意題目是問最長的回文，所以在解題時其實只要maintain相距最遠的left_pos, right_pos就好，即初始化兩個變數start, end為零，檢查每次expand回傳的left_pos, right_pos，若有比start, end相距還遠，就更新start, end，最後再return “string[start : end+1]”即可（這樣就不用浪費O(n)的空間去真的maintain一個longest string）</li>
</ol>
<h2 id="Method2：dynamic-programming"><a href="#Method2：dynamic-programming" class="headerlink" title="Method2：dynamic programming"></a>Method2：dynamic programming</h2><p>先備知識：DP</p>
<ol>
<li>DP的核心觀念：將一個問題切成子問題，將子問題切成子子問題，以此類推，並透過儲存每一次的計算成果，達到減少重複計算的目的</li>
<li>儲存計算結果的方式通常為1D-table或是2D-table </li>
<li>就如同遞迴函式一樣，DP一定會有基本(初始)條件，所以在建完用來儲存計算結果的表後，我們通常需要assign一些值進去</li>
<li>續(3)：舉個基本條件的例子，以計算階乘為例，我們知道n! &#x3D; (n-1)! * n，而1! &#x3D; 1，所以我們可以利用”1! &#x3D; 1”這個基本條件去計算2以後的所有階乘，可以列出以下式子 → For function f(n): (1)f(n) &#x3D; 1 , n &#x3D;&#x3D; 1 (2)f(n) &#x3D; f(n-1)*n , n ≥ 2</li>
</ol>
<p>time：O(n^2)</p>
<p>space：O(n^2)</p>
<p>觀念：</p>
<ol>
<li><p>此題利用DP的精髓在於：若s[ i ] &#x3D;&#x3D; s[ j ]，且s[ i+1 : j-1 ]為palindrome，則s[ i : j ]為palindrome，如此達到”重複利用先前計算結果”的效果，所以2D-table的任一entry實際上為bool，即table[ i ][ j ]代表的就是s[ i : j ]是否為palindrome</p>
</li>
<li><p>上述先備知識(3)應用於此題為：每單一個char自己就是palindrome，所以在建完2D-table後，需要將table[ 1 ][ 1 ], table[ 2 ][ 2 ] … 等初始化為True</p>
</li>
<li><p>利用double for loops分別去迭代start_pos, end_pos，並利用兩個變數leftmost、rightmost去maintain最長的回文區間，當s[ start_pos ] &#x3D;&#x3D; s[ end_pos]時，需要更新table有兩種情形：</p>
<ol>
<li>end_pos -  start_pos &#x3D;&#x3D; 1：表示為偶數的回文</li>
<li>s[start_pos+1 : end_pos-1]為palindrome(去table看)</li>
</ol>
<p> 以上兩種皆為有效的palindrome，此時就檢查當前區段是否為longest，是的話就更新leftmost、rightmost，並更新table[start_pos][end_pos]為True
 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/solutions/474664/commented-clean-python-dp-solution/#:~:text=hungapp,end">(explanation見評論區)</a>%3A)</p>
<p> 由於我們想要以最短的substring為開始去填dp table，迴圈(start, end)的設置必須是由”短到長”，e.g. s &#x3D; “abba”，double for loops的起始點(start_pos, end_pos)依序為”ab”, “bb”, “ba”，而非”ab”, “ab”, “aa”，這是由於觀念(1)，我們現在考慮start_pos, end_pos分別在first “a”, last “a”，演算法會去table看”bb”是否為palindrome，而若我們不是由”短到長”去iterate的話，此時”bb”根本還沒被iterate到，因此無法找出所求，反之則可以求出正解</p>
</li>
</ol>
<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/description/">Container With Most Water</a></h1><h2 id="Method1：Two-pointers"><a href="#Method1：Two-pointers" class="headerlink" title="Method1：Two pointers"></a>Method1：Two pointers</h2><p>time：O(n)</p>
<p>space：O(1)</p>
<p>concept：由於是算面積，要想到用”夾住”的概念(top down)，即一開始就直接考慮最寬的情況，然 後慢慢往內縮</p>
<p>main：</p>
<ol>
<li>每次都移動較矮的那根，試想，如果是移動較高的那根只會有兩種情況，(1): 新的那根高於較矮的那根，此情況則還是會以矮的那根為主 (2): 新的那根低於較矮的那根，此情況面積只會更小，所以以上兩種情況都沒有意義。</li>
<li>濃縮1.的概念，由於一開始已經是從”最寬”的情況往內縮，所以得到較大面積唯一的可能為找到比當前更高的高度，則只有移動矮的那根才可能做得到。</li>
</ol>
<p>terminal condition：</p>
<p>當兩個pointer碰到</p>
<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/description/">15. 3Sum</a></strong></h1><p>ime：O(n^2)</p>
<p>space：O(n)</p>
<h2 id="Method1：Two-pointers-and-set"><a href="#Method1：Two-pointers-and-set" class="headerlink" title="Method1：Two pointers and set"></a>Method1：Two pointers and set</h2><p>觀念：</p>
<p>set</p>
<ol>
<li>由於題目要求三個數不能有duplicates，且不要求順序，所以使用set來存取答案 → set的unique property：<ol>
<li>當set裡存的是一個個number → 只要值不同就可以被存入 </li>
<li>當set裡存的是一個個tuple(set只能存hashable object) → 只要tuple裡的值順序不同就可以被存入，e.g. (1,2,3) &amp; (1,3,2)→可以、(1,2,3) &amp; (1,2,3)→不行</li>
</ol>
</li>
<li>插入：set.add(<hashable object>)，e.g. tuple &#x3D; (1,2,3), set.add(tuple)</li>
<li>刪除：set.remove(<hashable object>)，e.g. set.remove(tuple) </li>
<li>註：”All of Python’s immutable built-in objects are hashable”，所以set可以存tuple(不可被修改)，但不能存lists, sets</li>
</ol>
<p>two pointers </p>
<ol>
<li>先排序number array，從左到右(len-2)iterate，將current pointer視為base number，剩下的兩個數則是我們要找的target，也就是-1*base number </li>
<li>利用left(i+1), right(last element)去夾住base number以後的elements：<ol>
<li>while condition：由於題目要求三個數的index不能重複，所以條件會是while left &lt; right</li>
<li>當(left + right) &lt; target : 表示要變大，所以left往右移動一格 </li>
<li>當(left + right) &gt; target : 表示要變小，所以right左移動一格 </li>
<li>當(left + right) &#x3D; target : 表示找到答案，將三個數按照順序放入set，此時因為我們每次都是將值按照順序插入set，所以set會自動幫我們過濾掉duplicates</li>
</ol>
</li>
</ol>
<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">Remove Nth Node From End of List</a></h1><p>先備知識：linked list世界裡的”remove”常常是將previous node接到current node的next node</p>
<h3 id="Method1：count"><a href="#Method1：count" class="headerlink" title="Method1：count"></a>Method1：count</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>先traverse一次linked list統計nodes數量，為了刪除該node，我們需要得到其”前一個”node的位置，因此拿node總數減掉題目所給的n可得該位置</li>
<li>第二次traverse時也是一邊count nodes去走到由(1)所得的位置，走到該位置後利用”先備知識”所述的方法刪除node並return head即可</li>
<li>special case：若(2)的情況沒有發生(no return)，則代表要刪除node為第一個node，而由於first node並無所謂的previous node，因此無法利用(2)的方法將其刪除，此時的post processing為直接return head.next即可</li>
</ol>
<h1 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array">Search in Rotated Sorted Array</a></h1><h3 id="Method1：variation-of-binary-search"><a href="#Method1：variation-of-binary-search" class="headerlink" title="Method1：variation of binary search"></a>Method1：variation of binary search</h3><p>時間：O(logn)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>稍微思考一下此題rotate後的樣子會長成”兩個ascending order interval”，且左邊的interval &gt; 右邊的interval</li>
<li>知道了(1)之後，接著判斷mid所處的位置進而決定要怎麼移動left和right： <ol>
<li>若nums[mid] &#x3D;&#x3D; target : return mid</li>
<li>若nums[mid] &lt; nums[right] : 代表mid位在”right ascending order interval”，此時只要比較target是否位在此右區間，若是的話就往右search，反之則往左</li>
<li>若nums[mid] &gt; nums[right] : 代表mid位在”left ascending order interval”，此時只要比較target是否位在此左區間，若是的話就往左search，反之則往右</li>
</ol>
</li>
</ol>
<h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum">Combination Sum</a></h1><p>先備知識：backtracking</p>
<ul>
<li><p>使用時機：當一個問題在於”找出所有可能解”的時候</p>
</li>
<li><p>觀念：backtracking通常包含三個部分</p>
<ul>
<li>choose: 找出可能的解(candidates)，可以試著思考”找解的步驟或是方式為何”</li>
<li>constraints: 在找解的過程中，思考在什麼情況下”不用繼續找下去” 或是 ”才要繼續找下去”，像是”最大不能超過某個值”或是”要符合某種條件(e.g. panlidrome)”，而不符合此限制時演算法會向”下一步邁進”</li>
<li>target: 即在什麼情況下current candidates符合題目所求，達到target時通常此時會用某種資料結構將current candidates存起來，然後演算法向”下一步邁進”</li>
</ul>
<p>  → 思考以上三點後通常可以整理出一個固定的模式，所以在解題時不需要先想code怎麼寫，而是先想辦法歸納出演算法的模式
  </p>
</li>
<li><p>寫法：通常會包含(1)loop (2)recursive 這兩部分，而recursive負責實際的統計或計算、loop負責充當發生「不符合constraints」或「滿足target」後，將演算法向下一步推進的角色</p>
</li>
</ul>
<h3 id="Method1：dfs-backtracking"><a href="#Method1：dfs-backtracking" class="headerlink" title="Method1：dfs(backtracking)"></a>Method1：dfs(backtracking)</h3><p>時間：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/solutions/1755084/detailed-time-and-space-complexity-analysis-c-java-backtracking/?orderBy=most_votes">https://leetcode.com/problems/combination-sum/solutions/1755084/detailed-time-and-space-complexity-analysis-c-java-backtracking/?orderBy=most_votes</a></p>
<p>空間：(同上)</p>
<p>觀念：</p>
<p>e.g nums &#x3D; [2,3,6,7] , target &#x3D; 7</p>
<ol>
<li><p>choose: 此題可以允許同一個number(自己)被使用多次，所以想法上為：由左至右，先一直”加自己”直到不符合constraints或滿足target，再往右移一格並重複做一樣的事，而在寫法上因為有多組可能，所以需要一個curr_arr、ans_arr分別去紀錄當前可能的答案和所有的答案，另外需要有個變數summation去紀錄當前的加總值</p>
<p> 注意：以上提到的幾個變數都是寫在遞迴參數內，而非寫在其他行，為的就是當不符合constraints或滿足target return後，算法可以自己回到”上一個狀態”而不需要再去手動對curr_arr和summation進行處理</p>
</li>
<li><p>constraints: 當summation &gt; target時，代表不用再”累加自己”上去，而因為是遞迴，所以此時為了回到上一個狀態，e.g. <a href="%E7%88%86%E6%8E%89">2,2,2,2</a> 回到 [2,2,2]，要return回去，而return後的位置在迴圈內，此時如同”先備知識 - 寫法”所述，迴圈會負責將算法往前推進一格，即[2,2,2,3]</p>
<p> 注意：迴圈的起始點需要隨著算法的推進而往前，e.g.(續上例) 在[2,2,2,2]return回[2,2,2]後，此時迴圈的起始點會往前移動到3的位置(即 i 從 0<del>3 到 1</del>3)，如此才能達到繼續”加自己”的效果，i.e. curr_arr之後只可能會長成[2,2,2,3,3,3…..]，而非[2,2,2,3,2,2,2…]</p>
</li>
<li><p>target: 當summation &#x3D;&#x3D; target時，表示candidate符合條件，將curr_arr加進ans_arr中，再return(不用沿著這條路繼續找下去，因為，e.g. [2,2,3]之後[2,2,3,3]不可能是答案)</p>
</li>
</ol>
<h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image">Rotate Image</a></h1><h3 id="Method1：Rotate-Groups-of-Four-Cells"><a href="#Method1：Rotate-Groups-of-Four-Cells" class="headerlink" title="Method1：Rotate Groups of Four Cells"></a>Method1：<strong><strong>Rotate Groups of Four Cells</strong></strong></h3><p>時間：O(n^2)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<p>假設矩陣的邊長為n</p>
<ol>
<li>觀察規律可發現，For each cell(i, j)，將它旋轉90度後會變成cell( j, n-1-i )，且循著此規律一直search其位置最終會回到原點，每四次一個循環</li>
<li>而得知(1)的特性後再觀察一下可發現，從第一列開始，若對於每一列的index 0~n-2都做一次”四次循環的modify”，即可將該列所處的四個邊順利完成旋轉，如此利用兩個變數start_col、end_col當作界線，每完成一次”四個邊的旋轉”(i.e. 從最外圍開始往內)，就將此界線往內各縮一格，並將row往下移動一格，直到兩條界線碰觸到或是交錯(Note: 兩條界線最後若交疊代表陣列邊長為奇數，若交錯代表為偶數)，即代表矩陣所有的cells都已被我們旋轉完成</li>
</ol>
<h3 id="Method2：transpose-and-swap-the-matrix-best-solution"><a href="#Method2：transpose-and-swap-the-matrix-best-solution" class="headerlink" title="Method2：transpose and swap the matrix(best solution)"></a>Method2：transpose and swap the matrix(best solution)</h3><p>時間：O(n^2)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<p>利用矩陣的特性，透過transpose(swap列和欄) 和 swap rows, columns(上下或是左右顛倒)這兩個操作來完成rotation</p>
<ol>
<li><p>python中的swap()可以直接用assign的方式寫在同一行，e.g. swap(matrix[i][j], matrix[j][i]):</p>
<p> matrix[i][j], matrix[ j ][i]&#x3D; matrix[j][i], matrix[i][ j ]</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/solutions/1449737/rotation-90-code-180-270-360-explanation-inplace-o-1-space/">旋轉180度, 270度</a>: </p>
<ol>
<li>180度：上下左右顛倒，即swap rows then swap columns 或是 swap columns then swap rows</li>
<li>270度：transpose(swap列和欄) then swap rows</li>
</ol>
</li>
</ol>
<h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></strong></h1><h3 id="Method1：Kadane’s-Algorithm"><a href="#Method1：Kadane’s-Algorithm" class="headerlink" title="Method1：Kadane’s Algorithm"></a><a target="_blank" rel="noopener" href="https://www.interviewbit.com/blog/maximum-subarray-sum/">Method1：<strong>Kadane’s Algorithm</strong></a></h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用兩個變數curr_sum、maximum分別去紀錄當前的加總以及歷史最大加總，且一開始將curr_sum初始化為0、maximum初始化為一個很小的數(畢竟returned answer至少須為陣列中的某個數)：<ol>
<li>if curr_sum &gt; maximum :  maximum &#x3D; curr_sum</li>
<li>if curr_sum &lt; 0 : curr_sum &#x3D; 0</li>
</ol>
</li>
<li>此算法的核心概念為1-b：當curr_sum變為負時，我們需要在下一個iteration前將其歸零(即在下一個iteration重新開始作加總)，這是因為curr_sum為負時，表示”current position以前”的那坨數對於”current position以後”的數(不管之後的數為何)都是”拖油瓶”，它們只會讓以後的加總”更小”，而到目前為止的最大加總都已經被maximum紀錄起來了，所以我們可以放心的放棄之前看過的累積值(curr_sum)並將其歸零重新開始計算</li>
<li>Ex: [3, -5, 2, 2] :</li>
</ol>
<table>
<thead>
<tr>
<th>i</th>
<th>curr_sum</th>
<th>maximum</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>0</td>
<td>-1000000</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>-2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<h1 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-interval/description/">57. Insert Interval</a></strong></h1><h3 id="Method1：brute-force"><a href="#Method1：brute-force" class="headerlink" title="Method1：brute force"></a>Method1：brute force</h3><p>時間：O(n), given n is the number of intervals</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li><p>新增兩個函式(1)func overlap: 判斷任兩個inverval是否為overlap (2)func merge: 當兩個interval發生overlap時將他們合併成一個interval</p>
</li>
<li><p>為了不改變原本的陣列結構，所以將newInterval直接插在陣列最後面，由後往前檢查： </p>
<ol>
<li>是否發生overlap：若True，則將current interval更新為merged interval，再將前一個interval pop掉（Note: pop完一般會產生是否改變index正確性的疑慮，然而仔細思考一下就知道不會有問題，因為這邊的做法是merge完的interval要繼續跟它的前一個interval做檢查，所以正常將index -&#x3D; 1後current position還是會回到自己身上） </li>
<li>start(i)的是否為ascending order：若(a)不成立，而current start point &lt; prev start point，則swap兩個interval</li>
</ol>
<p> Note: 需要優先判斷(a)，因為如果有overlap則不管順序怎樣都要merge
 </p>
</li>
<li><p>依照(2)遍歷完整個陣列即可確保得到一個ascending, non-overlapping interval</p>
</li>
</ol>
<p>補充(續觀念(2))：</p>
<p>在陣列作pop操作後常常會遇到index跑掉的問題，做個整理：</p>
<ol>
<li>pop完的變動為 → ”poped position之後”的index全部-1</li>
<li>以lst &#x3D; [0, 1, 2, 3]為例，after lst.pop(1)，lst &#x3D; [0, 2, 3]，所以2, 3分別會被更新為1, 2  </li>
<li>所以視情況而定，看pop之後希望curr position落在哪就可清楚地維持正確性</li>
</ol>
<h1 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-matrix-zeroes/description/">Set Matrix Zeroes</a></h1><h3 id="Method1：first-row-and-column-as-signals-best-solution"><a href="#Method1：first-row-and-column-as-signals-best-solution" class="headerlink" title="Method1：first row and column as signals(best solution)"></a>Method1：first row and column as signals(best solution)</h3><p>時間：O(M*N), given M, N are the number of rows and columns, respectively</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li>利用第一列和第一欄當作label：若cell(i, j)為0，則label matrix[ 0 ][ j ]和matrix[ i ][ 0 ]為0，label完後再次traverse matrix的時候只要任一element所對應的matrix[ 0 ][ j ] 或 matrix[ i ][ 0 ]為0，就將該element assign為0</li>
<li>注意：由於第一列和第一欄要拿來當作signals，所以”第一列和第一欄是否要填0”必須分開看：在label前先行判斷第一列和第一欄是否有0(用bool表示)，判斷完之後即可traverse matrix，而也因為前述，所以matrix的traversal要保留第一列和第一欄(i.e. 從[1, 1]開始)</li>
<li>等到該填0的cell都填完，表示我們不再需要signals，最後就可以處理第一列和第一欄，將列和欄該填滿0的填上去</li>
</ol>
<h1 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-search/description/">Word Search</a></h1><h3 id="Method1：dfs-best-solution"><a href="#Method1：dfs-best-solution" class="headerlink" title="Method1：dfs(best solution)"></a>Method1：dfs(best solution)</h3><p>時間：O(n<em>m</em>4^len(word))</p>
<p>空間：O(n*m)</p>
<p>觀念：</p>
<ol>
<li>DFS：對於任一個”有效的”且”尚未被visit過”的cell(i, j)，判斷其是否等於word的current char，若不相等則return，否則就朝”上下左右”四個方向分別去search下一個char，直到所有的char被找到，For each cell(i, j)：<ol>
<li>若row or column超出方格的範圍：return False </li>
<li>若cell(i, j) ≠ curr_char 或 cell(i, j) is visited ： return False </li>
<li>若(a), (b)為False，表示此cell(i, j)為effective且與char匹配，此時若char已經是word的最後一個，表示成功找到word，則將True一路傳回主函式，反之則繼續朝上述四個方向分頭繼續搜尋</li>
<li>為了避免搜尋的過程中cell被重複visit，直接利用題目所給的方格紀錄看過的cell，i.e. 可暫時assign visited cell隨便一個char(e.g. “@”)</li>
</ol>
</li>
<li>Main function：對於方格中的每一個cell，若其與word[0]匹配，則進入search階段(func DFS)，直到double for loops結束都沒有成功找到word，代表word不存在，return False</li>
</ol>
<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Longest Consecutive Sequence</a></h1><p>先備知識：</p>
<ol>
<li>subarray v.s sequence：subarray必須是contiguous，而sequence不用，e.g. For [1,2,3,4]: [1,2,3] is a subarray，[1,2,4] is a subsequence</li>
<li>此題所指的consecutive sequence指的其實就是subarray，差別在於此題要從一個unsorted array找出答案，e.g. For [100, 4, 2, 3, 3, 200]: ans  &#x3D; 3 ([2, 3, 4])</li>
</ol>
<h3 id="Method1：sort-it"><a href="#Method1：sort-it" class="headerlink" title="Method1：sort it"></a>Method1：sort it</h3><p>時間：O(nlogn)</p>
<p>空間：O(1)</p>
<p>觀念：利用三個變數max_len、curr_len、prev_num去找出max_len</p>
<ol>
<li>prev_num初始化為nums[0]，for loop從nums[1]開始，而由於已經sorted：<ol>
<li>若curr_num - prev_num &gt; 1：表示斷掉，新的sequence重新開始，curr_len設為1</li>
<li>若curr_num - prev_num &#x3D;&#x3D; 1：curr_len +&#x3D; 1  </li>
<li>若curr_num - prev_num &#x3D;&#x3D; 0：代表兩個數為duplicates，注意，由先備知識(2)的例子可知此時長度是不會增加的(此題不考慮duplicates)</li>
</ol>
</li>
<li>為了maintain max_len，每一個iteration都要更新max_len &#x3D; max(max_len, curr_len) </li>
<li>每一個iteration都要在下一個iteration開始前更新prev_num為curr_num</li>
</ol>
<h3 id="Method2：hashset-best-solution"><a href="#Method2：hashset-best-solution" class="headerlink" title="Method2：hashset(best solution)"></a>Method2：hashset(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<p>觀念：可以想像陣列存在多個consecutive sequence，對於每一個”starting point”，利用hashset尋找其下一個number直到斷掉為止，如此去maintain max_len</p>
<ol>
<li>先將所有numbers存入set()，以便後續做到O(1)查找</li>
<li>starting point：對於陣列中的任一number，若number - 1不存在於set，則代表其為某個sequence的”starting point”，此時開始去set找它的consecutive number直到找不到，以此去計算該sequence的長度</li>
<li>not starting point：若(2)為False，表示curr_num不是”starting point”，而是存在於某個sequence之間的numbers之一，此時不需要計算長度所以不用做任何事</li>
</ol>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/gas-station/">Gas Station</a></h1><h3 id="Method1：two-pointers-best-solution"><a href="#Method1：two-pointers-best-solution" class="headerlink" title="Method1：two pointers(best solution)"></a>Method1：two pointers(best solution)</h3><p>時間：O(n)</p>
<p>空間：O(1)</p>
<p>觀念：</p>
<ol>
<li><p>將gas, cost兩個陣列想像成一個陣列( arr[i] &#x3D; gas[i] - cost[i] )，arr[i]表示從 i 開到 i + 1所剩下的油量，將arr的每個element加總，由於不論從哪個起始點開始，車子繞一圈相當於就是在將陣列中的所有elements做加總，只是順序不同罷了(起始點不同)，所以：</p>
<ol>
<li>若≥0: 表示一定存在有效的起始點  </li>
<li>反之: 不存在有效起始點</li>
</ol>
</li>
<li><p>此題最關鍵的概念：若從某起始點”s”只能開到另一點”e”，則[s, e]這段區間都不會有有效的起始點，所以此時應該要跨過這個區間直接從”e+1”繼續。</p>
<p> 反證法：假設[s, e]存在有效的起始點</p>
<p> (1)let’s say “s+1”，For sum(s+1, s+2, …, e) &gt; 0，已知起始點(s)必為正，所以sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+1, s+3, …, e) &lt; 0</p>
<p> (2)let’s say “s+2”，For sum(s+2, s+3, …, e) &gt; 0，已知sum(s, s+1)必為正(否則車子早在s+1就沒油了)，因此sum(s, s+1, s+2, …, e) &lt; 0 implies sum(s+2, s+3, …, e) &lt; 0</p>
<p> → 以此類推即可得證。</p>
</li>
<li><p>實際操作：</p>
<ol>
<li>用變數curr_surplus對”當前幾個”elements進行加總，在陣列中的任一位置，若curr_surplus&lt;0表示車只能開到該位置，此時根據觀念(2)，我們將curr_surplus歸零，並把起始點往前拉到該位置的下一個位置，繼續演算法</li>
<li>用變數total_surplus對陣列中的每個elements進行加總，迴圈結束後若total_surplus&lt;0表示不存在有效起始點，反之則存在(此時return該起始點)</li>
<li>若看code會發現一個容易產生疑慮的地方：”start &#x3D; i + 1”這行，不禁讓人思考若i此時為last element則start不是就超出陣列長度了嗎？ ans: 若i為last element且被+1，表示車子開到last position勢必會沒油，而不管從哪個起始點開始繞一圈車子一定會經過last position，所以可得陣列一定不存在有效起始點(i.e. total_surplus勢必&lt;0，return -1)</li>
</ol>
</li>
</ol>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></strong></h1><h1 id="958-Check-Completeness-of-a-Binary-Tree"><a href="#958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="958. Check Completeness of a Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/">958. Check Completeness of a Binary Tree</a></strong></h1><h3 id="complete-binary-tree"><a href="#complete-binary-tree" class="headerlink" title="complete binary tree"></a>complete binary tree</h3><ol>
<li>last level：由左連續排到右，不能斷掉 </li>
<li>other than last level：full binary tree</li>
</ol>
<h3 id="Method1：dfs-label"><a href="#Method1：dfs-label" class="headerlink" title="Method1：dfs(label)"></a>Method1：dfs(label)</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<ol>
<li>利用binary tree的特性：對於任一個node(n)，其left child必為2<em>n，right child必為2</em>n+1，透過此特性可得到任一個node的position，如此traverse整棵樹並搭配$max(maxPos, ;currPos)$每當遇到更大的label就更新max_pos並把結果傳回去，即可得到最大的node label</li>
<li>接續1.，在traverse的過程中一邊計算最大label，一邊去count整棵樹的node數量</li>
<li>最後會得到兩個變數：(1)maxPos , (2)num_nodes，若該棵樹為complete binary tree則它的max_label勢必等於它的總nodes數，反之就不是complete binary tree</li>
</ol>
<h3 id="Method2：bfs"><a href="#Method2：bfs" class="headerlink" title="Method2：bfs"></a>Method2：bfs</h3><p>時間：O(n)</p>
<p>空間：O(n)</p>
<ol>
<li>初始化一個idx，將所有nodes依照level order存進list裡，即對於任一node，依序存入它的left child、right child，直到遇到None就跳出迴圈</li>
<li>延續1.，若該棵樹為complete binary tree，則None的後面不應該有任何node，若有則不是complete binary tree，利用此特性，在1.跳出迴圈後我們會得到一個idx(None的位置)，接著只要檢查idx之後的位置是否存在node即可判斷是不是complete binary tree</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/TheCrack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrancisTan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/TheCrack/" class="post-title-link" itemprop="url">TheCrack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-17 03:08:18 / Modified: 03:09:01" itemprop="dateCreated datePublished" datetime="2023-02-17T03:08:18+08:00">2023-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Find-the-two-sum-link"><a href="#1-Find-the-two-sum-link" class="headerlink" title="1. Find the two sum (link)"></a>1. Find the two sum (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">link</a>)</h1><h2 id="Method-1-Brute-force-O-n-2"><a href="#Method-1-Brute-force-O-n-2" class="headerlink" title="Method 1 : Brute force (O(n^2))"></a>Method 1 : Brute force (O(n^2))</h2><p>觀念：</p>
<ul>
<li>從陣列的第一個值開始，拿target value減current value，然後去找陣列中剩下的值哪個等於complement，如果都沒有的話就將current value移到下一個，依此類推。</li>
<li>當固定某個current value，如果掃過一遍都沒有match的，則該current value就不用再看了</li>
</ul>
<p>Programming：</p>
<ul>
<li>if x in dictionary → 只能用於判斷dictionary的「key」有沒有包含x，不能用於「value」</li>
</ul>
<h2 id="Method-2-Two-pass-hash-map-O-n"><a href="#Method-2-Two-pass-hash-map-O-n" class="headerlink" title="Method 2 : Two pass hash map (O(n))"></a>Method 2 : Two pass hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>先利用dictionary跑一個for loop，將陣列中的值存入(key: array value, value: array index)，再跑一圈for loop遍歷陣列，將complement當作key查找dictionary，如果該值存在且該索引不等於current value的索引，則return兩個值的index。</li>
<li>dictionary的查找每次只需要用到O(1)的時間，因此能夠滿足O(n)。</li>
</ul>
<h1 id="9-Check-if-an-integer-is-a-palindrome-link"><a href="#9-Check-if-an-integer-is-a-palindrome-link" class="headerlink" title="9.Check if an integer is a palindrome (link)"></a>9.Check if an integer is a palindrome (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/submissions/">link</a>)</h1><h2 id="Method3-Revert-half-of-the-number-Olog-n"><a href="#Method3-Revert-half-of-the-number-Olog-n" class="headerlink" title="Method3 : Revert half of the number (Olog(n))"></a>Method3 : <strong><strong>Revert half of the number (Olog(n))</strong></strong></h2><p>作法：</p>
<ul>
<li><p>利用一個變數”reverse”(一開始為0)每次對integer%10去取他的個位數(得到current value)，再將current value + reverse * 10，達到revert的效果</p>
</li>
<li><p>While loop :</p>
<ul>
<li>條件：當reverse &lt; integer</li>
<li>跑完迴圈後要比較兩個number(reverse &amp; integer)，(1)如果integer為奇數位數: revert會比integer多一位(e.g. integer &#x3D;&#x3D; 12, revert &#x3D;&#x3D; 123)   (2)如果integer為偶數位數: integer會剛好等於revert</li>
</ul>
</li>
<li><p>最後：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reverse == integer <span class="keyword">or</span> <span class="built_in">int</span>(reverse/<span class="number">10</span>) == integer:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：一開始要先處理負數、個位數為0的情況(e.g. 4440)，不然reverse會不正確</p>
</li>
</ul>
<h1 id="13-Convert-Roman-numerial-to-integer-link"><a href="#13-Convert-Roman-numerial-to-integer-link" class="headerlink" title="13.Convert Roman numerial to integer (link)"></a>13.Convert Roman numerial to integer (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">link</a>)</h1><h2 id="Method2-Hash-map-O-n"><a href="#Method2-Hash-map-O-n" class="headerlink" title="Method2 : Hash map (O(n))"></a>Method2 : Hash map (O(n))</h2><p>觀念：</p>
<ul>
<li>利用一個dictionary去紀錄roman numerial所代表的數字</li>
<li>用一個for loop遍歷string，依照roman numerial的規則，如果current value &lt; next value，則代表current value需要被扣掉（須注意在比較current, next的大小時，next value不能超過string的長度）</li>
</ul>
<h1 id="14-Find-the-longest-common-prefix-link"><a href="#14-Find-the-longest-common-prefix-link" class="headerlink" title="14.Find the longest common prefix (link)"></a>14.Find the longest common prefix (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">link</a>)</h1><h2 id="Method1-Vertical-scanning-O-N-M"><a href="#Method1-Vertical-scanning-O-N-M" class="headerlink" title="Method1 : Vertical scanning (O(N*M))"></a>Method1 : Vertical scanning (O(N*M))</h2><p>觀念：</p>
<ul>
<li>直接以第一個string為比對基準，每次取一個character出來和list裡的其他string相比，如果based string的長度超過了某個其他string，或是當based string和任一string不相等時，則return目前取到的string</li>
<li>最差的情況為list裡的所有string都相等，這樣等於要把所有的character都看過一遍才可以return，意即O(N*M)</li>
</ul>
<h2 id="Method2-Compare-the-most-two-different-strings-O-N-M"><a href="#Method2-Compare-the-most-two-different-strings-O-N-M" class="headerlink" title="Method2 : Compare the most two different strings (O(N*M))"></a>Method2 : Compare the most two different strings (O(N*M))</h2><p>觀念：</p>
<ul>
<li>利用function min( ), max( ) 分別找出alphabet排序最前面和最後面的string，再比較此兩個strings，return答案。</li>
<li>由於min, max讓我們得到list中差異最大的兩個strings，直接比較這兩個strings就可代表其他所有的strings，我們無需再對其他的strings作比對。</li>
</ul>
<h1 id="20-Valid-Parentheses（link）"><a href="#20-Valid-Parentheses（link）" class="headerlink" title="20.Valid Parentheses（link）"></a>20.<strong>Valid Parentheses（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">link</a>）</strong></h1><h2 id="Method1-Using-hash-map-and-stack-O-N"><a href="#Method1-Using-hash-map-and-stack-O-N" class="headerlink" title="Method1 : Using hash map and stack (O(N))"></a>Method1 : Using hash map and stack (O(N))</h2><p>觀念：</p>
<ul>
<li>hash map: 把左括號當作key, 右括號當作value。</li>
<li>stack: 只要是左括號就push, 右括號就pop。</li>
<li>如果current char為右括號，須檢查stack是否為empty以及current char和stack裡的top char是否配對，若沒有則return false。</li>
<li>最後若stack不為empty表示有左括號沒被配對到，則return false，否則就return true。</li>
</ul>
<h1 id="21-Merge-two-sorted-lists-singly-linked-list-link-reference"><a href="#21-Merge-two-sorted-lists-singly-linked-list-link-reference" class="headerlink" title="21.Merge two sorted lists (singly linked list) (link, reference)"></a>21.Merge two sorted lists (singly linked list) (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">link</a>, <a target="_blank" rel="noopener" href="https://medium.com/@tobby168/%E7%94%A8python%E5%AF%A6%E4%BD%9Clinked-list-524441133d4d">reference</a>)</h1><h2 id="Method1-Using-the-concept-of-“merge-sort”"><a href="#Method1-Using-the-concept-of-“merge-sort”" class="headerlink" title="Method1 : Using the concept of “merge sort”"></a>Method1 : Using the concept of “merge sort”</h2><p>time: O(m+n), given that m, n are the length of two lists respectively</p>
<p>space: O(1)</p>
<p>觀念：</p>
<ol>
<li><p>linked list起手式：要用node.next &#x3D; …去把鏈結串起來，不能直接assign(因為會改變記憶體位置) e.g y &#x3D; 5 → x &#x3D; y → y &#x3D; 8 —&gt; (x, y) &#x3D; (5, 8)  </p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node = ListNode()</span><br><span class="line">head = node</span><br><span class="line"><span class="keyword">while</span> ... :</span><br><span class="line">	node.<span class="built_in">next</span> = ...</span><br><span class="line">	node = node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>traverse的時候不用另外再創建新的ListNode，應該要直接用list裡面的node去串接以節省記憶體空間，實踐方法為利用一個nxt變數先保存curr_node.next，再將current_node斷掉來直接取用current_node，最後再將current_node接回nxt變數即可達到inplace traverse。</p>
</li>
</ol>
<h1 id="26-Remove-Duplicates-from-Sorted-Array-link"><a href="#26-Remove-Duplicates-from-Sorted-Array-link" class="headerlink" title="26.Remove Duplicates from Sorted Array (link)"></a>26.<strong>Remove Duplicates from Sorted Array (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a>)</strong></h1><h2 id="Method1-Just-delete-it"><a href="#Method1-Just-delete-it" class="headerlink" title="Method1 : Just delete it"></a>Method1 : Just delete it</h2><p>觀念：</p>
<ul>
<li>若遇到duplicates，則利用function remove(”value”)直接把它刪掉，否則就跳到下一個繼續檢查 。</li>
<li>function remove(”value” ) : 會刪掉陣列中第一個符合”value”的element。</li>
</ul>
<h2 id="Method2-Take-advantage-of-the-property-of-non-decreasing-order"><a href="#Method2-Take-advantage-of-the-property-of-non-decreasing-order" class="headerlink" title="Method2 : Take advantage of the property of non-decreasing order"></a>Method2 : Take advantage of the property of non-decreasing order</h2><p>觀念：</p>
<ul>
<li>利用一個變數(e.g. “ind”)去紀錄前幾個sorted values的位置，接著一個個比大小，若找到比較大的值(代表非duplicates)就將該值插到前面，最後return ind。</li>
</ul>
<h1 id="27-Remove-Elements-link"><a href="#27-Remove-Elements-link" class="headerlink" title="27.Remove Elements (link)"></a>27.<strong>Remove Elements (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">link</a>)</strong></h1><h2 id="Method2-Check-and-insert"><a href="#Method2-Check-and-insert" class="headerlink" title="Method2 : Check and insert"></a>Method2 : Check and insert</h2><p>觀念：</p>
<ul>
<li>利用一個for loop遍歷整個list，如果current element和題目給的val不相等，則將他插入前面，最後return “first part of sorted array”</li>
</ul>
<h1 id="35-Search-Insertion-Position-link"><a href="#35-Search-Insertion-Position-link" class="headerlink" title="35.Search Insertion Position (link)"></a>35.<strong>Search Insertion Position (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/">link</a>)</strong></h1><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search :"></a>Binary Search :</h2><ul>
<li>two pointers : left, right</li>
<li>middle : $(left+right);&#x2F;&#x2F;;2$ → (1)目標為奇數個: middle在正中間 (2)目標為偶數個: middle在中間偏前面的位置</li>
<li>每一個iteration透過移動left or right把當前問題減半直到找到目標值或是當前問題無法再被減少</li>
</ul>
<h2 id="Method1-iterative-binary-search"><a href="#Method1-iterative-binary-search" class="headerlink" title="Method1 : iterative binary search"></a>Method1 : iterative binary search</h2><p>時間：O(logn)</p>
<p>空間：O(1)</p>
<p>主體：middle和目標值比大小</p>
<ol>
<li><p>while condition：left &lt; right<br>why &lt; rather than ≤ → 試想當目標被我們減少到只剩一個時，此時left, right, middle指在同個位置，而若target又剛好小於middle，這時透過right &#x3D; middle並無法縮減目標，會陷入infinite while loop，e.g. nums &#x3D; [8], target &#x3D; 7</p>
</li>
<li><p>$if;middle &#x3D;&#x3D;target:;return ;midddle$ </p>
<p> $if;middle &gt; target:;search;left;half$ → right &#x3D; middle</p>
<p> $if;middle &lt; target:;search;right;half$ → left &#x3D; middle + 1</p>
</li>
<li><p>edge case：若while loop結束還沒有return，代表target不在陣列裡，此時分成兩種情況</p>
<ol>
<li>target要被插在陣列的中間某個位置 → return left or right</li>
<li>target大於陣列所有的值，此時要被插在最後面 → return len(arr)</li>
</ol>
</li>
</ol>
<h2 id="Method2-recursive-binary-search"><a href="#Method2-recursive-binary-search" class="headerlink" title="Method2 : recursive binary search"></a>Method2 : recursive binary search</h2><p>時間：O(logn)</p>
<p>空間：O(logn)</p>
<p>主體：（略）</p>
<h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-last-word/">Length of Last Word</a></h1><h2 id="Method-Naive"><a href="#Method-Naive" class="headerlink" title="Method : Naive"></a>Method : Naive</h2><p>觀念：</p>
<ul>
<li>loop由後往前掃，用一個variable去紀錄last word的長度，如果不是empty string就++，所以如果current value為empty string且variable又不為零，代表loop遇到了last word之後(由後往前)的第一個斷點，此時可以return result。</li>
</ul>
<h2 id="Method-Using-module"><a href="#Method-Using-module" class="headerlink" title="Method : Using module"></a>Method : Using module</h2><p>觀念：</p>
<ul>
<li>利用”string”.split( )，當此function的parameter為None時，它會自動將空格、換行等當作separator，並回傳一個string list，此時return len(list[-1])即是答案。</li>
</ul>
<h1 id="66-Plus-one"><a href="#66-Plus-one" class="headerlink" title="66. Plus one"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. Plus one</a></h1><h2 id="Method1-convert-to-integer-and-increment-it"><a href="#Method1-convert-to-integer-and-increment-it" class="headerlink" title="Method1 : convert to integer and increment it"></a>Method1 : convert to integer and increment it</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>Note：</p>
<ol>
<li>join( )只能用在string iterable(e.g. string, string list)</li>
<li>map(<function>, <iterable>)可以但不限於用在list，但其return的是一個物件，要把他再轉成list</li>
</ol>
<p>觀念：把陣列中的每個數字合併成一個string，再把他轉成integer後+1，再轉回string回傳整數陣列</p>
<h2 id="Method2-digits-operation"><a href="#Method2-digits-operation" class="headerlink" title="Method2 : digits operation"></a>Method2 : digits operation</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：由後往前遍歷，如果不是9就直接+1回傳，否則就更新為0</p>
<p>注意：如果the most significant number是9且需要進位，則最後回傳會多一位，e.g. num &#x3D; [9, 9]，return [1, 0, 0]</p>
<h1 id="67-Add-binary"><a href="#67-Add-binary" class="headerlink" title="67. Add binary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/">67. Add binary</a></h1><h2 id="Method-math"><a href="#Method-math" class="headerlink" title="Method : math"></a>Method : math</h2><p>觀念：</p>
<ol>
<li>數學進位題要想到”%” operation</li>
</ol>
<p>主體：</p>
<ol>
<li>利用兩個pointer分別代表兩個str的index，將對應的每一位相加並且由右往左算，額外利用一個bool去判斷是否需要進位，如此算出answer的每一位char，即$ans&#x3D;curr%2;+;ans$  </li>
<li>注意：有種special case需要在head新增”1”，e.g. 11 + 1 &#x3D; 100</li>
</ol>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></strong></h1><h2 id="Method-calculate-the-arrangement-and-combination-排列組合"><a href="#Method-calculate-the-arrangement-and-combination-排列組合" class="headerlink" title="Method : calculate the arrangement and combination(排列組合)"></a>Method : calculate the arrangement and combination(排列組合)</h2><p>觀念：</p>
<ul>
<li>把該值想成是很多‘2’和’1’的組合，而計算出這些可能的排列組合即為題目所求。<br>排列組合的公式：(total amount of numbers)!  &#x2F;  (the amount of number which are in the same catogory)! multiplied by each other</li>
<li>先算出2最多可能有幾個(e.g. “5”→2, “12”→6)，而每一次iteration拿題目給的value扣掉2 * ”2的個數”所剩即為”1的個數”，由此去計算每一種組合(e.g. “4”→[ (一個2+兩個1), (兩個2+零個1) ] )的可能排列，即可得出答案。</li>
<li>階乘的計算：math.factorial(”number”)<br>e.g. math.factorial(5) &#x3D; 5! , math.factorial(0) &#x3D; 0! &#x3D; 1</li>
</ul>
<h1 id="83-Remove-Duplicates-From-Sorted-Linked-List"><a href="#83-Remove-Duplicates-From-Sorted-Linked-List" class="headerlink" title="83. Remove Duplicates From Sorted Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates From Sorted Linked List</a></h1><h2 id="Method-connect-the-“next”-to-the-“next-next”"><a href="#Method-connect-the-“next”-to-the-“next-next”" class="headerlink" title="Method : connect the “next” to the “next next”"></a>Method : connect the “next” to the “next next”</h2><p>觀念：</p>
<ul>
<li>Traverse整個linked list，當current value &#x3D;&#x3D; next value就把current node的next接到next next，如此達到delete的效果，若current value !&#x3D; next value就(head &#x3D; head.next)繼續traverse下去。</li>
</ul>
<h1 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h1><h2 id="Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort"><a href="#Method1-create-new-list-from-the-first-m-elements-of-nums1-and-use-Merge-Sort" class="headerlink" title="Method1 : create new list from the first m elements of nums1 and use Merge Sort"></a>Method1 : create new list from the first m elements of nums1 and use Merge Sort</h2><p>觀念：</p>
<ul>
<li>將first m elements of nums1擷取出來，再和nums2比大小（Merge Sort），這邊可以將排序後的elements放進新的陣列，也可以inplace放進nums1裡面。</li>
</ul>
<h2 id="Method2-Using-the-reverse-index（link）"><a href="#Method2-Using-the-reverse-index（link）" class="headerlink" title="Method2 : Using the reverse index（link）"></a>Method2 : Using the reverse index（<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/discuss/785646/Python-3-greater-99.78-faster">link</a>）</h2><p>觀念：</p>
<ul>
<li>利用reverse index將first m elements of nums1 and total nums2由後往前比，較大的就插入nums1的last element，直到兩個陣列其中一個被traverse完為止，而最後還沒被traverse完的那個陣列若是nums1則不用做任何事（因為題目所求為nums1的inplace），但若是nums2則要將nums2內剩下的所有elements依序插入nums1。</li>
</ul>
<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h1><p>Inorder Traversal:</p>
<ul>
<li>traverse left subtree</li>
<li>do something with root value</li>
<li>traverse right sub tree</li>
</ul>
<h2 id="Method1-depth-first-search-recursion"><a href="#Method1-depth-first-search-recursion" class="headerlink" title="Method1 : depth-first-search(recursion)"></a>Method1 : depth-first-search(recursion)</h2><p>觀念：</p>
<ul>
<li>先往左下探到底，直到root.left為None的時候再將root.val append到list，接著traverse root.right。</li>
<li>每個遞迴都會創建一個新的list，如此利用list +&#x3D; list的方式將每次遞迴所return的陣列接起來。</li>
</ul>
<h2 id="Method1-depth-first-search-stack"><a href="#Method1-depth-first-search-stack" class="headerlink" title="Method1 : depth-first-search(stack)"></a>Method1 : depth-first-search(stack)</h2><p>觀念：</p>
<ul>
<li>一樣先往左traverse並將沿路看到的nodes push到stack裡，直到遇到null node時，就將stack的top node pop出來並放到result list，再將root更新為popedNode.right，只要stack不為empty且root ≠ null就繼續重複上述動作直到return。</li>
<li>此做法即是利用stack後進先出的特性，由於我們都是優先往左traverse，而根據Inorder traversal的特性越靠左下角的node越會先被traverse到，所以當我們撞到null node時，只要將stack pop出來，再把root移到popedNode.right繼續traverse，即可得到題目所求。</li>
</ul>
<h1 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h1><h2 id="Method1-“just-compare-both-of-them”-recursion"><a href="#Method1-“just-compare-both-of-them”-recursion" class="headerlink" title="Method1 : “just compare both of them”(recursion)"></a>Method1 : “just compare both of them”(recursion)</h2><p>觀念：</p>
<p>直接比對兩個tree(true or false)：</p>
<ul>
<li>若兩者皆為null → true</li>
<li>若其中一個為null → false</li>
<li>若都不是null(都有值) → (1)值不相等: false (2)值相等: look further</li>
</ul>
<h1 id="106-Convert-sorted-array-to-bst"><a href="#106-Convert-sorted-array-to-bst" class="headerlink" title="106. Convert sorted array to bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">106. Convert sorted array to bst</a></h1><h2 id="Method1-recursive"><a href="#Method1-recursive" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>觀念：</p>
<p>先找到middle value並initialize為root，middle value的左邊都小於自己，所以要放到root.left，相反地，將middle value的右邊都放到root.right，最後return root。</p>
<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a></h1><h2 id="Method1-recursion"><a href="#Method1-recursion" class="headerlink" title="Method1 : recursion"></a>Method1 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(logn)$</p>
<p>觀念：</p>
<h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></strong></h1><h2 id="Method1-recursive-postorder-traversal"><a href="#Method1-recursive-postorder-traversal" class="headerlink" title="Method1 : recursive(postorder traversal)"></a>Method1 : recursive(postorder traversal)</h2><p>觀念：</p>
<ul>
<li><p>postorder traversal</p>
</li>
<li><p>終止條件：null node → return 0(什麼都沒有)</p>
</li>
<li><p>遞迴：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftNodes = func(root.left)</span><br><span class="line">rightNodes = func(root.right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當$abs(leftNodes - rightNodes) &gt;&#x3D; 2$時，表示已經出現unbalanced情形所以其他的部分都不重要了(現在只要想辦法把這個結果一路傳回root)，於是return -1(這邊-1只是為了標記沒有其他含義)</li>
<li>當$leftNodes&#x3D;&#x3D;-1 ;||; rightNodes&#x3D;&#x3D;-1$，表示先前已經找到unbalanced，所以繼續return -1</li>
<li>當1.和2.都沒發生，則$return;1+max(leftNodes, ;rightNodes)$，要用max是因為對於任一個node來說，當出現左右不對稱情形，會用較深的那邊表示該節點的高度。</li>
</ol>
</li>
</ul>
<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></strong></h1><h2 id="Method-dfs-postorder-traversal"><a href="#Method-dfs-postorder-traversal" class="headerlink" title="Method : dfs(postorder traversal)"></a>Method : dfs(postorder traversal)</h2><p>時間：O(n)</p>
<p>空間：O(h)</p>
<p>觀念： </p>
<ol>
<li><p>當left_nodes和right_nodes其中一個為0且另一個不為0，代表只有一條路可以到leaf node(不為零的那條)，所以要return 1 + max(left_nodes, right_nodes)</p>
</li>
<li><p>除了1.以外的情況可再分為兩種：</p>
<ol>
<li>兩條路都可走：由於是找最短路徑，所以要走nodes較少的那條</li>
<li>兩條路都不可走：代表current node為leaf node(left &amp; right &#x3D;&#x3D; 0)</li>
</ol>
<p> 綜合a,b → return 1 + min(left_nodes, right_nodes)</p>
</li>
</ol>
<h1 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/description/">112. Path Sum</a></strong></h1><h2 id="Method1-recursive-1"><a href="#Method1-recursive-1" class="headerlink" title="Method1 : recursive"></a>Method1 : recursive</h2><p>time: $O(n)$ , space: </p>
<p>觀念：</p>
<ul>
<li><p>由於是要traverse到leaf node，不太可能先”遞迴”再”做事”，所以為preorder traversal</p>
</li>
<li><p>終止條件：null node → return False</p>
</li>
<li><p>遞迴：</p>
<p>  由於要做加總，所以要把”total一路傳下去到leaf node”，而target也要傳因為要做比對</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = func(root.left, total, target)</span><br><span class="line">r = func(root.right, total, target)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主體：</p>
<ol>
<li>當left或right其中一邊為True表示找到了sum path，這時return True，把True這個資訊接續傳上去</li>
<li>除了1.以外的情況，表示兩邊都是False(沒有找到)，這時就要看current node的total是否等於target sum，且因為題目限制為leaf node，所以要限制條件為沒有children node</li>
<li>如果1. 2.都不符合表示沒戲了，直接return False</li>
</ol>
</li>
</ul>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/description/">118. Pascal’s Triangle</a></strong></h1><h2 id="Method1-double-for-loops"><a href="#Method1-double-for-loops" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>觀念：</p>
<ul>
<li>由於return format為2d array → 直覺想到double for loops</li>
<li>架構：<ol>
<li>第一圈為2d array內所有sub array的iterations，也就是題目的numRows</li>
<li>第二圈為每個sub array內integer的iterations</li>
</ol>
</li>
<li>主體：<ol>
<li>對於triangle每一層的integer，只要是頭或尾都必為1</li>
<li>若不符合1.，代表是位於中間的integer，因此若我們假設current position為”i”，則其值為$prevArray[i];+;prevArray[i+1]$</li>
</ol>
</li>
</ul>
<h1 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/description/">119. Pascal’s Triangle II</a></strong></h1><h2 id="Method1-double-for-loops-1"><a href="#Method1-double-for-loops-1" class="headerlink" title="Method1 : double for loops"></a>Method1 : double for loops</h2><p>time: $O(n^2)$ , space: $O(n^2)$</p>
<p>觀念：跟118.一樣，只是變成return最後一個array</p>
<h2 id="Method2-Mathematics"><a href="#Method2-Mathematics" class="headerlink" title="Method2 : Mathematics"></a>Method2 : Mathematics</h2><p>time: $O(n^2)$ , space: $O(n)$</p>
<p>觀念：帕斯克三角形第i列的第j個值為 → $C^i_j$ （i, j為0-indexed, 利用模組math的函式factorial計算）</p>
<p>→ $\frac{factorial(i)}{factorial(j)*factorial(i-j)}$</p>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Window-Sliding" class="headerlink" title="121. Best Time to Buy and Sell Stock(Window Sliding)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a>(<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/window-sliding-technique/">Window Sliding</a>)</strong></h1><h2 id="Method1-Window-Sliding-two-pointers"><a href="#Method1-Window-Sliding-two-pointers" class="headerlink" title="Method1 : Window Sliding(two pointers)"></a>Method1 : Window Sliding(two pointers)</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>profit最重要的就是買、賣價 → 所以想到用two pointers去紀錄</li>
<li>架構：初始化purchase_price、max_profit，一邊維護這兩個變數一邊遍歷陣列</li>
<li>主體：<ol>
<li>先比較current price和purchase_price<ol>
<li>current price &lt; purchase_price → 無利可圖，但需要更新purchase_price(買低就是賺)</li>
<li>current price ≥ purchase_price → 去看max_profit</li>
</ol>
</li>
<li>若情況為1-b，看當前利潤是否大於最大利潤 → $max(maxProfit,;currentPrice;-;purchasePrice)$</li>
</ol>
</li>
</ul>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></strong></h1><h2 id="Method-traverse-forward-and-backward-synchronously"><a href="#Method-traverse-forward-and-backward-synchronously" class="headerlink" title="Method : traverse forward and backward synchronously"></a>Method : traverse forward and backward synchronously</h2><p>time : O(n)</p>
<p>space : O(1)</p>
<p>補充：</p>
<ol>
<li>letters的大小寫轉換：string.upper() , string.lower()</li>
<li>判斷是否為letters or numbers：isalnum(<string>)</li>
</ol>
<p>觀念：</p>
<p>題目所給的string包含許多不是alphanumeric的符號，而palindrome的前後比對必須是pairs by pairs，所以當前或後遇到不是alphanumeric的時候必須跳過，只有當前後都為alphanumeric時才有比較的意義</p>
<h1 id="136-Single-Number-Wiki-XOR"><a href="#136-Single-Number-Wiki-XOR" class="headerlink" title="136. Single Number (Wiki: XOR)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/description/">136. Single Number</a> (<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">Wiki: XOR</a>)</strong></h1><h2 id="Method1-sort-it-first-then-compare-them"><a href="#Method1-sort-it-first-then-compare-them" class="headerlink" title="Method1 : sort it first, then compare them"></a>Method1 : sort it first, then compare them</h2><p>time: $O(nlogn)$ → the cost of built-in function sorted( ), note that every compare-based sorting algorithm at least cost nlogn</p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li><p>排序後一樣的number會比鄰排在一起</p>
</li>
<li><p>主體：</p>
<p>  每個number和它下一個比，如果一樣就跳到下下個繼續比，如果不一樣就return single number</p>
<ol>
<li>single number位在array的”非最後位置” → 發現不一樣時，single number一定是current number</li>
<li>single number位在array的最後 → 若已經看到最後一個位置，代表前面的numbers都是duplicates，這時不能和下一個比，直接return current number。</li>
</ol>
</li>
</ul>
<h2 id="Method2-XOR"><a href="#Method2-XOR" class="headerlink" title="Method2 : XOR"></a>Method2 : XOR</h2><p>time: $O(n)$ , space: $O(1)$</p>
<p>XOR：</p>
<ol>
<li><p>同性相斥：同樣的boolean: return False , 同樣的integer: return 0</p>
<p> e.g.</p>
<table>
<thead>
<tr>
<th>(a,b)</th>
<th>a^b</th>
</tr>
</thead>
<tbody><tr>
<td>(True, False)</td>
<td>True</td>
</tr>
<tr>
<td>(True, True)</td>
<td>False</td>
</tr>
<tr>
<td>(100, 0)</td>
<td>100</td>
</tr>
<tr>
<td>(100, 100)</td>
<td>0</td>
</tr>
<tr>
<td>(100, 10)</td>
<td>some number</td>
</tr>
</tbody></table>
</li>
<li><p>a^b^c^b^c &#x3D; b^b^c^c^a &#x3D; a</p>
</li>
</ol>
<p>觀念：0有還原某個數的特性 → 0^100 &#x3D; 100 , 0^0 &#x3D; 0，所以利用上述2.的特性，初始化一個變數為0，讓他去和整個array的number作XOR即可得到single number</p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></strong></h1><h2 id="Method1-hash-map"><a href="#Method1-hash-map" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：</p>
<ul>
<li><p>Node的結構為object，實質為某個unique的記憶體位址，所以即便有兩個node.val一樣，他們對於記憶體而言仍然是兩個不同的東西，利用此特性去儲存traverse到的每個node，就可以判斷是否有cycle</p>
</li>
<li><p>主體：</p>
<p>  儲存traverse過的每個node，如此判斷同一個node是否重複出現</p>
<ol>
<li><p>由於儲存的方式不用去管順序，且希望使用O(1)查找，所以適合用set( ) （<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-set.html">set相關用法</a>）</p>
<p> <em>→ set( ) is an unsorted and unique data structure</em></p>
</li>
<li><p>檢查每個node是否已在set( )內，如果有就代表出現cycle → return True，否則就將current node存到set( )</p>
</li>
<li><p>若traverse完整個node list都沒有return則代表沒有出現cycle → return False</p>
</li>
</ol>
</li>
</ul>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists</a></strong></h1><h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169. Majority Element</a></strong></h1><h2 id="Method1-hash-map-1"><a href="#Method1-hash-map-1" class="headerlink" title="Method1 : hash map"></a>Method1 : hash map</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：利用一個dictionary去統計不同數字出現的次數，直到發現某數的次數$&gt;\frac{1}{2}n$時就return該數</p>
<h2 id="Method2-Boyer-Moore-Voting-Algorithm-多數投票算法"><a href="#Method2-Boyer-Moore-Voting-Algorithm-多數投票算法" class="headerlink" title="Method2 : Boyer-Moore Voting Algorithm(多數投票算法)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Method2 :</a> <strong><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">Boyer-Moore Voting Algorithm(多數投票算法)</a></strong></strong></h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：</p>
<ul>
<li>將$majority$想像成一個最強的軍隊，$count$想像成此軍隊的生命值，而其他的數通通組成較弱的一隊，在traverse的過程中如果$current;number&#x3D;&#x3D;majority$，表示他們為同一國的，則$count$+1，反之則為敵人，$count$-1，根據題目由於$majority$的數量一定超過總數的一半，所以可以確保最後必會產生出$majority$(至少剩一命)</li>
<li>注意：$if;count&#x3D;&#x3D;0$，表示目前最強軍隊的人都死光了，那就必須將<em>current number</em>變成新的王</li>
</ul>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel Sheet Column Number</a></strong></h1><h2 id="Method1-進位制"><a href="#Method1-進位制" class="headerlink" title="Method1 : 進位制"></a>Method1 : 進位制</h2><p>time:  O(n)</p>
<p>space: O(1), given the number of alphabet is fixed at 26</p>
<p>觀念：</p>
<ol>
<li>此題考進位制的概念，如同我們熟悉的十進位制計算一般，e.g. $18&#x3D;10^0<em>8;+;10^1</em>1$，英文字母(alphabet)的26進位制也是一樣的概念，e.g. $AB&#x3D;26^0<em>2;+;26^1</em>1&#x3D;28$</li>
<li>迴圈從string的右掃到左比較容易寫</li>
</ol>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></strong></h1><p>先備知識：</p>
<ol>
<li>Bits(Binary digits)：為二元進位的意思，每一位為0或1，e.g. 32bits的意思即為用32個位置的0或1來表示某一個數，沒用到的位置補零(補在前面)</li>
<li>function bin(<int>)：將integer轉成二進位制，return format為string，使用上通常為bin(<int>)[2:]，其中[2:]是為了省略開頭的”0b…”</li>
<li>int(<str>, <int>)：將<int>進位制的<str>轉換為一般的10進位制int，e.g. int(”0110”, 2) → 6</li>
</ol>
<h2 id="Method1-Just-coding"><a href="#Method1-Just-coding" class="headerlink" title="Method1 : Just coding"></a>Method1 : Just coding</h2><p>time:  O(n)</p>
<p>space: O(n) </p>
<p>觀念：</p>
<ol>
<li>利用func bin()將input轉換為二進位制的string，由於題目說input必須是32-bits，而因為func bin()返回的string會自動省略掉前面的0，所以必須將string的前面補零至32個character</li>
<li>reverse(1)得到的32-bits string </li>
<li>最後將reversed string利用func int()轉回正常的10進位int即可得答案</li>
</ol>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">20<strong>6. Reverse Linked List</strong></a></h1><h2 id="Method1-iterative"><a href="#Method1-iterative" class="headerlink" title="Method1 : iterative"></a>Method1 : iterative</h2><p>time: $O(n)$ </p>
<p>space: $O(1)$</p>
<p>觀念：想像成這個list會由右往左長，且方向是往右指</p>
<ol>
<li>初始化一個None </li>
<li>主體：每次將head的next紀錄起來，然後就可以將head接到answer node，接著把answer node往左移一格到剛接好的head，如此一來answer node就完成，最後將head指回一開始我們紀錄的next的位置</li>
</ol>
<h2 id="Method2-recursion"><a href="#Method2-recursion" class="headerlink" title="Method2 : recursion"></a>Method2 : recursion</h2><p>time: $O(n)$ </p>
<p>space: $O(n)$</p>
<p>觀念：和iterative差不多只是換種寫法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Francis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
